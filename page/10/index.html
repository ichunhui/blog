<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ichunhui.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不忘初心，方得始终.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy&#39;s Blog">
<meta property="og:url" content="https://ichunhui.github.io/page/10/index.html">
<meta property="og:site_name" content="Jimmy&#39;s Blog">
<meta property="og:description" content="不忘初心，方得始终.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jimmy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ichunhui.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jimmy's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Jimmy's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jimmy's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">靡不有初，鲜克有终.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">192</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">114</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">41</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/ichunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/65d37753.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/65d37753.html" class="post-title-link" itemprop="url">Logstash 运维</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elastic/" itemprop="url" rel="index"><span itemprop="name">Elastic</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/65d37753.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="65d37753.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="logstash-运维"><a class="markdownIt-Anchor" href="#logstash-运维"></a> Logstash 运维</h1>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash</a> 是开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。</p>
</blockquote>
<h2 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h2>
<h3 id="11-安装步骤"><a class="markdownIt-Anchor" href="#11-安装步骤"></a> 1.1. 安装步骤</h3>
<p>安装步骤如下：</p>
<p>（1）在 <a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/logstash">logstash 官方下载地址</a>下载所需版本包并解压到本地。</p>
<p>（2）添加一个 <code>logstash.conf</code> 文件，指定要使用的插件以及每个插件的设置。举个简单的例子：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123; <span class="keyword">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123; hosts <span class="operator">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; codec <span class="operator">=&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）运行 <code>bin/logstash -f logstash.conf</code> （Windows 上运行<code>bin/logstash.bat -f logstash.conf</code>）</p>
<h2 id="2-配置"><a class="markdownIt-Anchor" href="#2-配置"></a> 2. 配置</h2>
<h3 id="21-设置文件"><a class="markdownIt-Anchor" href="#21-设置文件"></a> 2.1. 设置文件</h3>
<ul>
<li><strong><code>logstash.yml</code></strong>：logstash 的默认启动配置文件</li>
<li><strong><code>jvm.options</code></strong>：logstash 的 JVM 配置文件。</li>
<li><strong><code>startup.options</code></strong> (Linux)：包含系统安装脚本在 <code>/usr/share/logstash/bin</code> 中使用的选项为您的系统构建适当的启动脚本。安装 Logstash 软件包时，系统安装脚本将在安装过程结束时执行，并使用 <code>startup.options</code> 中指定的设置来设置用户，组，服务名称和服务描述等选项。</li>
</ul>
<h3 id="22-logstashyml-设置项"><a class="markdownIt-Anchor" href="#22-logstashyml-设置项"></a> 2.2. logstash.yml 设置项</h3>
<p>节选部分设置项，更多项请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html">https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.name</code></td>
<td>节点名</td>
<td>机器的主机名</td>
</tr>
<tr>
<td><code>path.data</code></td>
<td>Logstash 及其插件用于任何持久性需求的目录。</td>
<td><code>LOGSTASH_HOME/data</code></td>
</tr>
<tr>
<td><code>pipeline.workers</code></td>
<td>同时执行管道的过滤器和输出阶段的工作任务数量。如果发现事件正在备份，或 CPU 未饱和，请考虑增加此数字以更好地利用机器处理能力。</td>
<td>Number of the host’s CPU cores</td>
</tr>
<tr>
<td><code>pipeline.batch.size</code></td>
<td>尝试执行过滤器和输出之前，单个工作线程从输入收集的最大事件数量。较大的批量处理大小一般来说效率更高，但是以增加的内存开销为代价。您可能必须通过设置 <code>LS_HEAP_SIZE</code> 变量来有效使用该选项来增加 JVM 堆大小。</td>
<td><code>125</code></td>
</tr>
<tr>
<td><code>pipeline.batch.delay</code></td>
<td>创建管道事件批处理时，在将一个尺寸过小的批次发送给管道工作任务之前，等待每个事件需要多长时间（毫秒）。</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>pipeline.unsafe_shutdown</code></td>
<td>如果设置为 true，则即使在内存中仍存在 inflight 事件时，也会强制 Logstash 在关闭期间退出。默认情况下，Logstash 将拒绝退出，直到所有接收到的事件都被推送到输出。启用此选项可能会导致关机期间数据丢失。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>path.config</code></td>
<td>主管道的 Logstash 配置路径。如果您指定一个目录或通配符，配置文件将按字母顺序从目录中读取。</td>
<td>Platform-specific. See [<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/6.1/docs/static/settings-file.asciidoc#dir-layout">dir-layout]</a>.</td>
</tr>
<tr>
<td><code>config.string</code></td>
<td>包含用于主管道的管道配置的字符串。使用与配置文件相同的语法。</td>
<td>None</td>
</tr>
<tr>
<td><code>config.test_and_exit</code></td>
<td>设置为 true 时，检查配置是否有效，然后退出。请注意，使用此设置不会检查 grok 模式的正确性。 Logstash 可以从目录中读取多个配置文件。如果将此设置与 log.level：debug 结合使用，则 Logstash 将记录组合的配置文件，并注掉其源文件的配置块。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.automatic</code></td>
<td>设置为 true 时，定期检查配置是否已更改，并在配置更改时重新加载配置。这也可以通过 SIGHUP 信号手动触发。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.interval</code></td>
<td>Logstash 检查配置文件更改的时间间隔。</td>
<td><code>3s</code></td>
</tr>
<tr>
<td><code>config.debug</code></td>
<td>设置为 true 时，将完全编译的配置显示为调试日志消息。您还必须设置<code>log.level：debug</code>。警告：日志消息将包括任何传递给插件配置作为明文的“密码”选项，并可能导致明文密码出现在您的日志！</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.support_escapes</code></td>
<td>当设置为 true 时，带引号的字符串将处理转义字符。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>modules</code></td>
<td>配置时，模块必须处于上表所述的嵌套 YAML 结构中。</td>
<td>None</td>
</tr>
<tr>
<td><code>http.host</code></td>
<td>绑定地址</td>
<td><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td><code>http.port</code></td>
<td>绑定端口</td>
<td><code>9600</code></td>
</tr>
<tr>
<td><code>log.level</code></td>
<td>日志级别。有效选项：fatal &gt; error &gt; warn &gt; info &gt; debug &gt; trace</td>
<td><code>info</code></td>
</tr>
<tr>
<td><code>log.format</code></td>
<td>日志格式。json （JSON 格式）或 plain （原对象）</td>
<td><code>plain</code></td>
</tr>
<tr>
<td><code>path.logs</code></td>
<td>Logstash 自身日志的存储路径</td>
<td><code>LOGSTASH_HOME/logs</code></td>
</tr>
<tr>
<td><code>path.plugins</code></td>
<td>在哪里可以找到自定义的插件。您可以多次指定此设置以包含多个路径。</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="3-启动"><a class="markdownIt-Anchor" href="#3-启动"></a> 3. 启动</h2>
<h3 id="31-命令行"><a class="markdownIt-Anchor" href="#31-命令行"></a> 3.1. 命令行</h3>
<p>通过命令行启动 logstash 的方式如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bin</span>/logstash<span class="meta"> [options]</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>options</code> 是您可以指定用于控制 Logstash 执行的命令行标志。</p>
<p>在命令行上设置的任何标志都会覆盖 Logstash 设置文件（<code>logstash.yml</code>）中的相应设置，但设置文件本身不会更改。</p>
<blockquote>
<p><strong>注</strong></p>
<p>虽然可以通过指定命令行参数的方式，来控制 logstash 的运行方式，但显然这么做很麻烦。</p>
<p>建议通过指定配置文件的方式，来控制 logstash 运行，启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>
<p>若想了解更多的命令行参数细节，请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html">https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html</a></p>
</blockquote>
<h3 id="32-配置文件"><a class="markdownIt-Anchor" href="#32-配置文件"></a> 3.2. 配置文件</h3>
<p>上节，我们了解到，logstash 可以执行 <code>bin/logstash -f logstash.conf</code> ，按照配置文件中的参数去覆盖默认设置文件（<code>logstash.yml</code>）中的设置。</p>
<p>这节，我们就来学习一下这个配置文件如何配置参数。</p>
<h4 id="321-配置文件结构"><a class="markdownIt-Anchor" href="#321-配置文件结构"></a> 3.2.1. 配置文件结构</h4>
<p>在工作原理一节中，我们已经知道了 Logstash 主要有三个工作阶段 input 、filter、output。而 logstash 配置文件文件结构也与之相对应：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">input </span><span class="template-variable">&#123;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">filter </span><span class="template-variable">&#123;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">output </span><span class="template-variable">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个部分都包含一个或多个插件的配置选项。如果指定了多个过滤器，则会按照它们在配置文件中的显示顺序应用它们。</p>
</blockquote>
<h4 id="322-插件配置"><a class="markdownIt-Anchor" href="#322-插件配置"></a> 3.2.2. 插件配置</h4>
<p>插件的配置由插件名称和插件的一个设置块组成。</p>
<p>下面的例子中配置了两个输入文件配置：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">&quot;/var/log/messages&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">file</span> &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">&quot;/var/log/apache/access.log&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;apache&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以配置的设置因插件类型而异。你可以参考： <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a>, 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a> 。</p>
<h4 id="323-值类型"><a class="markdownIt-Anchor" href="#323-值类型"></a> 3.2.3. 值类型</h4>
<p>一个插件可以要求设置的值是一个特定的类型，比如布尔值，列表或哈希值。以下值类型受支持。</p>
<ul>
<li>Array</li>
</ul>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">users =&gt; [ &#123;id =&gt; <span class="number">1</span>, name =&gt; bob&#125;, &#123;id =&gt; <span class="number">2</span>, name =&gt; jane&#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>Lists</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">path</span> =&gt; [ <span class="string">&quot;/var/log/messages&quot;</span>, <span class="string">&quot;/var/log/*.log&quot;</span> ]</span><br><span class="line"><span class="attr">uris</span> =&gt; [ <span class="string">&quot;http://elastic.co&quot;</span>, <span class="string">&quot;http://example.net&quot;</span> ]</span><br></pre></td></tr></table></figure>
<ul>
<li>Boolean</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ssl_enable</span> =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Bytes</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;1113&quot;</span>   <span class="comment"># 1113 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;10MiB&quot;</span>  <span class="comment"># 10485760 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;100kib&quot;</span> <span class="comment"># 102400 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;180 mb&quot;</span> <span class="comment"># 180000000 bytes</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Codec</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">codec</span> <span class="operator">=</span>&gt; <span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Hash</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">match</span> <span class="operator">=</span>&gt; &#123;</span><br><span class="line">  <span class="string">&quot;field1&quot;</span> <span class="operator">=</span>&gt; <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="string">&quot;field2&quot;</span> <span class="operator">=</span>&gt; <span class="string">&quot;value2&quot;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Number</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">port</span> <span class="operator">=</span>&gt; <span class="number">33</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Password</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">my_password</span> =&gt; <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>URI</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">my_uri</span> =&gt; <span class="string">&quot;http://foo:bar@example.net&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Path</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">my_path</span> =&gt; <span class="string">&quot;/tmp/logstash&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>String</p>
</li>
<li>
<p>转义字符</p>
</li>
</ul>
<h2 id="4-插件"><a class="markdownIt-Anchor" href="#4-插件"></a> 4. 插件</h2>
<h3 id="41-input"><a class="markdownIt-Anchor" href="#41-input"></a> 4.1. input</h3>
<blockquote>
<p>Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p>
</blockquote>
<h4 id="411-常用-input-插件"><a class="markdownIt-Anchor" href="#411-常用-input-插件"></a> 4.1.1. 常用 input 插件</h4>
<ul>
<li><strong>file</strong>：从文件系统上的文件读取，就像 UNIX 命令 <code>tail -0F</code> 一样</li>
<li>**syslog：**在众所周知的端口 514 上侦听系统日志消息，并根据 RFC3164 格式进行解析</li>
<li>**redis：**从 redis 服务器读取，使用 redis 通道和 redis 列表。 Redis 经常用作集中式 Logstash 安装中的“代理”，它将来自远程 Logstash“托运人”的 Logstash 事件排队。</li>
<li>**beats：**处理由 Filebeat 发送的事件。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a></p>
<h3 id="42-filter"><a class="markdownIt-Anchor" href="#42-filter"></a> 4.2. filter</h3>
<blockquote>
<p>过滤器是 Logstash 管道中的中间处理设备。如果符合特定条件，您可以将条件过滤器组合在一起，对事件执行操作。</p>
</blockquote>
<h4 id="421-常用-filter-插件"><a class="markdownIt-Anchor" href="#421-常用-filter-插件"></a> 4.2.1. 常用 filter 插件</h4>
<ul>
<li>
<p>**grok：**解析和结构任意文本。 Grok 目前是 Logstash 中将非结构化日志数据解析为结构化和可查询的最佳方法。</p>
</li>
<li>
<p>**mutate：**对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段。</p>
</li>
<li>
<p>**drop：**完全放弃一个事件，例如调试事件。</p>
</li>
<li>
<p>**clone：**制作一个事件的副本，可能会添加或删除字段。</p>
</li>
<li>
<p>**geoip：**添加有关 IP 地址的地理位置的信息（也可以在 Kibana 中显示惊人的图表！）</p>
</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a></p>
<h3 id="43-output"><a class="markdownIt-Anchor" href="#43-output"></a> 4.3. output</h3>
<blockquote>
<p>输出是 Logstash 管道的最后阶段。一个事件可以通过多个输出，但是一旦所有输出处理完成，事件就完成了执行。</p>
</blockquote>
<h4 id="431-常用-output-插件"><a class="markdownIt-Anchor" href="#431-常用-output-插件"></a> 4.3.1. 常用 output 插件</h4>
<ul>
<li>**elasticsearch：**将事件数据发送给 Elasticsearch（推荐模式）。</li>
<li>**file：**将事件数据写入文件或磁盘。</li>
<li>**graphite：**将事件数据发送给 graphite（一个流行的开源工具，存储和绘制指标。 <a target="_blank" rel="noopener" href="http://graphite.readthedocs.io/en/latest/%EF%BC%89%E3%80%82">http://graphite.readthedocs.io/en/latest/）。</a></li>
<li>**statsd：**将事件数据发送到 statsd （这是一种侦听统计数据的服务，如计数器和定时器，通过 UDP 发送并将聚合发送到一个或多个可插入的后端服务）。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
<h3 id="44-codec"><a class="markdownIt-Anchor" href="#44-codec"></a> 4.4. codec</h3>
<p>用于格式化对应的内容。</p>
<h4 id="441-常用-codec-插件"><a class="markdownIt-Anchor" href="#441-常用-codec-插件"></a> 4.4.1. 常用 codec 插件</h4>
<ul>
<li>**json：**以 JSON 格式对数据进行编码或解码。</li>
<li>**multiline：**将多行文本事件（如 java 异常和堆栈跟踪消息）合并为单个事件。</li>
</ul>
<p>更多插件请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a></p>
<h2 id="5-实战"><a class="markdownIt-Anchor" href="#5-实战"></a> 5. 实战</h2>
<p>前面的内容都是对 Logstash 的介绍和原理说明。接下来，我们来实战一些常见的应用场景。</p>
<h3 id="51-传输控制台数据"><a class="markdownIt-Anchor" href="#51-传输控制台数据"></a> 5.1. 传输控制台数据</h3>
<blockquote>
<p>stdin input 插件从标准输入读取事件。这是最简单的 input 插件，一般用于测试场景。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>（1）创建 <code>logstash-input-stdin.conf</code> ：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123; <span class="keyword">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123; hosts <span class="operator">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; codec <span class="operator">=&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bin/logstash -f logstash-<span class="built_in">input</span>-<span class="built_in">stdin</span>.conf</span><br></pre></td></tr></table></figure>
<h3 id="52-传输-logback-日志"><a class="markdownIt-Anchor" href="#52-传输-logback-日志"></a> 5.2. 传输 logback 日志</h3>
<blockquote>
<p>elk 默认使用的 Java 日志工具是 log4j2 ，并不支持 logback 和 log4j。</p>
<p>想使用 logback + logstash ，可以使用 <a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 。<a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 提供了 UDP / TCP / 异步方式来传输日志数据到 logstash。</p>
<p>如果你使用的是 log4j ，也不是不可以用这种方式，只要引入桥接 jar 包即可。如果你对 log4j 、logback ，或是桥接 jar 包不太了解，可以参考我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
</blockquote>
<h4 id="521-tcp-应用"><a class="markdownIt-Anchor" href="#521-tcp-应用"></a> 5.2.1. TCP 应用</h4>
<p>logstash 配置：</p>
<p>（1）创建 <code>logstash-input-tcp.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  <span class="comment"># stdin &#123; &#125;</span></span><br><span class="line">  tcp &#123;</span><br><span class="line">    <span class="comment"># host:port就是上面appender中的 destination，</span></span><br><span class="line"> <span class="comment"># 这里其实把logstash作为服务，开启9250端口接收logback发出的消息</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">port</span> =&gt; <span class="number">9250</span> <span class="attr">mode</span> =&gt; <span class="string">&quot;server&quot;</span> <span class="attr">tags</span> =&gt; [<span class="string">&quot;tags&quot;</span>] <span class="attr">codec</span> =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123; <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置：</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- logback 依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-TCP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> destination 是 logstash 服务的 host:port，</span></span><br><span class="line"><span class="comment"> 相当于和 logstash 建立了管道，将日志数据定向传输到 logstash</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.28.32:9251<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-TCP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大功告成，此后，<code>io.github.dunwu.spring</code> 包中的 TRACE 及以上级别的日志信息都会被定向输出到 logstash 服务。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-cd876d79a14955b0.png" alt="img" /></p>
<p>接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h4 id="522-udp-应用"><a class="markdownIt-Anchor" href="#522-udp-应用"></a> 5.2.2. UDP 应用</h4>
<p>UDP 和 TCP 的使用方式大同小异。</p>
<p>logstash 配置：</p>
<p>（1）创建 <code>logstash-input-udp.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">udp &#123;</span><br><span class="line">  <span class="attr">port</span> =&gt; <span class="number">9250</span></span><br><span class="line">  <span class="attr">codec</span> =&gt; json</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line"> elasticsearch &#123; <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> <span class="keyword">stdout</span> &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置：</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<p>与 <strong>TCP 应用</strong> 一节中的引入依赖包完全相同。</p>
<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-UDP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashSocketAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>192.168.28.32<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>9250<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-UDP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h3 id="53-传输文件"><a class="markdownIt-Anchor" href="#53-传输文件"></a> 5.3. 传输文件</h3>
<blockquote>
<p>在 Java Web 领域，需要用到一些重要的工具，例如 Tomcat 、Nginx 、Mysql 等。这些不属于业务应用，但是它们的日志数据对于定位问题、分析统计同样很重要。这时无法使用 logback 方式将它们的日志传输到 logstash。</p>
<p>如何采集这些日志文件呢？别急，你可以使用 logstash 的 file input 插件。</p>
<p>需要注意的是，传输文件这种方式，必须在日志所在的机器上部署 logstash 。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-file.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">  <span class="attr">path</span> =&gt; [<span class="string">&quot;/var/log/nginx/access.log&quot;</span>]</span><br><span class="line">  <span class="attr">type</span> =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  <span class="attr">start_position</span> =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">&quot;nginx-access-log&quot;</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">   <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">   <span class="attr">index</span> =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-file.conf</code></p>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html</a></p>
<h2 id="6-小技巧"><a class="markdownIt-Anchor" href="#6-小技巧"></a> 6. 小技巧</h2>
<h3 id="61-启动-终止应用"><a class="markdownIt-Anchor" href="#61-启动-终止应用"></a> 6.1. 启动、终止应用</h3>
<p>如果你的 logstash 每次都是通过指定配置文件方式启动。不妨建立一个启动脚本。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd xxx 进入 logstash 安装目录下的 bin 目录</span></span><br><span class="line"><span class="attribute">logstash</span> -f logstash.conf</span><br></pre></td></tr></table></figure>
<p>如果你的 logstash 运行在 linux 系统下，不妨使用 nohup 来启动一个守护进程。这样做的好处在于，即使关闭终端，应用仍会运行。</p>
<p>创建 <a target="_blank" rel="noopener" href="http://startup.sh">startup.sh</a>：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nohup</span> ./logstash -f logstash.conf &gt;&gt; nohup.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>终止应用没有什么好方法，你只能使用 ps -ef | grep logstash ，查出进程，将其 kill 。不过，我们可以写一个脚本来干这件事：</p>
<p>创建 <a target="_blank" rel="noopener" href="http://shutdown.sh">shutdown.sh</a>：</p>
<p>脚本不多解释，请自行领会作用。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PID</span>=`ps -ef | grep logstash | awk &#x27;&#123; print $<span class="number">2</span>&#125;&#x27; | head -n <span class="number">1</span>`</span><br><span class="line"><span class="attribute">kill</span> -<span class="number">9</span> <span class="variable">$&#123;PID&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/logstash">Logstash 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chenryn/logstash-best-practice-cn">ELK Stack 权威指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/judasn/Linux-Tutorial/blob/master/ELK-Install-And-Settings.md">ELK（Elasticsearch、Logstash、Kibana）安装和配置</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/65334efa.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/65334efa.html" class="post-title-link" itemprop="url">RPC 基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T16:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">分布式应用</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/65334efa.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="65334efa.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rpc-基本原理"><a class="markdownIt-Anchor" href="#rpc-基本原理"></a> RPC 基本原理</h1>
<h2 id="1-rpc-简介"><a class="markdownIt-Anchor" href="#1-rpc-简介"></a> 1. RPC 简介</h2>
<h3 id="11-什么是-rpc"><a class="markdownIt-Anchor" href="#11-什么是-rpc"></a> 1.1. 什么是 RPC</h3>
<p>RPC 的全称是 <strong>Remote Procedure Call</strong>，即<strong>远程过程调用</strong>。</p>
<p>RPC 的主要作用是：</p>
<ul>
<li>屏蔽远程调用跟本地调用的区别。</li>
<li>隐藏底层网络通信的复杂性。</li>
</ul>
<h3 id="12-rpc-通信"><a class="markdownIt-Anchor" href="#12-rpc-通信"></a> 1.2. RPC 通信</h3>
<p>远程调用说明了，RPC 需要通信，那么 RPC 的通信过程是怎样的呢？</p>
<p>RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。</p>
<p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象，所以必须要将其转换，这个过程叫序列化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610153311.png" alt="img" /></p>
<ul>
<li>RPC 拦截调用方要执行的远程方法，将方法名、参数等序列化为方便在网络中传输的二进制或 JSON 数据，然后将这些请求信息传给服务提供方；</li>
<li>服务提供方将请求信息反序列化为本地的方法和请求参数，然后执行，最后将执行结果序列化为二进制或 JSON 数据，再回应给调用方。</li>
<li>调用方将应答数据反序列化。</li>
</ul>
<h3 id="13-rpc-协议"><a class="markdownIt-Anchor" href="#13-rpc-协议"></a> 1.3. RPC 协议</h3>
<p>既然有了现成的 HTTP 协议，还有必要设计 RPC 协议吗？</p>
<p>有必要。因为 HTTP 这些通信标准协议，数据包中的实际请求数据相对于数据包本身要小很多，有很多无用的内容；并且 HTTP 属于无状态协议，无法将请求和响应关联，每次请求要重新建立连接。这对于高性能的 RPC 来说，HTTP 协议难以满足需求，所以有必要设计一个<strong>紧凑的私有协议</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610163132.png" alt="img" /></p>
<h2 id="2-序列化"><a class="markdownIt-Anchor" href="#2-序列化"></a> 2. 序列化</h2>
<blockquote>
<p><strong>序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中</strong>。</p>
</blockquote>
<p>序列化是 RPC 的要点之一。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553224129484.png" alt="img" /></p>
<h3 id="21-常见序列化方式"><a class="markdownIt-Anchor" href="#21-常见序列化方式"></a> 2.1. 常见序列化方式</h3>
<h4 id="211-jdk-序列化"><a class="markdownIt-Anchor" href="#211-jdk-序列化"></a> 2.1.1. JDK 序列化</h4>
<blockquote>
<p>有兴趣深入了解 JDK 序列化方式，可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/javacore/blob/master/docs/io/java-serialization.md">深入理解 Java 序列化</a></p>
</blockquote>
<h4 id="212-json"><a class="markdownIt-Anchor" href="#212-json"></a> 2.1.2. JSON</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">jackson</a>、<a target="_blank" rel="noopener" href="https://github.com/google/gson">gson</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">fastjson</a> - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。</p>
<h4 id="213-hessian"><a class="markdownIt-Anchor" href="#213-hessian"></a> 2.1.3. Hessian</h4>
<p><a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">hessian</a> - 适用于对开发体验敏感，性能有要求的内外部系统。</p>
<p>但 Hessian 本身也有问题，官方版本对 Java 里面一些常见对象的类型不支持，比如：</p>
<ul>
<li>Linked 系列，<code>LinkedHashMap</code>、<code>LinkedHashSet</code> 等，但是可以通过扩展 <code>CollectionDeserializer</code> 类修复；</li>
<li>Locale 类，可以通过扩展 <code>ContextSerializerFactory</code> 类修复；</li>
<li><code>Byte</code>/<code>Short</code> 反序列化的时候变成 <code>Integer</code>。</li>
</ul>
<h4 id="214-thrift-protobuf"><a class="markdownIt-Anchor" href="#214-thrift-protobuf"></a> 2.1.4. Thrift / Protobuf</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">thrift</a>、<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">protobuf</a> - 适用于对性能敏感，对开发体验要求不高的内部系统。</p>
<p>初次以外，还有很多其他的序列化方案。那么，RPC 的序列化方式如何选择呢？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610193721.png" alt="img" /></p>
<p>综合以上，Java RPC 框架中序列化方式，一般首选 Protobuf 和 Hessian，二者在性能、通用性、安全性、兼容性、空间开销上都表现不错。其中，Protobuf 性能、通用性更好；而 Hessian 在开发体验上更为便捷。</p>
<h3 id="22-序列化问题"><a class="markdownIt-Anchor" href="#22-序列化问题"></a> 2.2. 序列化问题</h3>
<p>Java 对象序列化，一般要关注以下问题：</p>
<p>常规性问题：</p>
<ul>
<li>当父类继承 <code>Serializable</code> 接口时，所有子类都可以被序列化。</li>
<li>子类实现了 <code>Serializable</code> 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。</li>
<li>如果序列化的属性是对象，则这个对象也必须实现 <code>Serializable</code> 接口，否则会报错。</li>
<li>在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。</li>
<li>在反序列化时，如果 <code>serialVersionUID</code> 被修改，则反序列化时会失败。</li>
</ul>
<p>设计问题：</p>
<ul>
<li><strong>对象过于复杂、庞大</strong> - 对象过于复杂、庞大，会降低序列化、反序列化的效率，并增加传输开销，从而导致响应时延增大。</li>
<li><strong>对象有复杂的继承关系</strong> - 对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。</li>
<li><strong>使用序列化框架不支持的类作为入参类</strong> - 比如 Hessian 框架，他天然是不支持 LinkHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。</li>
</ul>
<h2 id="3-反射动态代理"><a class="markdownIt-Anchor" href="#3-反射动态代理"></a> 3. 反射+动态代理</h2>
<p>RPC 的远程过程调用时通过反射+动态代理实现的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610161617.png" alt="img" /></p>
<p>RPC 框架会自动为要调用的接口生成一个代理类。当在项目中注入接口的时候，运行过程中实际绑定的就是这个接口生成的代理类。在接口方法被调用时，会被代理类拦截，这样，就可以在生成的代理类中，加入远程调用逻辑。</p>
<p>除了 JDK 默认的 <code>InvocationHandler</code> 能完成代理功能，还有很多其他的第三方框架也可以，比如像 Javassist、Byte Buddy 这样的框架。</p>
<blockquote>
<p>反射+动态代理更多详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/javacore/blob/master/docs/basics/java-reflection.md">深入理解 Java 反射和动态代理</a></p>
</blockquote>
<h2 id="4-网络通信"><a class="markdownIt-Anchor" href="#4-网络通信"></a> 4. 网络通信</h2>
<p>一次 RPC 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。可见，通信时 RPC 实现的核心。</p>
<p>常见的网络 IO 模型有：同步阻塞（BIO）、同步非阻塞（NIO）、异步非阻塞（AIO）。</p>
<h3 id="41-io-多路复用"><a class="markdownIt-Anchor" href="#41-io-多路复用"></a> 4.1. IO 多路复用</h3>
<p>IO 多路复用（Reactor 模式）在高并发场景下使用最为广泛，很多知名软件都应用了这一技术，如：Netty、Redis、Nginx 等。</p>
<p>IO 多路复用分为 select，poll 和 epoll。</p>
<p>什么是 IO 多路复用？字面上的理解，多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。</p>
<h3 id="42-零拷贝"><a class="markdownIt-Anchor" href="#42-零拷贝"></a> 4.2. 零拷贝</h3>
<p>系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200717154300" alt="img" /></p>
<p>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。</p>
<p>应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样很浪费 CPU 和性能。</p>
<p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200717154716.jfif" alt="img" /></p>
<p>Netty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。</p>
<p>Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。</p>
<p>Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socketd 的读写<br />
操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。</p>
<p>Netty 还提供 FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法实现了零拷<br />
贝，这与 Linux 中的 sendfile 方式在原理上也是一样的。</p>
<h2 id="5-rpc-架构模型"><a class="markdownIt-Anchor" href="#5-rpc-架构模型"></a> 5. RPC 架构模型</h2>
<p>了解前面的知识点（序列化、动态代理、通信），其实已经可以实现一个点对点的 RPC 架构了。</p>
<p>采用微内核架构的 RPC 架构模型：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610164920.png" alt="img" /></p>
<p>在 RPC 框架里面，怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接<br />
口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机<br />
制，它可以动态地为某个接口寻找服务实现。使用 SPI 机制需要在 Classpath 下的 <code>META-INF/services</code> 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。</p>
<p>但在实际项目中，我们其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载，<br />
<code>ServiceLoader</code> 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。</p>
<h2 id="6-服务注册和发现"><a class="markdownIt-Anchor" href="#6-服务注册和发现"></a> 6. 服务注册和发现</h2>
<p>RPC 框架必须要有服务注册和发现机制，这样，集群中的节点才能知道通信方的请求地址。</p>
<ul>
<li><strong>服务注册</strong>：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。</li>
<li><strong>服务订阅</strong>：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用。</li>
</ul>
<h3 id="61-基于-zookeeper-的服务发现"><a class="markdownIt-Anchor" href="#61-基于-zookeeper-的服务发现"></a> 6.1. 基于 ZooKeeper 的服务发现</h3>
<p>使用 ZooKeeper 作为服务注册中心，是 Java 分布式系统的经典方案。</p>
<p>搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610180056.png" alt="img" /></p>
<p>通常我们可以使用 ZooKeeper、etcd 或者分布式缓存（如 Hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 ZooKeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求。</p>
<p>在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题：</p>
<ul>
<li>注册中心负载过高；</li>
<li>各节点数据不一致；</li>
<li>服务下发不及时或下发错误的服务节点列表。</li>
</ul>
<p>RPC 框架依赖的注册中心的服务数据的一致性其实并不需要满足 CP，只要满足 AP 即可。</p>
<h3 id="62-基于消息总线的最终一致性的注册中心"><a class="markdownIt-Anchor" href="#62-基于消息总线的最终一致性的注册中心"></a> 6.2. 基于消息总线的最终一致性的注册中心</h3>
<p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。</p>
<p>而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后<br />
（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200717162006.png" alt="img" /></p>
<h2 id="7-健康检查"><a class="markdownIt-Anchor" href="#7-健康检查"></a> 7. 健康检查</h2>
<p><strong>使用频率适中的心跳去检测目标机器的健康状态</strong>。</p>
<ul>
<li>健康状态：建立连接成功，并且心跳探活也一直成功；</li>
<li>亚健康状态：建立连接成功，但是心跳请求连续失败；</li>
<li>死亡状态：建立连接失败。</li>
</ul>
<p>可以<strong>使用可用率来作为健康状态的量化标准</strong>：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">可用率 <span class="operator">=</span> 一个时间窗口内接口调用成功次数 / 总调用次数</span><br></pre></td></tr></table></figure>
<p>当可用率低于某个比例，就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。</p>
<h2 id="8-路由和负载均衡"><a class="markdownIt-Anchor" href="#8-路由和负载均衡"></a> 8. 路由和负载均衡</h2>
<p>对于服务调用方来说，一个接口会有多个服务提供方同时提供服务，所以我们的 RPC 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。这被称为路由策略。</p>
<ul>
<li>IP 路由：最简单的当然是 IP 路由，因为服务上线后，会暴露服务到注册中心，将自身 IP、端口等元信息告知注册中心。这样消费方就可以在向注册中心请求服务地址时，感知其存在。</li>
<li>参数路由：但有时，会有一些复杂的场景，如：灰度发布、定点调用，我们并不希望上线的服务被所有消费者感知，为了更加细粒度的控制，可以使用参数路由。通过参数控制通信的路由策略。</li>
</ul>
<p>除了特殊场景的路由策略以外，对于机器中多个服务方，如何选择调用哪个服务节点，可以应用负载均衡策略。RPC 负载均衡策略一般包括随机、轮询、一致性 Hash、最近最少连接等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200717163401.png" alt="img" /></p>
<blockquote>
<p>负载均衡详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/distributed/load-balance.md">负载均衡基本原理</a></p>
</blockquote>
<h3 id="81-超时重试"><a class="markdownIt-Anchor" href="#81-超时重试"></a> 8.1. 超时重试</h3>
<p>超时重试机制是指：当调用端发起的请求失败或超时未收到响应时，RPC 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610193748.png" alt="img" /></p>
<h3 id="82-限流-降级-熔断"><a class="markdownIt-Anchor" href="#82-限流-降级-熔断"></a> 8.2. 限流、降级、熔断</h3>
<p>限流方案：Redis + lua、Sentinel</p>
<p>熔断方案：Hystrix</p>
<h3 id="83-优雅启动关闭"><a class="markdownIt-Anchor" href="#83-优雅启动关闭"></a> 8.3. 优雅启动关闭</h3>
<p>如何避免服务停机带来的业务损失：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610193806.png" alt="img" /></p>
<p>如何避免流量打到没有启动完成的节点：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200610193829.png" alt="img" /></p>
<h2 id="9-容错处理"><a class="markdownIt-Anchor" href="#9-容错处理"></a> 9. 容错处理</h2>
<h3 id="91-异常重试"><a class="markdownIt-Anchor" href="#91-异常重试"></a> 9.1. 异常重试</h3>
<p>就是当调用端发起的请求失败时，RPC 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。</p>
<p>当然，不是所有的异常都要触发重试，只有符合重试条件的异常才能触发重试，比如网络超时异常、网络连接异常等等（这个需要 RPC 去判定）。</p>
<blockquote>
<p>注意：有时网络可能发生抖动，导致请求超时，这时如果 RPC 触发超时重试，会触发业务逻辑重复执行，如果接口没有幂等性设计，就可能引发问题。如：重发写表。</p>
</blockquote>
<h3 id="92-重试超时时间"><a class="markdownIt-Anchor" href="#92-重试超时时间"></a> 9.2. 重试超时时间</h3>
<p>连续的异常重试可能会出现一种不可靠的情况，那就是连续的异常重试并且每次处理的请求时间比较长，最终会导致请求处理的时间过长，超出用户设置的超时时间。</p>
<p>解决这个问题最直接的方式就是，在每次重试后都重置一下请求的超时时间。</p>
<p>当调用端发起 RPC 请求时，如果发送请求发生异常并触发了异常重试，我们可以先判定下这个请求是否已经超时，如果已经超时了就直接返回超时异常，否则就先重置下这个请求的超时时间，之后再发起重试。</p>
<p>在所有发起重试、负载均衡选择节点的时候，去掉重试之前出现过问题的那个节点，以保证重试的成功率。</p>
<h3 id="93-业务异常"><a class="markdownIt-Anchor" href="#93-业务异常"></a> 9.3. 业务异常</h3>
<p>RPC 框架是不会知道哪些业务异常能够去进行异常重试的，我们可以加个重试异常的白名<br />
单，用户可以将允许重试的异常加入到这个白名单中。当调用端发起调用，并且配置了异常重试策略，捕获到异常之后，我们就可以采用这样的异常处理策略。如果这个异常是 RPC 框架允许重试的异常，或者这个异常类型存在于可重试异常的白名单中，我们就允许对这个请求进行重试。</p>
<hr />
<p>综上，一个可靠的 RPC 容错处理机制如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200717163921.png" alt="img" /></p>
<h2 id="10-优雅上线下线"><a class="markdownIt-Anchor" href="#10-优雅上线下线"></a> 10. 优雅上线下线</h2>
<p>如何避免服务停机带来的业务损失？</p>
<h3 id="101-优雅下线"><a class="markdownIt-Anchor" href="#101-优雅下线"></a> 10.1. 优雅下线</h3>
<p>当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）。这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”，然后调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损。</p>
<p>在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子。在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。</p>
<p><img src="C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718205036132.png" alt="image-20200718205036132" /></p>
<h3 id="102-优雅上线"><a class="markdownIt-Anchor" href="#102-优雅上线"></a> 10.2. 优雅上线</h3>
<h4 id="1021-启动预热"><a class="markdownIt-Anchor" href="#1021-启动预热"></a> 10.2.1. 启动预热</h4>
<p>启动预热，就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。</p>
<p>首先，在真实环境中机器都会默认开启 NTP 时间同步功能，来保证所有机器时间的一致性。</p>
<p>调用方通过服务发现，除了可以拿到 IP 列表，还可以拿到对应的启动时间。我们需要把这个时间作用在负载均衡上。</p>
<p><img src="C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718210228814.png" alt="image-20200718210228814" /></p>
<p>通过这个小逻辑的改动，我们就可以保证当服务提供方运行时长小于预热时间时，对服务提供方进行降权，减少被负载均衡选择的概率，避免让应用在启动之初就处于高负载状态，从而实现服务提供方在启动后有一个预热的过程。</p>
<h4 id="1022-延迟暴露"><a class="markdownIt-Anchor" href="#1022-延迟暴露"></a> 10.2.2. 延迟暴露</h4>
<p>服务提供方应用在没有启动完成的时候，调用方的请求就过来了，而调用方请求过来的原因是，服务提供方应用在启动过程中把解析到的 RPC 服务注册到了注册中心，这就导致在后续加载没有完成的情况下服务提供方的地址就被服务调用方感知到了。</p>
<p>为了解决这个问题，需要在应用启动加载、解析 Bean 的时候，如果遇到了 RPC 服务的 Bean，只先把这个<br />
Bean 注册到 Spring-BeanFactory 里面去，而并不把这个 Bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。</p>
<p>具体如何实现呢？</p>
<p>我们可以在服务提供方应用启动后，接口注册到注册中心前，预留一个 Hook 过程，让用户可以实现可扩展的<br />
Hook 逻辑。用户可以在 Hook 里面模拟调用逻辑，从而使 JVM 指令能够预热起来，并且用户也可以在 Hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才把接口注册到注册中心。</p>
<p><img src="C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718210019621.png" alt="image-20200718210019621" /></p>
<h2 id="11-限流熔断"><a class="markdownIt-Anchor" href="#11-限流熔断"></a> 11. 限流熔断</h2>
<p>限流算法有很多，比如最简单的计数器，还有可以做到平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等。其中令牌桶算法最为常用。</p>
<p>服务端主要是通过限流来进行自我保护，我们在实现限流时要考虑到应用和 IP 级别，方便我们在服务治理的时候，对部分访问量特别大的应用进行合理的限流。</p>
<p>服务端的限流阈值配置都是作用于单机的，而在有些场景下，例如对整个服务设置限流阈值，服务进行扩容时，<br />
限流的配置并不方便，我们可以在注册中心或配置中心下发限流阈值配置的时候，将总服务节点数也下发给服务节点，让 RPC 框架自己去计算限流阈值。</p>
<p>我们还可以让 RPC 框架的限流模块依赖一个专门的限流服务，对服务设置限流阈值进行精准地控制，但是这种方式依赖了限流服务，相比单机的限流方式，在性能和耗时上有劣势。</p>
<p>调用端可以通过熔断机制进行自我保护，防止调用下游服务出现异常，或者耗时过长影响调<br />
用端的业务逻辑，RPC 框架可以在动态代理的逻辑中去整合熔断器，实现 RPC 框架的熔断<br />
功能。</p>
<h2 id="12-业务分组"><a class="markdownIt-Anchor" href="#12-业务分组"></a> 12. 业务分组</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200718204407.png" alt="img" /></p>
<p>在 RPC 里面我们可以通过分组的方式人为地给不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保障我们的核心业务不受非核心业务的干扰。但我们在考虑问题的时候，不能顾此失彼，不能因为新加一个的功能而影响到原有系统的稳定性。</p>
<p>其实我们不仅可以通过分组把服务提供方划分成不同规模的小集群，我们还可以利用分组完成一个接口多种实现的功能。正常情况下，为了方便我们自己管理服务，我一般都会建议每个接口完成的功能尽量保证唯一。但在有些特殊场景下，两个接口也会完全一样，只是具体实现上有那么一点不同，那么我们就可以在服务提供方应用里面同时暴露两个相同接口，但只是接口分组不一样罢了。</p>
<h3 id="121-动态分组"><a class="markdownIt-Anchor" href="#121-动态分组"></a> 12.1. 动态分组</h3>
<p>分组可以帮助服务提供方实现调用方的隔离。但是因为调用方流量并不是一成不变的，而且还可能会因为突发事件导致某个分组的流量溢出，而在整个大集群还有富余能力的时候，又因为分组隔离不能为出问题的集群提供帮助。</p>
<p>为了解决这种突发流量的问题，我们提供了一种更高效的方案，可以实现分组的快速伸缩。事实上我们还可以利用动态分组解决分组后给每个分组预留机器冗余的问题，我们没有必要把所有冗余的机器都分配到分组里面，我们可以把这些预留的机器做成一个共享的池子，从而减少整体预留的实例数量。</p>
<h2 id="13-链路跟踪"><a class="markdownIt-Anchor" href="#13-链路跟踪"></a> 13. 链路跟踪</h2>
<p>分布式链路跟踪就是将一次分布式请求还原为一个完整的调用链路，我们可以在整个调用链路中跟踪到这一次分布式请求的每一个环节的调用情况，比如调用是否成功，返回什么异常，调用的哪个服务节点以及请求耗时等等。</p>
<p>Trace 就是代表整个链路，每次分布式都会产生一个 Trace，每个 Trace 都有它的唯一标识即 TraceId，在分布式链路跟踪系统中，就是通过 TraceId 来区分每个 Trace 的。<br />
Span 就是代表了整个链路中的一段链路，也就是说 Trace 是由多个 Span 组成的。在一个 Trace 下，每个 Span 也都有它的唯一标识 SpanId，而 Span 是存在父子关系的。还是以讲过的例子为例子，在 A-&gt;B-&gt;C-&gt;D 的情况下，在整个调用链中，正常情况下会产生 3 个 Span，分别是 Span1（A-&gt;B）、Span2（B-&gt;C）、Span3（C-&gt;D），这时 Span3 的父 Span 就是 Span2，而 Span2 的父 Span 就是 Span1。</p>
<p>RPC 在整合分布式链路跟踪需要做的最核心的两件事就是“埋点”和“传递”。</p>
<p>我们前面说是因为各子应用、子服务间复杂的依赖关系，所以通过日志难定位问题。那我们就想办法通过日志定位到是哪个子应用的子服务出现问题就行了。</p>
<p>其实，在 RPC 框架打印的异常信息中，是包括定位异常所需要的异常信息的，比如是哪类异常引起的问题（如序列化问题或网络超时问题），是调用端还是服务端出现的异常，调用端与服务端的 IP 是什么，以及服务接口与服务分组都是什么等等。具体如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719082205.png" alt="img" /></p>
<h2 id="14-泛化调用"><a class="markdownIt-Anchor" href="#14-泛化调用"></a> 14. 泛化调用</h2>
<p>在一些特定场景下，需要在没有接口的情况下进行 RPC 调用。例如：</p>
<p>场景一：搭建一个统一的测试平台，可以让各个业务方在测试平台中通过输入接口、分组名、方法名以及参数值，在线测试自己发布的 RPC 服务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719095518.png" alt="img" /></p>
<p>场景二：搭建一个轻量级的服务网关，可以让各个业务方用 HTTP 的方式，通过服务网关调用其它服务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719095704.png" alt="img" /></p>
<p>为了解决这些场景的问题，可以使用泛化调用。</p>
<p>就是 RPC 框架提供统一的泛化调用接口（GenericService），调用端在创建 GenericService 代理时指定真正需要调用的接口的接口名以及分组名，通过调用 GenericService 代理的 $invoke 方法将服务端所需要的所有信息，包括接口名、业务分组名、方法名以及参数信息等封装成请求消息，发送给服务端，实现在没有接口的情况下进行<br />
RPC 调用的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericService</span> &#123;</span><br><span class="line">Object $invoke(String methodName, String[] paramTypes, Object[] params);</span><br><span class="line">CompletableFuture&lt;Object&gt; $asyncInvoke(String methodName, String[] paramTypes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过泛化调用的方式发起调用，由于调用端没有服务端提供方提供的接口 API，不能正常地进行序列化与反序列化，我们可以为泛化调用提供专属的序列化插件，来解决实际问题。</p>
<h2 id="15-时钟轮"><a class="markdownIt-Anchor" href="#15-时钟轮"></a> 15. 时钟轮</h2>
<p>时钟轮这个机制很好地解决了定时任务中，因每个任务都创建一个线程，导致的创建过多线程的问题，以及一个线程扫描所有的定时任务，让 CPU 做了很多额外的轮询遍历操作而浪费 CPU 的问题。</p>
<p>时钟轮的实现机制就是模拟现实生活中的时钟，将每个定时任务放到对应的时间槽位上，这样可以减少扫描任务时对其它时间槽位定时任务的额外遍历操作。</p>
<p>在时间轮的使用中，有些问题需要你额外注意：</p>
<p>时间槽位的单位时间越短，时间轮触发任务的时间就越精确。例如时间槽位的单位时间是 10 毫秒，那么执行定时任务的时间误差就在 10 毫秒内，如果是 100 毫秒，那么误差就在 100 毫秒内。</p>
<p>时间轮的槽位越多，那么一个任务被重复扫描的概率就越小，因为只有在多层时钟轮中的任务才会被重复扫描。比如一个时间轮的槽位有 1000 个，一个槽位的单位时间是 10 毫秒，那么下一层时间轮的一个槽位的单位时间就是 10 秒，超过 10 秒的定时任务会被放到下一层时间轮中，也就是只有超过 10 秒的定时任务会被扫描遍历两次，但如果槽位是 10 个，那么超过 100 毫秒的任务，就会被扫描遍历两次。</p>
<p>结合这些特点，我们就可以视具体的业务场景而定，对时钟轮的周期和时间槽数进行设置。</p>
<p>在 RPC 框架中，只要涉及到定时任务，我们都可以应用时钟轮，比较典型的就是调用端的超时处理、调用端与服务端的启动超时以及定时心跳等等。</p>
<h2 id="16-流量回放"><a class="markdownIt-Anchor" href="#16-流量回放"></a> 16. 流量回放</h2>
<p>所谓的流量就是某个时间段内的所有请求，我们通过某种手段把发送到 A 应用的所有请求录制下来，然后把这些请求统一转发到 B 应用，让 B 应用接收到的请求参数跟 A 应用保持一致，从而实现 A 接收到的请求在 B 应用里面重新请求了一遍。整个过程称之为“<strong>流量回放</strong>”。</p>
<p>流量回放可以做什么？</p>
<p>为了保障应用升级后，我们的业务行为还能保持和升级前一样，我们在大多数情况下都是依靠已有的 TestCase 去验证，但这种方式在一定程度上并不是完全可靠的。最可靠的方式就是引入线上 Case 去验证改造后的应用，把线上的真实流量在改造后的应用里面进行回放，这样不仅节省整个上线时间，还能弥补手动维护 Case 存在的缺陷。</p>
<p>应用引入了 RPC 后，所有的请求流量都会被 RPC 接管，所以我们可以很自然地在 RPC 里面支持流量回放功能。虽然这个功能本身并不是 RPC 的核心功能，但对于使用 RPC 的人来说，他们有了这个功能之后，就可以更放心地升级自己的应用了。</p>
<h2 id="17-rpc-高级"><a class="markdownIt-Anchor" href="#17-rpc-高级"></a> 17. RPC 高级</h2>
<h3 id="171-rpc-性能"><a class="markdownIt-Anchor" href="#171-rpc-性能"></a> 17.1. RPC 性能</h3>
<p>如何提升单机吞吐量？</p>
<p>大多数情况下，影响到 RPC 调用的吞吐量的原因也就是业务逻辑处理慢了，CPU 大部分时间都在等待资源。</p>
<p>为了解决等待的耗时，可以使用<strong>异步</strong>。异步可以使用 Future 或 Callback 方式，Future 最为简单。</p>
<p><img src="C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719081257192.png" alt="image-20200719081257192" /></p>
<p>另外，我们可以通过对 CompletableFuture 的支持，实现 RPC 调用在调用端与服务端之间的完全异步，同时提升两端的单机吞吐量。</p>
<h3 id="172-rpc-安全"><a class="markdownIt-Anchor" href="#172-rpc-安全"></a> 17.2. RPC 安全</h3>
<p>虽然 RPC 经常用于解决内网应用之间的调用，内网环境相对公网也没有那么恶劣，但我们也有必要去建立一套可控的安全体系，去防止一些错误行为。对于 RPC 来说，我们所关心的安全问题不会有公网应用那么复杂，我们只要保证让服务调用方能拿到真实的服务提供方 IP 地址集合，且服务提供方可以管控调用自己的应用就够了。</p>
<p>服务提供方应用里面放一个用于 HMAC 签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，我们只要需要验证下这个签名跟调用方应用信息是否对应得上就行了，这样集中式授权的瓶颈也就不存在了。</p>
<h2 id="18-参考资料"><a class="markdownIt-Anchor" href="#18-参考资料"></a> 18. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/280">《RPC 实战与核心原理》</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/f030e214.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/f030e214.html" class="post-title-link" itemprop="url">Mysql 性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 20:16:48" itemprop="dateCreated datePublished" datetime="2020-06-03T20:16:48+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/f030e214.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="f030e214.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-性能优化"><a class="markdownIt-Anchor" href="#mysql-性能优化"></a> Mysql 性能优化</h1>
<h2 id="1-数据结构优化"><a class="markdownIt-Anchor" href="#1-数据结构优化"></a> 1. 数据结构优化</h2>
<p>良好的逻辑设计和物理设计是高性能的基石。</p>
<h3 id="11-数据类型优化"><a class="markdownIt-Anchor" href="#11-数据类型优化"></a> 1.1. 数据类型优化</h3>
<h4 id="数据类型优化基本原则"><a class="markdownIt-Anchor" href="#数据类型优化基本原则"></a> 数据类型优化基本原则</h4>
<ul>
<li><strong>更小的通常更好</strong> - 越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。
<ul>
<li>例如：整型比字符类型操作代价低，因而会使用整型来存储 IP 地址，使用 <code>DATETIME</code> 来存储时间，而不是使用字符串。</li>
</ul>
</li>
<li><strong>简单就好</strong> - 如整型比字符型操作代价低。
<ul>
<li>例如：很多软件会用整型来存储 IP 地址。</li>
<li>例如：<strong><code>UNSIGNED</code> 表示不允许负值，大致可以使正数的上限提高一倍</strong>。</li>
</ul>
</li>
<li><strong>尽量避免 NULL</strong> - 可为 NULL 的列会使得索引、索引统计和值比较都更复杂。</li>
</ul>
<h4 id="类型的选择"><a class="markdownIt-Anchor" href="#类型的选择"></a> 类型的选择</h4>
<ul>
<li>
<p>整数类型通常是标识列最好的选择，因为它们很快并且可以使用 <code>AUTO_INCREMENT</code>。</p>
</li>
<li>
<p><code>ENUM</code> 和 <code>SET</code> 类型通常是一个糟糕的选择，应尽量避免。</p>
</li>
<li>
<p>应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 <code>MD5</code>、<code>SHA</code>、<code>UUID</code> 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 <code>INSERT</code> 以及一些 <code>SELECT</code> 语句变得很慢。</p>
<ul>
<li>如果存储 UUID ，应该移除 <code>-</code> 符号；更好的做法是，用 <code>UNHEX()</code> 函数转换 UUID 值为 16 字节的数字，并存储在一个 <code>BINARY(16)</code> 的列中，检索时，可以通过 <code>HEX()</code> 函数来格式化为 16 进制格式。</li>
</ul>
</li>
</ul>
<h3 id="12-表设计"><a class="markdownIt-Anchor" href="#12-表设计"></a> 1.2. 表设计</h3>
<p>应该避免的设计问题：</p>
<ul>
<li><strong>太多的列</strong> - 设计者为了图方便，将大量冗余列加入表中，实际查询中，表中很多列是用不到的。这种宽表模式设计，会造成不小的性能代价，尤其是 <code>ALTER TABLE</code> 非常耗时。</li>
<li><strong>太多的关联</strong> - 所谓的实体 - 属性 - 值（EVA）设计模式是一个常见的糟糕设计模式。Mysql 限制了每个关联操作最多只能有 61 张表，但 EVA 模式需要许多自关联。</li>
<li><strong>枚举</strong> - 尽量不要用枚举，因为添加和删除字符串（枚举选项）必须使用 <code>ALTER TABLE</code>。</li>
<li>尽量避免 <code>NULL</code></li>
</ul>
<h3 id="13-范式和反范式"><a class="markdownIt-Anchor" href="#13-范式和反范式"></a> 1.3. 范式和反范式</h3>
<p><strong>范式化目标是尽量减少冗余，而反范式化则相反</strong>。</p>
<p>范式化的优点：</p>
<ul>
<li>比反范式更节省空间</li>
<li>更新操作比反范式快</li>
<li>更少需要 <code>DISTINCT</code> 或 <code>GROUP BY</code> 语句</li>
</ul>
<p>范式化的缺点：</p>
<ul>
<li>通常需要关联查询。而关联查询代价较高，如果是分表的关联查询，代价更是高昂。</li>
</ul>
<p>在真实世界中，很少会极端地使用范式化或反范式化。实际上，应该权衡范式和反范式的利弊，混合使用。</p>
<h3 id="14-索引优化"><a class="markdownIt-Anchor" href="#14-索引优化"></a> 1.4. 索引优化</h3>
<blockquote>
<p>索引优化应该是查询性能优化的最有效手段。</p>
<p>如果想详细了解索引特性请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md">Mysql 索引</a></p>
</blockquote>
<h4 id="何时使用索引"><a class="markdownIt-Anchor" href="#何时使用索引"></a> 何时使用索引</h4>
<ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li>对于中、大型表，索引非常有效。</li>
<li>对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术。</li>
<li>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。</li>
</ul>
<h4 id="索引优化策略"><a class="markdownIt-Anchor" href="#索引优化策略"></a> 索引优化策略</h4>
<ul>
<li><strong>索引基本原则</strong>
<ul>
<li>索引不是越多越好，不要为所有列都创建索引。</li>
<li>要尽量避免冗余和重复索引。</li>
<li>要考虑删除未使用的索引。</li>
<li>尽量的扩展索引，不要新建索引。</li>
<li>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引。</li>
</ul>
</li>
<li><strong>独立的列</strong> - “独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。</li>
<li><strong>前缀索引</strong> - 索引很长的字符列，可以索引开始的部分字符，这样可以大大节约索引空间。</li>
<li><strong>最左匹配原则</strong> - 将选择性高的列或基数大的列优先排在多列索引最前列。</li>
<li><strong>使用索引来排序</strong> - 索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。</li>
<li><code>=</code>、<code>IN</code> 可以乱序 - 不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</li>
<li><strong>覆盖索引</strong></li>
<li><strong>自增字段作主键</strong></li>
</ul>
<h2 id="2-sql-优化"><a class="markdownIt-Anchor" href="#2-sql-优化"></a> 2. SQL 优化</h2>
<p>使用 <code>EXPLAIN</code> 命令查看当前 SQL 是否使用了索引，优化后，再通过执行计划（<code>EXPLAIN</code>）来查看优化效果。</p>
<p>SQL 优化基本思路：</p>
<ul>
<li>
<p><strong>只返回必要的列</strong> - 最好不要使用 <code>SELECT *</code> 语句。</p>
</li>
<li>
<p><strong>只返回必要的行</strong> - 使用 <code>WHERE</code> 子查询语句进行过滤查询，有时候也需要使用 <code>LIMIT</code> 语句来限制返回的数据。</p>
</li>
<li>
<p><strong>缓存重复查询的数据</strong> - 应该考虑在客户端使用缓存，尽量不要使用 Mysql 服务器缓存（存在较多问题和限制）。</p>
</li>
<li>
<p><strong>使用索引来覆盖查询</strong></p>
</li>
</ul>
<h3 id="21-优化-count-查询"><a class="markdownIt-Anchor" href="#21-优化-count-查询"></a> 2.1. 优化 <code>COUNT()</code> 查询</h3>
<p><code>COUNT()</code> 有两种作用：</p>
<ul>
<li>统计某个列值的数量。统计列值时，要求列值是非 <code>NULL</code> 的，它不会统计 <code>NULL</code>。</li>
<li>统计行数。</li>
</ul>
<p><strong>统计列值时，要求列值是非空的，它不会统计 NULL</strong>。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用 <code>COUNT(*)</code> 时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用 <code>COUNT(*)</code>，意义清晰，且性能更好。</p>
<p>（1）简单优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city) <span class="operator">-</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>（2）使用近似值</p>
<p>有时候某些业务场景并不需要完全精确的统计值，可以用近似值来代替，<code>EXPLAIN</code> 出来的行数就是一个不错的近似值，而且执行 <code>EXPLAIN</code> 并不需要真正地去执行查询，所以成本非常低。通常来说，执行 <code>COUNT()</code> 都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 Redis 这样的外部缓存系统。</p>
<h3 id="22-优化关联查询"><a class="markdownIt-Anchor" href="#22-优化关联查询"></a> 2.2. 优化关联查询</h3>
<p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用 <code>JOIN</code> 有更好的性能。</p>
<p>如果确实需要使用关联查询的情况下，需要特别注意的是：</p>
<ul>
<li><strong>确保 <code>ON</code> 和 <code>USING</code> 字句中的列上有索引</strong>。在创建索引的时候就要考虑到关联的顺序。当表 A 和表 B 用某列 column 关联的时候，如果优化器关联的顺序是 A、B，那么就不需要在 A 表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li>
<li><strong>确保任何的 <code>GROUP BY</code> 和 <code>ORDER BY</code> 中的表达式只涉及到一个表中的列</strong>，这样 MySQL 才有可能使用索引来优化。</li>
</ul>
<p>要理解优化关联查询的第一个技巧，就需要理解 MySQL 是如何执行关联查询的。当前 MySQL 关联执行的策略非常简单，它对任何的关联都执行<strong>嵌套循环关联</strong>操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>太抽象了？以上面的示例来说明，比如有这样的一个查询：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">SELECT <span class="selector-tag">A</span><span class="selector-class">.xx</span>,<span class="selector-tag">B</span><span class="selector-class">.yy</span></span><br><span class="line"><span class="selector-tag">FROM</span> <span class="selector-tag">A</span> INNER JOIN <span class="selector-tag">B</span> USING(c)</span><br><span class="line">WHERE <span class="selector-tag">A</span><span class="selector-class">.xx</span> IN (<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>假设 MySQL 按照查询中的关联顺序 A、B 来进行关联操作，那么可以用下面的伪代码表示 MySQL 如何完成这个查询：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">outer_iterator = <span class="variable constant_">SELECT</span> A.xx,A.c <span class="variable constant_">FROM</span> A <span class="variable constant_">WHERE</span> A.xx <span class="variable constant_">IN</span> (<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">outer_row = outer_iterator.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">while</span>(outer_row) &#123;</span><br><span class="line">    inner_iterator = <span class="variable constant_">SELECT</span> B.yy <span class="variable constant_">FROM</span> B <span class="variable constant_">WHERE</span> B.c = outer_row.c;</span><br><span class="line">    inner_row = inner_iterator.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(inner_row) &#123;</span><br><span class="line">        output[inner_row.yy,outer_row.xx];</span><br><span class="line">        inner_row = inner_iterator.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outer_row = outer_iterator.<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最外层的查询是根据<code>A.xx</code>列来查询的，<code>A.c</code>上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显<code>B.c</code>上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p>
<h3 id="23-优化-group-by-和-distinct"><a class="markdownIt-Anchor" href="#23-优化-group-by-和-distinct"></a> 2.3. 优化 <code>GROUP BY</code> 和 <code>DISTINCT</code></h3>
<p>Mysql 优化器会在内部处理的时候相互转化这两类查询。它们都<strong>可以使用索引来优化，这也是最有效的优化方法</strong>。</p>
<h3 id="24-优化-limit"><a class="markdownIt-Anchor" href="#24-优化-limit"></a> 2.4. 优化 <code>LIMIT</code></h3>
<p>当需要分页操作时，通常会使用 <code>LIMIT</code> 加上偏移量的办法实现，同时加上合适的 <code>ORDER BY</code> 字句。<strong>如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作</strong>。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：<code>LIMIT 10000 20</code>这样的查询，MySQL 需要查询 10020 条记录然后只返回 20 条记录，前面的 10000 条都将被抛弃，这样的代价非常高。</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>如果这张表非常大，那么这个查询最好改成下面的样子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>
<p>这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用<code>OFFSET</code>，比如下面的查询：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SELECT <span class="type">id</span> FROM t LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br><span class="line">改为：</span><br><span class="line">SELECT <span class="type">id</span> FROM t WHERE <span class="type">id</span> &gt; <span class="number">10000</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h3 id="25-优化-union"><a class="markdownIt-Anchor" href="#25-优化-union"></a> 2.5. 优化 UNION</h3>
<p>MySQL 总是通过创建并填充临时表的方式来执行 <code>UNION</code> 查询。因此很多优化策略在<code>UNION</code>查询中都没有办法很好的时候。经常需要手动将<code>WHERE</code>、<code>LIMIT</code>、<code>ORDER BY</code>等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p>
<p>除非确实需要服务器去重，否则就一定要使用<code>UNION ALL</code>，如果没有<code>ALL</code>关键字，MySQL 会给临时表加上<code>DISTINCT</code>选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用 ALL 关键字，MySQL 总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p>
<h3 id="26-优化查询方式"><a class="markdownIt-Anchor" href="#26-优化查询方式"></a> 2.6. 优化查询方式</h3>
<h4 id="切分大查询"><a class="markdownIt-Anchor" href="#切分大查询"></a> 切分大查询</h4>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELEFT <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="分解大连接查询"><a class="markdownIt-Anchor" href="#分解大连接查询"></a> 分解大连接查询</h4>
<p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>
<h2 id="3-执行计划explain"><a class="markdownIt-Anchor" href="#3-执行计划explain"></a> 3. 执行计划（<code>EXPLAIN</code>）</h2>
<p>如何判断当前 SQL 是否使用了索引？如何检验修改后的 SQL 确实有优化效果？</p>
<p>在 SQL 中，可以通过执行计划（<code>EXPLAIN</code>）分析 <code>SELECT</code> 查询效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><code>EXPLAIN</code> 参数说明：</p>
<ul>
<li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li><code>select_type</code> ⭐ ：SELECT 查询的类型.
<ul>
<li><code>SIMPLE</code>：表示此查询不包含 UNION 查询或子查询</li>
<li><code>PRIMARY</code>：表示此查询是最外层的查询</li>
<li><code>UNION</code>：表示此查询是 UNION 的第二或随后的查询</li>
<li><code>DEPENDENT UNION</code>：UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li><code>UNION RESULT</code>：UNION 的结果</li>
<li><code>SUBQUERY</code>：子查询中的第一个 SELECT</li>
<li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
</li>
<li><code>table</code>: 查询的是哪个表，如果给表起别名了，则显示别名。</li>
<li><code>partitions</code>：匹配的分区</li>
<li><code>type</code> ⭐：表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，结果值从好到差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。
<ul>
<li><code>system</code>/<code>const</code>：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。如果是 B + 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。const 表示此时索引在第一层，只需访问一层便能得到数据。</li>
<li><code>eq_ref</code>：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。</li>
<li><code>ref</code>：非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。</li>
<li><code>range</code>：索引范围扫描，比如，&lt;，&gt;，between 等操作。</li>
<li><code>index</code>：索引全表扫描，此时遍历整个索引树。</li>
<li><code>ALL</code>：表示全表扫描，需要遍历全表来找到对应的行。</li>
</ul>
</li>
<li><code>possible_keys</code>：此次查询中可能选用的索引。</li>
<li><code>key</code> ⭐：此次查询中实际使用的索引。</li>
<li><code>ref</code>：哪个字段或常数与 key 一起被使用。</li>
<li><code>rows</code> ⭐：显示此查询一共扫描了多少行，这个是一个估计值。</li>
<li><code>filtered</code>：表示此查询条件所过滤的数据的百分比。</li>
<li><code>extra</code>：额外的信息。</li>
</ul>
<blockquote>
<p>更多内容请参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></p>
</blockquote>
<h2 id="4-optimizer-trace"><a class="markdownIt-Anchor" href="#4-optimizer-trace"></a> 4. optimizer trace</h2>
<p>在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。</p>
<p>如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> NAME <span class="operator">&gt;</span><span class="string">&#x27;name84059&#x27;</span> <span class="keyword">AND</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-01-24 05:00</span></span><br><span class="line"><span class="string">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span></span><br><span class="line"><span class="string">SET optimizer_trace=&quot;enabled=off&quot;;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-数据模型和业务"><a class="markdownIt-Anchor" href="#5-数据模型和业务"></a> 5. 数据模型和业务</h2>
<ul>
<li>表字段比较复杂、易变动、结构难以统一的情况下，可以考虑使用 Nosql 来代替关系数据库表存储，如 ElasticSearch、MongoDB。</li>
<li>在高并发情况下的查询操作，可以使用缓存（如 Redis）代替数据库操作，提高并发性能。</li>
<li>数据量增长较快的表，需要考虑水平分表或分库，避免单表操作的性能瓶颈。</li>
<li>除此之外，我们应该通过一些优化，尽量避免比较复杂的 JOIN 查询操作，例如冗余一些字段，减少 JOIN 查询；创建一些中间表，减少 JOIN 查询。</li>
</ul>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d7665192aaaf">我必须得告诉大家的 MySQL 优化原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/c047f08d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/c047f08d.html" class="post-title-link" itemprop="url">Mysql 事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 19:32:09" itemprop="dateCreated datePublished" datetime="2020-06-03T19:32:09+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/c047f08d.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="c047f08d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-事务"><a class="markdownIt-Anchor" href="#mysql-事务"></a> Mysql 事务</h1>
<blockquote>
<p>不是所有的 Mysql 存储引擎都实现了事务处理。支持事务的存储引擎有：<code>InnoDB</code> 和 <code>NDB Cluster</code>。不支持事务的存储引擎，代表有：<code>MyISAM</code>。</p>
<p>用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716074533.png" alt="img" /></p>
<h2 id="1-事务简介"><a class="markdownIt-Anchor" href="#1-事务简介"></a> 1. 事务简介</h2>
<blockquote>
<p>事务简单来说：<strong>一个 Session 中所进行所有的操作，要么同时成功，要么同时失败</strong>。进一步说，事务指的是满足 ACID 特性的一组操作，可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.png" alt="img" /></p>
<p><strong>事务就是一组原子性的 SQL 语句</strong>。具体来说，事务指的是满足 ACID 特性的一组操作。</p>
<p><strong>事务内的 SQL 语句，要么全执行成功，要么全执行失败</strong>。</p>
<p><strong>通过加锁的方式，可以实现不同的事务隔离机制</strong>。</p>
<p>想象一下，如果没有事务，在并发环境下，就可能出现丢失修改的问题。</p>
<p>T<sub>1</sub> 和 T<sub>2</sub> 两个线程都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png" alt="img" /></p>
<h2 id="2-事务用法"><a class="markdownIt-Anchor" href="#2-事务用法"></a> 2. 事务用法</h2>
<h3 id="21-事务处理指令"><a class="markdownIt-Anchor" href="#21-事务处理指令"></a> 2.1. 事务处理指令</h3>
<p>Mysql 中，使用 <code>START TRANSACTION</code> 语句开始一个事务；使用 <code>COMMIT</code> 语句提交所有的修改；使用 <code>ROLLBACK</code> 语句撤销所有的修改。不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>
<ul>
<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>
<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>
<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - 提交事务。</li>
</ul>
<p>事务处理示例：</p>
<p>（1）创建一张示例表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 撤销表 user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 user</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  email <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（2）执行事务操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>（3）执行结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	root1	root1	<span class="symbol">xxxx@</span><span class="number">163.</span>com</span><br></pre></td></tr></table></figure>
<h3 id="22-autocommit"><a class="markdownIt-Anchor" href="#22-autocommit"></a> 2.2. AUTOCOMMIT</h3>
<p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;AUTOCOMMIT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-acid"><a class="markdownIt-Anchor" href="#3-acid"></a> 3. ACID</h2>
<p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong>
<ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong>
<ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong>
<ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong>
<ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p><strong>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。</strong></p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93ACID.png" alt="img" /></p>
<blockquote>
<p>MySQL 默认采用自动提交模式（<code>AUTO COMMIT</code>）。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
</blockquote>
<h2 id="4-事务隔离级别"><a class="markdownIt-Anchor" href="#4-事务隔离级别"></a> 4. 事务隔离级别</h2>
<h3 id="41-事务隔离简介"><a class="markdownIt-Anchor" href="#41-事务隔离简介"></a> 4.1. 事务隔离简介</h3>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题：</p>
<ul>
<li><strong>丢失修改</strong></li>
<li><strong>脏读</strong></li>
<li><strong>不可重复读</strong></li>
<li><strong>幻读</strong></li>
</ul>
<p>在 SQL 标准中，定义了四种事务隔离级别（级别由低到高）：</p>
<ul>
<li><strong>未提交读</strong></li>
<li><strong>提交读</strong></li>
<li><strong>可重复读</strong></li>
<li><strong>串行化</strong></li>
</ul>
<p>Mysql 中查看和设置事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ UNCOMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ COMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 REPEATABLE READ</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 SERIALIZABLE</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>
<h3 id="42-未提交读"><a class="markdownIt-Anchor" href="#42-未提交读"></a> 4.2. 未提交读</h3>
<p><strong><code>未提交读（READ UNCOMMITTED）</code> 是指：事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</p>
<p>未提交读的问题：事务可以读取未提交的数据，也被称为 <strong>脏读（Dirty Read）</strong>。</p>
<p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E8%84%8F%E6%95%B0%E6%8D%AE.png" alt="img" /></p>
<h3 id="43-提交读"><a class="markdownIt-Anchor" href="#43-提交读"></a> 4.3. 提交读</h3>
<p><strong><code>提交读（READ COMMITTED）</code> 是指：事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。提交读解决了脏读的问题。</p>
<p>提交读是大多数数据库的默认事务隔离级别。</p>
<p>提交读有时也叫不可重复读，它的问题是：执行两次相同的查询，得到的结果可能不一致。</p>
<p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="img" /></p>
<h3 id="44-可重复读"><a class="markdownIt-Anchor" href="#44-可重复读"></a> 4.4. 可重复读</h3>
<p><strong><code>可重复读（REPEATABLE READ）</code> 是指：保证在同一个事务中多次读取同样数据的结果是一样的</strong>。可重复读解决了不可重复读问题。</p>
<p>可重复读是 Mysql 的默认事务隔离级别。</p>
<p>可重复读的问题：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，会产生 <strong>幻读（Phantom Read）</strong>。</p>
<p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E5%B9%BB%E8%AF%BB.png" alt="img" /></p>
<h3 id="45-串行化"><a class="markdownIt-Anchor" href="#45-串行化"></a> 4.5. 串行化</h3>
<p><strong><code>串行化（SERIALIXABLE）</code> 是指：强制事务串行执行</strong>。</p>
<p>强制事务串行执行，则避免了所有的并发问题。串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</p>
<h3 id="46-隔离级别小结"><a class="markdownIt-Anchor" href="#46-隔离级别小结"></a> 4.6. 隔离级别小结</h3>
<ul>
<li><strong><code>未提交读（READ UNCOMMITTED）</code></strong> - 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li><strong><code>提交读（READ COMMITTED）</code></strong> - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li><strong><code>重复读（REPEATABLE READ）</code></strong> - 保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li><strong><code>串行化（SERIALIXABLE）</code></strong> - 强制事务串行执行。</li>
</ul>
<p>数据库隔离级别解决的问题：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">丢失修改</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">提交读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">可串行化</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
</tr>
</tbody>
</table>
<h2 id="5-死锁"><a class="markdownIt-Anchor" href="#5-死锁"></a> 5. 死锁</h2>
<p><strong>死锁是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p>
<p>产生死锁的场景：</p>
<ul>
<li>
<p>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</p>
</li>
<li>
<p>多个事务同时锁定同一个资源时，也会产生死锁。</p>
</li>
</ul>
<h3 id="51-死锁的原因"><a class="markdownIt-Anchor" href="#51-死锁的原因"></a> 5.1. 死锁的原因</h3>
<p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。</p>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p>
<p>在 MySQL 中，gap lock 默认是开启的，即 innodb_locks_unsafe_for_binlog 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</p>
<p>当我们执行以下查询 SQL 时，由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 gap lock，这里的 gap 范围是 (4,+∞）。</p>
<blockquote>
<p>SELECT id FROM <code>demo</code>.<code>order_record</code> where <code>order_no</code> = 4 for update;</p>
</blockquote>
<p>执行查询 SQL 语句获取的 gap lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。</p>
<p>以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。</p>
<blockquote>
<p>INSERT INTO <code>demo</code>.<code>order_record</code>(<code>order_no</code>, <code>status</code>, <code>create_date</code>) VALUES (5, 1, ‘2019-07-13 10:57:03’);</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630153139.png" alt="img" /></p>
<p><strong>另一个死锁场景</strong></p>
<p>InnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630154606.png" alt="img" /></p>
<p>出现死锁的步骤：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630154619.png" alt="img" /></p>
<p>综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。</p>
<h3 id="52-避免死锁"><a class="markdownIt-Anchor" href="#52-避免死锁"></a> 5.2. 避免死锁</h3>
<p>预防死锁的注意事项：</p>
<ul>
<li>在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li>
<li>在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导致的死锁问题；</li>
<li>更新表时，<strong>尽量使用主键更新</strong>；</li>
<li>避免长事务，<strong>尽量将长事务拆解</strong>，可以降低与其它事务发生冲突的概率；</li>
<li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li>
</ul>
<p>另外，我们还可以将 order_no 列设置为唯一索引列。虽然不能防止幻读，但我们可以利用它的唯一性来保证订单记录不重复创建，这种方式唯一的缺点就是当遇到重复创建订单时会抛出异常。</p>
<p>我们还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</p>
<h3 id="53-解决死锁"><a class="markdownIt-Anchor" href="#53-解决死锁"></a> 5.3. 解决死锁</h3>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。</p>
<p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<h2 id="6-分布式事务"><a class="markdownIt-Anchor" href="#6-分布式事务"></a> 6. 分布式事务</h2>
<p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 <strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>MQ 事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案分析：</p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<blockquote>
<p>分布式事务详细说明、分析请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md">分布式事务基本原理</a></p>
</blockquote>
<h2 id="7-事务最佳实践"><a class="markdownIt-Anchor" href="#7-事务最佳实践"></a> 7. 事务最佳实践</h2>
<p>高并发场景下的事务到底该如何调优？</p>
<h3 id="71-尽量使用低级别事务隔离"><a class="markdownIt-Anchor" href="#71-尽量使用低级别事务隔离"></a> 7.1. 尽量使用低级别事务隔离</h3>
<p>结合业务场景，尽量使用低级别事务隔离</p>
<h3 id="72-避免行锁升级表锁"><a class="markdownIt-Anchor" href="#72-避免行锁升级表锁"></a> 7.2. 避免行锁升级表锁</h3>
<p>在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。</p>
<h3 id="73-缩小事务范围"><a class="markdownIt-Anchor" href="#73-缩小事务范围"></a> 7.3. 缩小事务范围</h3>
<p>有时候，数据库并发访问量太大，会出现以下异常：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MySQLQueryInterruptedException: Query execution was <span class="built_in">int</span>errupted</span><br></pre></td></tr></table></figure>
<p>高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。</p>
<p>又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630112600.png" alt="img" /></p>
<p>如上图中的操作，虽然都是在一个事务中，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。</p>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/features/transaction/">ShardingSphere 分布式事务</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/79fffa13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/79fffa13.html" class="post-title-link" itemprop="url">Mysql 配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 22:32:57" itemprop="dateCreated datePublished" datetime="2020-02-29T22:32:57+08:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/79fffa13.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="79fffa13.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-配置"><a class="markdownIt-Anchor" href="#mysql-配置"></a> Mysql 配置</h1>
<blockquote>
<p>版本：<img src="https://img.shields.io/badge/mysql-8.0-blue" alt="mysql" /></p>
</blockquote>
<h2 id="1-基本配置"><a class="markdownIt-Anchor" href="#1-基本配置"></a> 1. 基本配置</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># GENERAL</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">datadir</span> = /var/lib/mysql</span><br><span class="line"><span class="attr">socket</span>  = /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="attr">pid_file</span> = /var/lib/mysql/mysql.pid</span><br><span class="line"><span class="attr">user</span> = mysql</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">default_storage_engine</span> = InnoDB</span><br><span class="line"><span class="attr">default_time_zone</span> = <span class="string">&#x27;+8：00&#x27;</span></span><br><span class="line"><span class="attr">character_set_server</span> = utf8mb4</span><br><span class="line"><span class="attr">collation_server</span> = utf8mb<span class="number">4_0900_</span>ai_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># LOG</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">log_error</span> = /var/log/mysql/mysql-error.log</span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># InnoDB</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_log_file_size</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_file_per_table</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_flush_method</span> = O_DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># MyIsam</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># OTHER</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_connections</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">open_files_limit</span> = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">socket</span>  = /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br></pre></td></tr></table></figure>
<h2 id="2-配置项说明"><a class="markdownIt-Anchor" href="#2-配置项说明"></a> 2. 配置项说明</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 服务端口号，默认 3306</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GENERAL</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 文件</span></span><br><span class="line"><span class="attr">pid_file</span> = /var/lib/mysql/mysql.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql 服务进程的用户</span></span><br><span class="line"><span class="attr">user</span> = mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端口号，默认 3306</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认时区</span></span><br><span class="line"><span class="attr">default_time_zone</span> = <span class="string">&#x27;+8：00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql 服务 ID，单点服务时没必要设置</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务隔离级别，默认为可重复读（REPEATABLE-READ）。（此级别下可能参数很多间隙锁，影响性能，但是修改又影响主从复制及灾难恢复，建议还是修改代码逻辑吧）</span></span><br><span class="line"><span class="comment"># 隔离级别可选项目：READ-UNCOMMITTED READ-COMMITTED REPEATABLE-READ SERIALIZABLE</span></span><br><span class="line"><span class="attr">transaction_isolation</span> = REPEATABLE-READ</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 安装根目录</span></span><br><span class="line"><span class="attr">basedir</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 数据文件所在目录</span></span><br><span class="line"><span class="attr">datadir</span> = /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时目录 比如 load data infile 会用到，一般都是使用/tmp</span></span><br><span class="line"><span class="attr">tmpdir</span> = /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.1 之后，默认引擎是 InnoDB</span></span><br><span class="line"><span class="attr">default_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存临时表默认引擎，默认 InnoDB</span></span><br><span class="line"><span class="attr">default_tmp_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.7 新增特性，磁盘临时表默认引擎，默认 InnoDB</span></span><br><span class="line"><span class="attr">internal_tmp_disk_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符集配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库默认字符集，主流字符集支持一些特殊表情符号（特殊表情符占用 4 个字节）</span></span><br><span class="line"><span class="attr">character_set_server</span> = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库字符集对应一些排序等规则，注意要和 character_set_server 对应</span></span><br><span class="line"><span class="attr">collation-server</span> = utf8mb<span class="number">4_0900_</span>ai_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 client 连接 mysql 时的字符集，防止乱码</span></span><br><span class="line"><span class="comment"># init_connect=&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否对 sql 语句大小写敏感，默认值为 0，1 表示不敏感</span></span><br><span class="line"><span class="attr">lower_case_table_names</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大连接数，可设最大值 16384，一般考虑根据同时在线人数设置一个比较综合的数字，鉴于该数值增大并不太消耗系统资源，建议直接设 10000</span></span><br><span class="line"><span class="comment"># 如果在访问时经常出现 Too Many Connections 的错误提示，则需要增大该参数值</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 100，最大错误连接数，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST</span></span><br><span class="line"><span class="comment"># 考虑高并发场景下的容错，建议加大。</span></span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL 打开的文件描述符限制，默认最小 1024;</span></span><br><span class="line"><span class="comment"># 当 open_files_limit 没有被配置的时候，比较 max_connections\*5 和 ulimit -n 的值，哪个大用哪个，</span></span><br><span class="line"><span class="comment"># 当 open_file_limit 被配置的时候，比较 open_files_limit 和 max_connections\*5 的值，哪个大用哪个。</span></span><br><span class="line"><span class="comment"># 注意：仍然可能出现报错信息 Can&#x27;t create a new thread；此时观察系统 cat /proc/mysql 进程号/limits，观察进程 ulimit 限制情况</span></span><br><span class="line"><span class="comment"># 过小的话，考虑修改系统配置表，/etc/security/limits.conf 和 /etc/security/limits.d/90-nproc.conf</span></span><br><span class="line"><span class="attr">open_files_limit</span> = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL 默认的 wait_timeout 值为 8 个小时，interactive_timeout 参数需要同时配置才能生效</span></span><br><span class="line"><span class="comment"># MySQL 连接闲置超过一定时间后(单位：秒，此处为 1800 秒)将会被强行关闭</span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">1800</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="number">1800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 MySQL 暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中</span></span><br><span class="line"><span class="comment"># 官方建议 back_log = 50 + (max_connections / 5)，封顶数为 900</span></span><br><span class="line"><span class="attr">back_log</span> = <span class="number">900</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库数据交换配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 该参数限制服务器端，接受的数据包大小，如果有 BLOB 子段，建议增大此值，避免写入或者更新出错。有 BLOB 子段，建议改为 1024M</span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存、cache 与 buffer 设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存临时表的最大值，默认 16M，此处设置成 64M</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户创建的内存表的大小，默认 16M，往往和 tmp_table_size 一起设置，限制用户临时表大小。</span></span><br><span class="line"><span class="comment"># 超限的话，MySQL 就会自动地把它转化为基于磁盘的 MyISAM 表，存储在指定的 tmpdir 目录下，增大 IO 压力，建议内存大，增大该数值。</span></span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示这个 mysql 版本是否支持查询缓存。ps：SHOW STATUS LIKE &#x27;qcache%&#x27;，与缓存相关的状态变量。</span></span><br><span class="line"><span class="comment"># have_query_cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个系统变量控制着查询缓存功能的开启和关闭，0 表示关闭，1 表示打开，2 表示只要 select 中明确指定 SQL_CACHE 才缓存。</span></span><br><span class="line"><span class="comment"># 看业务场景决定是否使用缓存，不使用，下面就不用配置了。</span></span><br><span class="line"><span class="comment"># Mysql8 不支持</span></span><br><span class="line"><span class="attr">query_cache_type</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 1M，优点是查询缓存可以极大的提高服务器速度，如果你有大量的相同的查询并且很少修改表。</span></span><br><span class="line"><span class="comment"># 缺点：在你表经常变化的情况下或者如果你的查询原文每次都不同，查询缓存也许引起性能下降而不是性能提升。</span></span><br><span class="line"><span class="comment"># Mysql8 不支持</span></span><br><span class="line"><span class="attr">query_cache_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有小于此设定值的结果才会被缓冲，保护查询缓冲，防止一个极大的结果集将其他所有的查询结果都覆盖。</span></span><br><span class="line"><span class="attr">query_cache_limit</span> = <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个被缓存的结果集要占用的最小内存，默认值 4kb，一般不怎么调整。</span></span><br><span class="line"><span class="comment"># 如果 Qcache_free_blocks 值过大，可能是 query_cache_min_res_unit 值过大，应该调小些</span></span><br><span class="line"><span class="comment"># query_cache_min_res_unit 的估计值：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache</span></span><br><span class="line"><span class="attr">query_cache_min_res_unit</span> = <span class="number">4</span>kb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个事务中 binlog 为了记录 SQL 状态所持有的 cache 大小</span></span><br><span class="line"><span class="comment"># 如果你经常使用大的、多声明的事务，你可以增加此值来获取更大的性能。</span></span><br><span class="line"><span class="comment"># 所有从事务来的状态都将被缓冲在 binlog 缓冲中然后在提交后一次性写入到 binlog 中</span></span><br><span class="line"><span class="comment"># 如果事务比此值大，会使用磁盘上的临时文件来替代。</span></span><br><span class="line"><span class="comment"># 此缓冲在每个连接的事务第一次更新状态时被创建</span></span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件相关设置，一般只开启三种日志，错误日志，慢查询日志，二进制日志。普通查询日志不开启。</span></span><br><span class="line"><span class="comment"># 普通查询日志，默认值 off，不开启</span></span><br><span class="line"><span class="attr">general_log</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通查询日志存放地址</span></span><br><span class="line"><span class="attr">general_log_file</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-general.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局动态变量，默认 3，范围：1 ～ 3</span></span><br><span class="line"><span class="comment"># 表示错误日志记录的信息，1：只记录 error 信息；2：记录 error 和 warnings 信息；3：记录 error、warnings 和普通的 notes 信息。</span></span><br><span class="line"><span class="attr">log_error_verbosity</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误日志文件地址</span></span><br><span class="line"><span class="attr">log_error</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启慢查询</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启慢查询时间，此处为 1 秒，达到此值才记录数据</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索行数达到此数值，才记录慢查询日志中</span></span><br><span class="line"><span class="attr">min_examined_row_limit</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.6.5 新增，用来表示每分钟允许记录到 slow log 的且未使用索引的 SQL 语句次数，默认值为 0，不限制。</span></span><br><span class="line"><span class="attr">log_throttle_queries_not_using_indexes</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询日志文件地址</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启记录没有使用索引查询语句</span></span><br><span class="line"><span class="attr">log-queries-not-using-indexes</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line"><span class="attr">log_bin</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-bin.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 清除过期日志的时间，默认值 0，不自动清理，而是使用滚动循环的方式。</span></span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于 1GB 或小于 4096 字节。 默认值是 1GB。</span></span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">1000</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># binlog 的格式也有三种：STATEMENT，ROW，MIXED。mysql 5.7.7 后，默认值从 MIXED 改为 ROW</span></span><br><span class="line"><span class="comment"># 关于 binlog 日志格式问题，请查阅网络资料</span></span><br><span class="line"><span class="attr">binlog_format</span> = row</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 N=1，使 binlog 在每 N 次 binlog 写入后与硬盘同步，ps：1 最慢</span></span><br><span class="line"><span class="comment"># sync_binlog = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyISAM 引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引缓冲区的大小，为 MYISAM 数据表开启供线程共享的索引缓存，对 INNODB 引擎无效。相当影响 MyISAM 的性能。</span></span><br><span class="line"><span class="comment"># 不要将其设置大于你可用内存的 30%，因为一部分内存同样被 OS 用来缓冲行数据</span></span><br><span class="line"><span class="comment"># 甚至在你并不使用 MyISAM 表的情况下，你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用。</span></span><br><span class="line"><span class="comment"># 默认值 8M，建议值：对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M。注意：该参数值设置的过大反而会是服务器整体效率降低！</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为每个扫描 MyISAM 的线程分配参数设置的内存大小缓冲区。</span></span><br><span class="line"><span class="comment"># 默认值 128kb，建议值：16G 内存建议 1M，4G：128kb 或者 256kb 吧</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况 128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="comment"># 一般不需要太关心该数值，稍微增大就可以了，</span></span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="number">262144</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持任何存储引擎</span></span><br><span class="line"><span class="comment"># MySQL 的随机读缓冲区大小，适当增大，可以提高性能。</span></span><br><span class="line"><span class="comment"># 默认值 256kb；建议值：得参考连接数，16G 内存，有人推荐 8M</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况 128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># order by 或 group by 时用到</span></span><br><span class="line"><span class="comment"># 支持所有引擎，innodb 和 myisam 有自己的 innodb_sort_buffer_size 和 myisam_sort_buffer_size 设置</span></span><br><span class="line"><span class="comment"># 默认值 256kb；建议值：得参考连接数，16G 内存，有人推荐 8M。</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况 1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此缓冲被使用来优化全联合(full JOINs 不带索引的联合)</span></span><br><span class="line"><span class="comment"># 类似的联合在极大多数情况下有非常糟糕的性能表现，但是将此值设大能够减轻性能影响。</span></span><br><span class="line"><span class="comment"># 通过 “Select_full_join” 状态变量查看全联合的数量</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况 1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="comment"># 默认值 256kb;建议值：16G 内存，设置 8M。</span></span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 linux 文件描述符信息，加快数据文件打开速度</span></span><br><span class="line"><span class="comment"># 它影响 myisam 表的打开关闭，但是不影响 innodb 表的打开关闭。</span></span><br><span class="line"><span class="comment"># 默认值 2000，建议值：根据状态变量 Opened_tables 去设定</span></span><br><span class="line"><span class="attr">table_open_cache</span> = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存表定义的相关信息，加快读取表信息速度</span></span><br><span class="line"><span class="comment"># 默认值 1400，最大值 2000，建议值：基本不改。</span></span><br><span class="line"><span class="attr">table_definition_cache</span> = <span class="number">1400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数是 myssql 5.6 后引入的，目的是提高并发。</span></span><br><span class="line"><span class="comment"># 默认值 1，建议值：cpu 核数，并且&lt;=16</span></span><br><span class="line"><span class="attr">table_open_cache_instances</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁。可重用，减小了系统开销。</span></span><br><span class="line"><span class="comment"># 默认值为 9，建议值：两种取值方式，方式一，根据物理内存，1G —&gt; 8；2G —&gt; 16； 3G —&gt; 32； &gt;3G —&gt; 64；</span></span><br><span class="line"><span class="comment"># 方式二，根据 show status like &#x27;threads%&#x27;，查看 Threads_connected 值。</span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 256k，建议值：16/32G 内存，512kb，其他一般不改变，如果报错：Thread stack overrun，就增大看看，</span></span><br><span class="line"><span class="comment"># 注意，每个线程分配内存空间，所以总内存空间。。。你懂得。</span></span><br><span class="line"><span class="attr">thread_stack</span> = <span class="number">512</span>k</span><br><span class="line"></span><br><span class="line"><span class="comment"># InnoDB 引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：该参数可以提升扩展性和刷脏页性能。</span></span><br><span class="line"><span class="comment"># 默认值 1，建议值：4-8；并且必须小于 innodb_buffer_pool_instances</span></span><br><span class="line"><span class="attr">innodb_page_cleaners</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：一般 8k 和 16k 中选择，8k 的话，cpu 消耗小些，selcet 效率高一点，一般不用改</span></span><br><span class="line"><span class="comment"># 默认值：16k；建议值：不改，</span></span><br><span class="line"><span class="attr">innodb_page_size</span> = <span class="number">16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：InnoDB 使用一个缓冲池来保存索引和原始数据，不像 MyISAM。这里你设置越大，你在存取表里面数据时所需要的磁盘 I/O 越少。</span></span><br><span class="line"><span class="comment"># 在一个独立使用的数据库服务器上，你可以设置这个变量到服务器物理内存大小的 60%-80%</span></span><br><span class="line"><span class="comment"># 注意别设置的过大，会导致 system 的 swap 空间被占用，导致操作系统变慢，从而减低 sql 查询的效率</span></span><br><span class="line"><span class="comment"># 默认值：128M，建议值：物理内存的 60%-80%</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">512</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：只有当设置 innodb_buffer_pool_size 值大于 1G 时才有意义，小于 1G，instances 默认为 1，大于 1G，instances 默认为 8</span></span><br><span class="line"><span class="comment"># 但是网络上有评价，最佳性能，每个实例至少 1G 大小。</span></span><br><span class="line"><span class="comment"># 默认值：1 或 8，建议值：innodb_buffer_pool_size/innodb_buffer_pool_instances &gt;= 1G</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql 5.7 新特性，defines the chunk size for online InnoDB buffer pool resizing operations。</span></span><br><span class="line"><span class="comment"># 实际缓冲区大小必须为 innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances*倍数，取略大于 innodb_buffer_pool_size</span></span><br><span class="line"><span class="comment"># 默认值 128M，建议值：默认值就好，乱改反而容易出问题，它会影响实际 buffer pool 大小。</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_chunk_size</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在启动时把热数据加载到内存。默认值为 on，不修改</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_load_at_startup</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在关闭时把热数据 dump 到本地磁盘。默认值为 on，不修改</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_dump_at_shutdown</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：影响 Innodb 缓冲区的刷新算法，建议从小到大配置，直到 zero free pages；innodb_lru_scan_depth \* innodb_buffer_pool_instances defines the amount of work performed by the page cleaner thread each second。</span></span><br><span class="line"><span class="comment"># 默认值 1024，建议值： 未知</span></span><br><span class="line"><span class="attr">innodb_lru_scan_depth</span> = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：事务等待获取资源等待的最长时间，单位为秒，看具体业务情况，一般默认值就好</span></span><br><span class="line"><span class="comment"># 默认值：50，建议值：看业务。</span></span><br><span class="line"><span class="attr">innodb_lock_wait_timeout</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：设置了 Mysql 后台任务（例如页刷新和 merge dadta from buffer pool）每秒 io 操作的上限。</span></span><br><span class="line"><span class="comment"># 默认值：200，建议值：方法一，单盘 sata 设 100，sas10，raid10 设 200，ssd 设 2000，fushion-io 设 50000；方法二，通过测试工具获得磁盘 io 性能后，设置 IOPS 数值/2。</span></span><br><span class="line"><span class="attr">innodb_io_capacity</span> = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：该参数是所有缓冲区线程 io 操作的总上限。</span></span><br><span class="line"><span class="comment"># 默认值：innodb_io_capacity 的两倍。建议值：例如用 iometer 测试后的 iops 数值就好</span></span><br><span class="line"><span class="attr">innodb_io_capacity_max</span> = <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：控制着 innodb 数据文件及 redo log 的打开、刷写模式，三种模式：fdatasync(默认)，O_DSYNC，O_DIRECT</span></span><br><span class="line"><span class="comment"># fdatasync：数据文件，buffer pool-&gt;os buffer-&gt;磁盘；日志文件，buffer pool-&gt;os buffer-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># O_DSYNC： 数据文件，buffer pool-&gt;os buffer-&gt;磁盘；日志文件，buffer pool-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># O_DIRECT： 数据文件，buffer pool-&gt;磁盘； 日志文件，buffer pool-&gt;os buffer-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># 默认值为空，建议值：使用 SAN 或者 raid，建议用 O_DIRECT，不懂测试的话，默认生产上使用 O_DIRECT</span></span><br><span class="line"><span class="attr">innodb_flush_method</span> = O_DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql5.7 之后默认开启，意思是，每张表一个独立表空间。</span></span><br><span class="line"><span class="comment"># 默认值 1，开启</span></span><br><span class="line"><span class="attr">innodb_file_per_table</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：The path where InnoDB creates undo tablespaces。通常等于 undo log 文件的存放目录。</span></span><br><span class="line"><span class="comment"># 默认值 ./;自行设置</span></span><br><span class="line"><span class="attr">innodb_undo_directory</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：The number of undo tablespaces used by InnoDB 等于 undo log 文件数量。5.7.21 后开始弃用</span></span><br><span class="line"><span class="comment"># 默认值为 0，建议默认值就好，不用调整了。</span></span><br><span class="line"><span class="attr">innodb_undo_tablespaces</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：定义 undo 使用的回滚段数量。5.7.19 后弃用</span></span><br><span class="line"><span class="comment"># 默认值 128，建议不动，以后弃用了。</span></span><br><span class="line"><span class="attr">innodb_undo_logs</span> = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：5.7.5 后开始使用，在线收缩 undo log 使用的空间。</span></span><br><span class="line"><span class="comment"># 默认值：关闭，建议值：开启</span></span><br><span class="line"><span class="attr">innodb_undo_log_truncate</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：结合 innodb_undo_log_truncate，实现 undo 空间收缩功能</span></span><br><span class="line"><span class="comment"># 默认值：1G，建议值，不改。</span></span><br><span class="line"><span class="attr">innodb_max_undo_log_size</span> = <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：重作日志文件的存放目录</span></span><br><span class="line"><span class="attr">innodb_log_group_home_dir</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：日志文件的大小</span></span><br><span class="line"><span class="comment"># 默认值：48M，建议值：根据你系统的磁盘空间和日志增长情况调整大小</span></span><br><span class="line"><span class="attr">innodb_log_file_size</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：日志组中的文件数量，mysql 以循环方式写入日志</span></span><br><span class="line"><span class="comment"># 默认值 2，建议值：根据你系统的磁盘空间和日志增长情况调整大小</span></span><br><span class="line"><span class="attr">innodb_log_files_in_group</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此参数确定些日志文件所用的内存大小，以 M 为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL 开发人员建议设置为 1－8M 之间</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：可以控制 log 从系统 buffer 刷入磁盘文件的刷新频率，增大可减轻系统负荷</span></span><br><span class="line"><span class="comment"># 默认值是 1；建议值不改。系统性能一般够用。</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_timeout</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：参数可设为 0，1，2；</span></span><br><span class="line"><span class="comment"># 参数 0：表示每秒将 log buffer 内容刷新到系统 buffer 中，再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="comment"># 参数 1：表示每次事物提交，将 log buffer 内容刷新到系统 buffer 中，再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="comment"># 参数 2：表示每次事物提交，将 log buffer 内容刷新到系统 buffer 中，隔 1 秒后再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：限制 Innodb 能打开的表的数据，如果库里的表特别多的情况，请增加这个。</span></span><br><span class="line"><span class="comment"># 值默认是 2000，建议值：参考数据库表总数再进行调整，一般够用不用调整。</span></span><br><span class="line"><span class="attr">innodb_open_files</span> = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># innodb 处理 io 读写的后台并发线程数量，根据 cpu 核来确认，取值范围：1-64</span></span><br><span class="line"><span class="comment"># 默认值：4，建议值：与逻辑 cpu 数量的一半保持一致。</span></span><br><span class="line"><span class="attr">innodb_read_io_threads</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">innodb_write_io_threads</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认设置为 0，表示不限制并发数，这里推荐设置为 0，更好去发挥 CPU 多核处理能力，提高并发量</span></span><br><span class="line"><span class="attr">innodb_thread_concurrency</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值为 4，建议不变。InnoDB 中的清除操作是一类定期回收无用数据的操作。mysql 5.5 之后，支持多线程清除操作。</span></span><br><span class="line"><span class="attr">innodb_purge_threads</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql 缓冲区分为 new blocks 和 old blocks；此参数表示 old blocks 占比；</span></span><br><span class="line"><span class="comment"># 默认值：37，建议值，一般不动</span></span><br><span class="line"><span class="attr">innodb_old_blocks_pct</span> = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：新数据被载入缓冲池，进入 old pages 链区，当 1 秒后再次访问，则提升进入 new pages 链区。</span></span><br><span class="line"><span class="comment"># 默认值：1000</span></span><br><span class="line"><span class="attr">innodb_old_blocks_time</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：开启异步 io，可以提高并发性，默认开启。</span></span><br><span class="line"><span class="comment"># 默认值为 1，建议不动</span></span><br><span class="line"><span class="attr">innodb_use_native_aio</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：默认为空，使用 data 目录，一般不改。</span></span><br><span class="line"><span class="attr">innodb_data_home_dir</span>=/usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：Defines the name，size，and attributes of InnoDB system tablespace data files。</span></span><br><span class="line"><span class="comment"># 默认值，不指定，默认为 ibdata1：12M：autoextend</span></span><br><span class="line"><span class="attr">innodb_data_file_path</span> = ibdata1：<span class="number">12</span>M：autoextend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：设置了 InnoDB 存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，除非你的数据对象及其多，否则一般默认不改。</span></span><br><span class="line"><span class="comment"># innodb_additional_mem_pool_size = 16M</span></span><br><span class="line"><span class="comment"># 说明：The crash recovery mode。只有紧急情况需要恢复数据的时候，才改为大于 1-6 之间数值，含义查下官网。</span></span><br><span class="line"><span class="comment"># 默认值为 0；</span></span><br><span class="line"><span class="comment">#innodb_force_recovery = 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqldump]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># quick 选项强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中</span></span><br><span class="line">quick</span><br><span class="line"></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 命令行工具不使用自动补全功能，建议还是改为</span></span><br><span class="line"><span class="comment"># no-auto-rehash</span></span><br><span class="line">auto-rehash</span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
<h2 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11220393.html">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5f39c486561b">Mysql 配置文件/etc/my.cnf 解析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/14d4f061.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/14d4f061.html" class="post-title-link" itemprop="url">效率提升方法论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T16:00:00+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/" itemprop="url" rel="index"><span itemprop="name">效率提升</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/14d4f061.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="14d4f061.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="效率提升方法论"><a class="markdownIt-Anchor" href="#效率提升方法论"></a> 效率提升方法论</h1>
<p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p>
<p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p>
<p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p>
<blockquote>
<p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p>
<p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p>
<p>——莎士比亚</p>
</blockquote>
<h2 id="5w2h"><a class="markdownIt-Anchor" href="#5w2h"></a> 5W2H</h2>
<p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p>
<p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210161837.png" alt="5W2H" /></p>
<ul>
<li>
<p><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</p>
</li>
<li>
<p><strong>what</strong> - 是什么？目的是什么？作什么工作？</p>
</li>
<li>
<p><strong>where</strong> - 何处？在哪里做？从哪里入手？</p>
</li>
<li>
<p><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</p>
</li>
<li>
<p><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</p>
</li>
<li>
<p><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</p>
</li>
<li>
<p><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p>
</li>
</ul>
<h2 id="四象限原则"><a class="markdownIt-Anchor" href="#四象限原则"></a> 四象限原则</h2>
<p><strong>四象限原则是一种时间管理方式</strong>。</p>
<p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p>
<p>事情、任务太多，时间太少，分身乏术。</p>
<p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210173335.png" alt="img" /></p>
<ul>
<li>
<p><strong>第一象限（重要而紧急</strong>）</p>
<ul>
<li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li>
<li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li>
<li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li>
</ul>
</li>
<li>
<p><strong>第二象限（重要但不紧急）</strong></p>
<ul>
<li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li>
<li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li>
<li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li>
</ul>
</li>
<li>
<p><strong>第三象限（紧急但不重要）</strong></p>
<ul>
<li>案例：电话、会议、突发的访客都属于这一类。</li>
<li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li>
</ul>
</li>
<li>
<p><strong>第四象限（不紧急也不重要）</strong></p>
<ul>
<li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li>
<li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/4f51c5e8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/4f51c5e8.html" class="post-title-link" itemprop="url">Hbase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/4f51c5e8.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="4f51c5e8.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="hbase"><a class="markdownIt-Anchor" href="#hbase"></a> HBase</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>HBase 是建立在 HDFS 基础上的面向列的分布式数据库。</p>
<ul>
<li>HBase 参考了谷歌的 BigTable 建模，实现的编程语言为 Java。</li>
<li>它是 Hadoop 项目的子项目，运行于 HDFS 文件系统之上。</li>
</ul>
<p>HBase 适用场景：实时地随机访问超大数据集。</p>
<p>在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP 理论</a>中，HBase 属于 CP 类型的系统。</p>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<p><a href="HBase%E8%BF%90%E7%BB%B4.md">HBase 维护</a></p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3>
<p>HBase 是一个面向列的数据库，在表中它由行排序。</p>
<p>HBase 表模型结构为：</p>
<ul>
<li>表（table）是行的集合。</li>
<li>行（row）是列族的集合。</li>
<li>列族（column family）是列的集合。</li>
<li>列（row）是键值对的集合。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164163369.png" alt="img" /></p>
<p>HBase 表的单元格（cell）由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为 HBase 插入单元格时的时间戳。单元格的内容是未解释的字节数组。</p>
<p>行的键也是未解释的字节数组，所以理论上，任何数据都可以通过序列化表示成字符串或二进制，从而存为 HBase 的键值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164224778.png" alt="img" /></p>
<h3 id="hbase-架构"><a class="markdownIt-Anchor" href="#hbase-架构"></a> HBase 架构</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164744748.png" alt="img" /></p>
<p>和 HDFS、YARN 一样，HBase 也采用 master / slave 架构：</p>
<ul>
<li>HBase 有一个 master 节点。master 节点负责将区域（region）分配给 region 节点；恢复 region 节点的故障。</li>
<li>HBase 有多个 region 节点。region 节点负责零个或多个区域（region）的管理并相应客户端的读写请求。region 节点还负责区域的划分并通知 master 节点有了新的子区域。</li>
</ul>
<p>HBase 依赖 ZooKeeper 来实现故障恢复。</p>
<h4 id="regin"><a class="markdownIt-Anchor" href="#regin"></a> Regin</h4>
<p>HBase 表按行键范围水平自动划分为区域（region）。每个区域由表中行的子集构成。每个区域由它所属的表、它所含的第一行及最后一行来表示。</p>
<p><strong>区域只不过是表被拆分，并分布在区域服务器。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551165887616.png" alt="img" /></p>
<h4 id="master-服务器"><a class="markdownIt-Anchor" href="#master-服务器"></a> Master 服务器</h4>
<p>区域分配、DDL(create、delete)操作由 HBase master 服务器处理。</p>
<ul>
<li>master 服务器负责协调 region 服务器
<ul>
<li>协助区域启动，出现故障恢复或负载均衡情况时，重新分配 region 服务器</li>
<li>监控集群中的所有 region 服务器</li>
</ul>
</li>
<li>支持 DDL 接口（创建、删除、更新表）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166513572.png" alt="img" /></p>
<h4 id="regin-服务器"><a class="markdownIt-Anchor" href="#regin-服务器"></a> Regin 服务器</h4>
<p>区域服务器运行在 HDFS 数据节点上，具有以下组件</p>
<ul>
<li>
<p><code>WAL</code> - Write Ahead Log 是 HDFS 上的文件。WAL 存储尚未持久存储到永久存储的新数据，它用于在发生故障时进行恢复。</p>
</li>
<li>
<p><code>BlockCache</code> - 是读缓存。它将频繁读取的数据存储在内存中。至少最近使用的数据在完整时被逐出。</p>
</li>
<li>
<p><code>MemStore</code> - 是写缓存。它存储尚未写入磁盘的新数据。在写入磁盘之前对其进行排序。每个区域每个列族有一个 MemStore。</p>
</li>
<li>
<p><code>Hfiles</code> - 将行存储为磁盘上的排序键值对。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166602999.png" alt="img" /></p>
<h4 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> ZooKeeper</h4>
<p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。Zookeeper 维护哪些服务器是活动的和可用的，并提供服务器故障通知。集群至少应该有 3 个节点。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166447147.png" alt="img" /></p>
<h2 id="hbase-和-rdbms"><a class="markdownIt-Anchor" href="#hbase-和-rdbms"></a> HBase 和 RDBMS</h2>
<table>
<thead>
<tr>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>HBase 无模式，它不具有固定列模式的概念;仅定义列族。</td>
<td>RDBMS 有它的模式，描述表的整体结构的约束。</td>
</tr>
<tr>
<td>它专门创建为宽表。 HBase 是横向扩展。</td>
<td>这些都是细而专为小表。很难形成规模。</td>
</tr>
<tr>
<td>没有任何事务存在于 HBase。</td>
<td>RDBMS 是事务性的。</td>
</tr>
<tr>
<td>它反规范化的数据。</td>
<td>它具有规范化的数据。</td>
</tr>
<tr>
<td>它用于半结构以及结构化数据是非常好的。</td>
<td>用于结构化数据非常好。</td>
</tr>
</tbody>
</table>
<h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2>
<p>Java API 归纳总结在这里：<a href="hbase-api-java.md">HBase 应用</a></p>
<h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2>
<h3 id="命令行"><a class="markdownIt-Anchor" href="#命令行"></a> 命令行</h3>
<p>HBase 命令行可以参考这里：<a href="HBase%E5%91%BD%E4%BB%A4.md">HBase 命令行</a></p>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<ul>
<li><a href="HBase%E5%91%BD%E4%BB%A4.md">HBase 命令</a></li>
<li><a href="HBase%E8%BF%90%E7%BB%B4.md">HBase 运维</a></li>
</ul>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<h4 id="官方"><a class="markdownIt-Anchor" href="#官方"></a> 官方</h4>
<ul>
<li><a target="_blank" rel="noopener" href="http://hbase.apache.org/">HBase 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html">HBase 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://abloz.com/hbase/book.html">HBase 官方文档中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/apidocs/index.html">HBase API</a></li>
</ul>
<h4 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a target="_blank" rel="noopener" href="https://mapr.com/blog/in-depth-look-hbase-architecture">An In-Depth Look at the HBase Architecture</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/4b832ddf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/4b832ddf.html" class="post-title-link" itemprop="url">Mysql 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/4b832ddf.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="4b832ddf.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>388</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-教程"><a class="markdownIt-Anchor" href="#mysql-教程"></a> Mysql 教程</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716103611.png" alt="img" /></p>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 📖 内容</h2>
<h3 id="mysql-应用指南"><a class="markdownIt-Anchor" href="#mysql-应用指南"></a> <a href="01.Mysql%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.md">Mysql 应用指南</a></h3>
<h3 id="mysql-工作流"><a class="markdownIt-Anchor" href="#mysql-工作流"></a> <a href="02.MySQL%E5%B7%A5%E4%BD%9C%E6%B5%81.md">Mysql 工作流</a></h3>
<h3 id="mysql-事务"><a class="markdownIt-Anchor" href="#mysql-事务"></a> <a href="03.Mysql%E4%BA%8B%E5%8A%A1.md">Mysql 事务</a></h3>
<blockquote>
<p>关键词：<code>ACID</code>、<code>AUTOCOMMIT</code>、<code>事务隔离级别</code>、<code>死锁</code>、<code>分布式事务</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716074533.png" alt="img" /></p>
<h3 id="mysql-锁"><a class="markdownIt-Anchor" href="#mysql-锁"></a> <a href="04.Mysql%E9%94%81.md">Mysql 锁</a></h3>
<blockquote>
<p>关键词：<code>乐观锁</code>、<code>表级锁</code>、<code>行级锁</code>、<code>意向锁</code>、<code>MVCC</code>、<code>Next-key 锁</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716064947.png" alt="img" /></p>
<h3 id="mysql-索引"><a class="markdownIt-Anchor" href="#mysql-索引"></a> <a href="05.Mysql%E7%B4%A2%E5%BC%95.md">Mysql 索引</a></h3>
<blockquote>
<p>关键词：<code>Hash</code>、<code>B 树</code>、<code>聚簇索引</code>、<code>回表</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200715172009.png" alt="img" /></p>
<h3 id="mysql-性能优化"><a class="markdownIt-Anchor" href="#mysql-性能优化"></a> <a href="06.Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Mysql 性能优化</a></h3>
<h3 id="mysql-运维"><a class="markdownIt-Anchor" href="#mysql-运维"></a> <a href="20.Mysql%E8%BF%90%E7%BB%B4.md">Mysql 运维</a> 🔨</h3>
<h3 id="mysql-配置"><a class="markdownIt-Anchor" href="#mysql-配置"></a> <a href="21.Mysql%E9%85%8D%E7%BD%AE.md">Mysql 配置</a> 🔨</h3>
<h3 id="mysql-常见问题"><a class="markdownIt-Anchor" href="#mysql-常见问题"></a> <a href="99.Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Mysql 常见问题</a></h3>
<hr />
<p>相关扩展知识：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/sql-interview.md">关系型数据库面试总结</a> 💯</li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/sql-cheat-sheet.md">SQL Cheat Sheet</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md">分布式事务基本原理</a></li>
</ul>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 📚 资料</h2>
<ul>
<li><strong>官方</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.mysql.com/">Mysql 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/">Mysql 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysql.html">Mysql 官方文档之命令行客户端</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a> - 经典，适合 DBA 或作为开发者的参考手册</li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3354490/">《MySQL 必知必会》</a> - 适合入门者</li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/mysql/mysql-tutorial.html">runoob.com MySQL 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial">mysql-tutorial</a></li>
</ul>
</li>
<li><strong>更多资源</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jobbole/awesome-mysql-cn">awesome-mysql</a></li>
</ul>
</li>
</ul>
<h2 id="传送"><a class="markdownIt-Anchor" href="#传送"></a> 🚪 传送</h2>
<p>◾ 🏠 <a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial">DB-TUTORIAL 首页</a> ◾ 🎯 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog">我的博客</a> ◾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/e6125021.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/e6125021.html" class="post-title-link" itemprop="url">Redis 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/e6125021.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="e6125021.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>837</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-教程"><a class="markdownIt-Anchor" href="#redis-教程"></a> Redis 教程</h1>
<blockquote>
<p>Redis 最典型的应用场景是作为分布式缓存。</p>
<p>学习 Redis，有必要深入理解缓存的原理，以及 Redis 作为一种缓存方案，在系统应用中的定位。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">缓存基本原理</a>，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。</p>
</blockquote>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 📖 内容</h2>
<h3 id="redis-面试总结"><a class="markdownIt-Anchor" href="#redis-面试总结"></a> <a href="01.Redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.md">Redis 面试总结 💯</a></h3>
<h3 id="redis-应用指南"><a class="markdownIt-Anchor" href="#redis-应用指南"></a> <a href="02.Redis%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.md">Redis 应用指南 ⚡</a></h3>
<blockquote>
<p>关键词：<code>内存淘汰</code>、<code>事件</code>、<code>事务</code>、<code>管道</code>、<code>发布与订阅</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713105627.png" alt="img" /></p>
<h3 id="redis-数据类型和应用"><a class="markdownIt-Anchor" href="#redis-数据类型和应用"></a> <a href="03.Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8.md">Redis 数据类型和应用</a></h3>
<blockquote>
<p>关键词：<code>STRING</code>、<code>HASH</code>、<code>LIST</code>、<code>SET</code>、<code>ZSET</code>、<code>BitMap</code>、<code>HyperLogLog</code>、<code>Geo</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200226113813.png" alt="Redis 数据类型" /></p>
<h3 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> <a href="04.Redis%E6%8C%81%E4%B9%85%E5%8C%96.md">Redis 持久化</a></h3>
<blockquote>
<p>关键词：<code>RDB</code>、<code>AOF</code>、<code>SAVE</code>、<code>BGSAVE</code>、<code>appendfsync</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224214047.png" alt="img" /></p>
<h3 id="redis-复制"><a class="markdownIt-Anchor" href="#redis-复制"></a> <a href="05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></h3>
<blockquote>
<p>关键词：<code>SLAVEOF</code>、<code>SYNC</code>、<code>PSYNC</code>、<code>REPLCONF ACK</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712182603.png" alt="img" /></p>
<h3 id="redis-哨兵"><a class="markdownIt-Anchor" href="#redis-哨兵"></a> <a href="06.Redis%E5%93%A8%E5%85%B5.md">Redis 哨兵</a></h3>
<blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 的高可用性（Hight Availability）解决方案。</p>
<p>Redis 哨兵是 Raft 算法 的具体实现。</p>
<p>关键词：<code>Sentinel</code>、<code>PING</code>、<code>INFO</code>、<code>Raft</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img" /></p>
<h3 id="redis-集群"><a class="markdownIt-Anchor" href="#redis-集群"></a> <a href="07.Redis%E9%9B%86%E7%BE%A4.md">Redis 集群</a></h3>
<blockquote>
<p>关键词：<code>CLUSTER MEET</code>、<code>Hash slot</code>、<code>MOVED</code>、<code>ASK</code>、<code>SLAVEOF no one</code>、<code>redis-trib</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713100613.png" alt="img" /></p>
<h3 id="redis-实战"><a class="markdownIt-Anchor" href="#redis-实战"></a> <a href="08.Redis%E5%AE%9E%E6%88%98.md">Redis 实战</a></h3>
<blockquote>
<p>关键词：<code>缓存</code>、<code>分布式锁</code>、<code>布隆过滤器</code></p>
</blockquote>
<h3 id="redis-运维"><a class="markdownIt-Anchor" href="#redis-运维"></a> <a href="20.Redis%E8%BF%90%E7%BB%B4.md">Redis 运维 🔨</a></h3>
<blockquote>
<p>关键词：<code>安装</code>、<code>命令</code>、<code>集群</code>、<code>客户端</code></p>
</blockquote>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 📚 资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/dvirsky/introduction-to-redis">Introduction to Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5db66ed9e51d452a2f15d833">《我们一起进大厂》系列- Redis 基础</a></li>
</ul>
</li>
<li><strong>源码</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/josiahcarlson/redis-in-action">《Redis 实战》配套 Python 源码</a></li>
</ul>
</li>
<li><strong>资源汇总</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/JamzyWang/awesome-redis">awesome-redis</a></li>
</ul>
</li>
<li><strong>Redis Client</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/1.8.13.RELEASE/reference/html/">spring-data-redis 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">redisson 官方文档(中文,略有滞后)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/Table-of-Content">redisson 官方文档(英文)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/82f0d5abb002">CRUG | Redisson PRO vs. Jedis: Which Is Faster? 翻译</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/everlasting_188/article/details/51073505">redis 分布锁 Redisson 性能测试</a></li>
</ul>
</li>
</ul>
<h2 id="传送"><a class="markdownIt-Anchor" href="#传送"></a> 🚪 传送</h2>
<p>◾ 🏠 <a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial">DB-TUTORIAL 首页</a> ◾ 🎯 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog">我的博客</a> ◾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/e850d375.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/e850d375.html" class="post-title-link" itemprop="url">Nosql技术选型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-09 02:18:58" itemprop="dateCreated datePublished" datetime="2020-02-09T02:18:58+08:00">2020-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">数据库综合</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/e850d375.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="e850d375.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="nosql-技术选型"><a class="markdownIt-Anchor" href="#nosql-技术选型"></a> Nosql 技术选型</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209020702.png" alt="img" /></p>
<h2 id="一-nosql-简介"><a class="markdownIt-Anchor" href="#一-nosql-简介"></a> 一、Nosql 简介</h2>
<p>传统的关系型数据库存在以下缺点：</p>
<ul>
<li><strong>大数据场景下 I/O 较高</strong> - 因为数据是按行存储，即使只针对其中某一列进行运算，关系型数据库也会将整行数据从存储设备中读入内存，导致 I/O 较高。</li>
<li>存储的是行记录，<strong>无法存储数据结构</strong>。</li>
<li><strong>表结构 schema 扩展不方便</strong> - 如要需要修改表结构，需要执行执行 DDL(data definition language)，语句修改，修改期间会导致锁表，部分服务不可用。</li>
<li><strong>全文搜索功能较弱</strong> - 关系型数据库下只能够进行子字符串的匹配查询，当表的数据逐渐变大的时候，<code>LIKE</code> 查询的匹配会非常慢，即使在有索引的情况下。况且关系型数据库也不应该对文本字段进行索引。</li>
<li><strong>存储和处理复杂关系型数据功能较弱</strong> - 许多应用程序需要了解和导航高度连接数据之间的关系，才能启用社交应用程序、推荐引擎、欺诈检测、知识图谱、生命科学和 IT/网络等用例。然而传统的关系数据库并不善于处理数据点之间的关系。它们的表格数据模型和严格的模式使它们很难添加新的或不同种类的关联信息。</li>
</ul>
<p>随着大数据时代的到来，越来越多的网站、应用系统需要支撑海量数据存储，高并发请求、高可用、高可扩展性等特性要求。传统的关系型数据库在应付这些调整已经显得力不从心，暴露了许多能以克服的问题。由此，各种各样的 NoSQL（Not Only SQL）数据库作为传统关系型数据的一个有力补充得到迅猛发展。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005228.png" alt="nosql-history" /></p>
<p><strong>NoSQL，泛指非关系型的数据库</strong>，可以理解为 SQL 的一个有力补充。</p>
<p>在 NoSQL 许多方面性能大大优于非关系型数据库的同时，往往也伴随一些特性的缺失，比较常见的，是事务库事务功能的缺失。 数据库事务正确执行的四个基本要素：ACID 如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">Atomicity (原子性)</td>
<td style="text-align:center">一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。 事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">Consistency 一致性</td>
<td style="text-align:center">在事务开始之前和事务结束以后，数据的数据的一致性约束没有被破坏。</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">Isolation 隔离性</td>
<td style="text-align:center">数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">Durability 持久性</td>
<td style="text-align:center">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td>
</tr>
</tbody>
</table>
<p>下面介绍 5 大类 NoSQL 数据针对传统关系型数据库的缺点提供的解决方案：</p>
<h2 id="二-列式数据库"><a class="markdownIt-Anchor" href="#二-列式数据库"></a> 二、列式数据库</h2>
<p>列式数据库是以列相关存储架构进行数据存储的数据库，主要<strong>适合于批量数据处理和即时查询</strong>。</p>
<p>相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。</p>
<p>基于列式数据库的列列存储特性，可以<strong>解决某些特定场景下关系型数据库 I/O 较高的问题</strong>。</p>
<h3 id="列式数据库原理"><a class="markdownIt-Anchor" href="#列式数据库原理"></a> 列式数据库原理</h3>
<p>传统关系型数据库是按照行来存储数据库，称为“行式数据库”，而列式数据库是按照列来存储数据。</p>
<p>将表放入存储系统中有两种方法，而我们绝大部分是采用行存储的。 行存储法是将各行放入连续的物理位置，这很像传统的记录和文件系统。 列存储法是将数据按照列存储到数据库中，与行存储类似，下图是两种存储方法的图形化解释：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005316.png" alt="按行存储和按列存储模式" /></p>
<h3 id="列式数据库产品"><a class="markdownIt-Anchor" href="#列式数据库产品"></a> 列式数据库产品</h3>
<ul>
<li>
<p>HBase</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e88bddc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HBase" /></p>
<p>HBase 是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的 BigTable 建模，实现的编程语言为 Java。它是 Apache 软件基金会的 Hadoop 项目的一部分，运行于 HDFS 文件系统之上，为 Hadoop 提供类似于 BigTable 规模的服务。因此，它可以容错地存储海量稀疏的数据。</p>
</li>
<li>
<p>BigTable</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e9147edf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>BigTable 是一种压缩的、高性能的、高可扩展性的，基于 Google 文件系统（Google File System，GFS）的数据存储系统，用于存储大规模结构化数据，适用于云端计算。</p>
</li>
</ul>
<h3 id="列式数据库特性"><a class="markdownIt-Anchor" href="#列式数据库特性"></a> 列式数据库特性</h3>
<p>优点如下：</p>
<ul>
<li><strong>高效的储存空间利用率</strong></li>
</ul>
<p>列式数据库由于其针对不同列的数据特征而发明的不同算法，使其<strong>往往有比行式数据库高的多的压缩率</strong>，普通的行式数据库一般压缩率在 3：1 到 5：1 左右，而列式数据库的压缩率一般在 8：1 到 30：1 左右。 比较常见的，通过字典表压缩数据： 下面中才是那张表本来的样子。经过字典表进行数据压缩后，表中的字符串才都变成数字了。正因为每个字符串在字典表里只出现一次了，所以达到了压缩的目的(有点像规范化和非规范化 Normalize 和 Denomalize)</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005406.png" alt="通过字典表压缩数据" /></p>
<ul>
<li><strong>查询效率高</strong></li>
</ul>
<p>读取多条数据的同一列效率高，因为这些列都是存储在一起的，一次磁盘操作可以数据的指定列全部读取到内存中。 下图通过一条查询的执行过程说明列式存储(以及数据压缩)的优点</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005611.png" alt="img" /></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">执行步骤如下：</span><br><span class="line"><span class="selector-tag">i</span>. 去字典表里找到字符串对应数字(只进行一次字符串比较)。</span><br><span class="line">ii. 用数字去列表里匹配，匹配上的位置设为<span class="number">1</span>。</span><br><span class="line">iii. 把不同列的匹配结果进行位运算得到符合所有条件的记录下标。</span><br><span class="line">iv. 使用这个下标组装出最终的结果集。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>适合做聚合操作</strong></li>
<li><strong>适合大量的数据而不是小数据</strong></li>
</ul>
<p>缺点如下：</p>
<ul>
<li>不适合扫描小量数据</li>
<li>不适合随机的更新</li>
<li>不适合做含有删除和更新的实时操作</li>
<li>单行的数据是 ACID 的，多行的事务时，不支持事务的正常回滚，支持 I(Isolation)隔离性(事务串行提交)，D(Durability)持久性，不能保证 A(Atomicity)原子性， C(Consistency)一致性</li>
</ul>
<h3 id="列式数据库使用场景"><a class="markdownIt-Anchor" href="#列式数据库使用场景"></a> 列式数据库使用场景</h3>
<p>以 HBase 为例说明：</p>
<ul>
<li><strong>大数据量</strong> （100s TB 级数据） 且有快速随机访问的需求。增长量无法预估的应用，需要进行优雅的数据扩展的 HBase 支持在线扩展，即使在一段时间内数据量呈井喷式增长，也可以通过 HBase 横向扩展来满足功能。</li>
<li><strong>写密集型</strong>应用，每天写入量巨大，而相对读数量较小的应用 比如 IM 的历史消息，游戏的日志等等</li>
<li><strong>不需要复杂查询条件</strong>来查询数据的应用 HBase 只支持基于 rowkey 的查询，对于 HBase 来说，单条记录或者小范围的查询是可以接受的，大范围的查询由于分布式的原因，可能在性能上有点影响，HBase 不适用于有 join，多级索引，表关系复杂的数据模型。</li>
<li><strong>对性能和可靠性要求非常高</strong>的应用，由于 HBase 本身没有单点故障，可用性非常高。</li>
<li><strong>存储结构化和半结构化的数据</strong>。</li>
</ul>
<h2 id="三-k-v-数据库"><a class="markdownIt-Anchor" href="#三-k-v-数据库"></a> 三、K-V 数据库</h2>
<p><strong>K-V 数据库指的是使用键值(key-value)存储的数据库，其数据按照键值对的形式进行组织、索引和存储</strong>。</p>
<p>KV 存储非常适合存储<strong>不涉及过多数据关系业务关系的数据</strong>，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够<strong>解决关系型数据库无法存储数据结构的问题</strong>。</p>
<h3 id="k-v-数据库产品"><a class="markdownIt-Anchor" href="#k-v-数据库产品"></a> K-V 数据库产品</h3>
<ul>
<li>
<p>Redis</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209010410.png" alt="img" /></p>
<p>Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从 2015 年 6 月开始，Redis 的开发由 Redis Labs 赞助，而 2013 年 5 月至 2015 年 6 月期间，其开发由 Pivotal 赞助。在 2013 年 5 月之前，其开发由 VMware 赞助。根据月度排行网站 <a target="_blank" rel="noopener" href="http://DB-Engines.com">DB-Engines.com</a> 的数据显示，Redis 是最流行的键值对存储数据库。</p>
</li>
<li>
<p>Cassandra</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209010451.png" alt="img" /></p>
<p>Apache Cassandra（社区内一般简称为 C*）是一套开源分布式 NoSQL 数据库系统。它最初由 Facebook 开发，用于储存收件箱等简单格式数据，集 Google BigTable 的数据模型与 Amazon Dynamo 的完全分布式架构于一身。Facebook 于 2008 将 Cassandra 开源，此后，由于 Cassandra 良好的可扩展性和性能，被 Apple, Comcast,Instagram, Spotify, eBay, Rackspace, Netflix 等知名网站所采用，成为了一种流行的分布式结构化数据存储方案。</p>
</li>
<li>
<p>LevelDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209011140.png" alt="img" /></p>
<p>LevelDB 是一个由 Google 公司所研发的键／值对（Key/Value Pair）嵌入式数据库管理系统编程库， 以开源的 BSD 许可证发布。</p>
</li>
</ul>
<h3 id="k-v-数据库特性"><a class="markdownIt-Anchor" href="#k-v-数据库特性"></a> K-V 数据库特性</h3>
<p>以 Redis 为例：</p>
<p>优点如下：</p>
<ul>
<li><strong>性能极高</strong> - Redis 能支持超过 10W 的 TPS。</li>
<li><strong>丰富的数据类型</strong> - Redis 支持包括 String，Hash，List，Set，Sorted Set，Bitmap 和 hyperloglog。</li>
<li><strong>丰富的特性</strong> - Redis 还支持 publish/subscribe、通知、key 过期等等特性。</li>
</ul>
<p>缺点如下： 针对 ACID，Redis 事务不能支持原子性和持久性(A 和 D)，只支持隔离性和一致性(I 和 C) 特别说明一下，这里所说的无法保证原子性，是针对 Redis 的事务操作，因为事务是不支持回滚（roll back），而因为 Redis 的单线程模型，<strong>Redis 的普通操作是原子性的</strong>。</p>
<p>大部分业务不需要严格遵循 ACID 原则，例如游戏实时排行榜，粉丝关注等场景，即使部分数据持久化失败，其实业务影响也非常小。因此在设计方案时，需要根据业务特征和要求来做选择</p>
<h3 id="k-v-数据库使用场景"><a class="markdownIt-Anchor" href="#k-v-数据库使用场景"></a> K-V 数据库使用场景</h3>
<ul>
<li>
<p><strong>适用场景</strong> - 储存用户信息(比如会话)、配置文件、参数、购物车等等。这些信息一般都和 ID（键）挂钩。</p>
</li>
<li>
<p><strong>不适用场景</strong></p>
<ul>
<li>需要通过值来查询，而不是键来查询。Key-Value 数据库中根本没有通过值查询的途径。</li>
<li>需要储存数据之间的关系。在 Key-Value 数据库中不能通过两个或以上的键来关联数据</li>
<li>需要事务的支持。在 Key-Value 数据库中故障产生时不可以进行回滚。</li>
</ul>
</li>
</ul>
<h2 id="四-文档数据库"><a class="markdownIt-Anchor" href="#四-文档数据库"></a> 四、文档数据库</h2>
<p>文档数据库（也称为文档型数据库）是<strong>旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题</strong>。文档数据库<strong>通常以 JSON 或 XML 格式存储数据</strong>。</p>
<p>由于文档数据库的 no-schema 特性，可以存储和读取任意数据。由于使用的数据格式是 JSON 或者 XML，无需在使用前定义字段，读取一个 JSON 中不存在的字段也不会导致 SQL 那样的语法错误。</p>
<h3 id="文档数据库产品"><a class="markdownIt-Anchor" href="#文档数据库产品"></a> 文档数据库产品</h3>
<ul>
<li>
<p>MongoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209012320.png" alt="img" /></p>
<p><strong>MongoDB</strong>是一种面向文档的数据库管理系统，由 C++ 撰写而成，以此来解决应用程序开发社区中的大量现实问题。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。</p>
</li>
<li>
<p>CouchDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209012418.png" alt="img" /></p>
<p>Apache CouchDB 是一个开源数据库，专注于易用性和成为&quot;<strong>完全拥抱 web 的数据库</strong>&quot;。它是一个使用 JSON 作为存储格式，JavaScript 作为查询语言，MapReduce 和 HTTP 作为 API 的 NoSQL 数据库。其中一个显著的功能就是多主复制。CouchDB 的第一个版本发布在 2005 年，在 2008 年成为了 Apache 的项目。</p>
</li>
</ul>
<h3 id="文档数据库特性"><a class="markdownIt-Anchor" href="#文档数据库特性"></a> 文档数据库特性</h3>
<p>以 MongoDB 为例进行说明</p>
<p>优点如下：</p>
<ul>
<li><strong>容易存储复杂数据结构</strong> - JSON 是一种强大的描述语言，能够描述复杂的数据结构。</li>
<li><strong>容易变更数据结构</strong> - 无需像关系型数据库一样先执行 DDL 语句修改表结构，程序代码直接读写即可。</li>
<li><strong>容易兼容历史数据</strong> - 对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码兼容处理即可。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong>
<ul>
<li>Atomicity(原子性) 仅支持单行/文档级原子性，不支持多行、多文档、多语句原子性。</li>
<li>Isolation(隔离性) 隔离级别仅支持已提交读（Read committed）级别，可能导致不可重复读，幻读的问题。</li>
</ul>
</li>
<li><strong>不支持复杂查询</strong> - 例如 join 查询，如果需要 join 查询，需要多次操作数据库。</li>
</ul>
<p>MongonDB 还是支持多文档事务的 Consistency(一致性)和 Durability(持久性)</p>
<p>虽然官方宣布 MongoDB 将在 4.0 版本中正式推出多文档 ACID 事务支持，最后落地情况还有待见证。</p>
<h3 id="文档数据库使用场景"><a class="markdownIt-Anchor" href="#文档数据库使用场景"></a> 文档数据库使用场景</h3>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>大数据量，且未来数据增长很快</strong></li>
<li><strong>表结构不明确，且字段在不断增加</strong>，例如内容管理系统，信息管理系统</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>支持事务</strong> - 在不同的文档上需要添加事务。Document-Oriented 数据库并不支持文档间的事务</li>
<li><strong>支持复杂查询</strong> - 多个文档直接需要复杂查询，例如 join</li>
</ul>
<h2 id="五-全文搜索引擎"><a class="markdownIt-Anchor" href="#五-全文搜索引擎"></a> 五、全文搜索引擎</h2>
<p>传统关系型数据库主要通过索引来达到快速查询的目的，在全文搜索的业务下，索引也无能为力，主要体现在：</p>
<ul>
<li>全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量非常多</li>
<li>全文搜索的模糊匹配方式，索引无法满足，只能用 <code>LIKE</code> 查询，而 <code>LIKE</code> 查询是整表扫描，效率非常低</li>
</ul>
<p>而全文搜索引擎的出现，正是<strong>解决关系型数据库全文搜索功能较弱的问题</strong>。</p>
<h3 id="搜索引擎原理"><a class="markdownIt-Anchor" href="#搜索引擎原理"></a> 搜索引擎原理</h3>
<p>全文搜索引擎的技术原理称为 <strong><code>倒排索引（inverted index）</code></strong>，是一种索引方法，其基本原理是建立单词到文档的索引。与之相对是，是“正排索引”，其基本原理是建立文档到单词的索引。</p>
<p>现在有如下文档集合：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014530.png" alt="img" /></p>
<p>正排索引得到索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014723.png" alt="img" /></p>
<p>可见，正排索引适用于根据文档名称查询文档内容</p>
<p>简单的倒排索引如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2750634bc?imageslim" alt="img" /></p>
<p>带有单词频率信息的倒排索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014842.png" alt="img" /></p>
<p>可见，倒排索引适用于根据关键词来查询文档内容</p>
<h3 id="搜索引擎产品"><a class="markdownIt-Anchor" href="#搜索引擎产品"></a> 搜索引擎产品</h3>
<ul>
<li>
<p>Elasticsearch</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a27ea53fae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>Elasticsearch 是一个基于 Lucene 的搜索引擎。它提供了一个分布式，多租户 -能够全文搜索与发动机 HTTP Web 界面和无架构 JSON 文件。Elasticsearch 是用 Java 开发的，并根据 Apache License 的条款作为开源发布。根据 DB-Engines 排名，Elasticsearch 是最受欢迎的企业搜索引擎，后面是基于 Lucene 的 Apache Solr。</p>
</li>
<li>
<p>Solr</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014947.png" alt="img" /></p>
<p>Solr 是 Apache Lucene 项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如 Word、PDF）的处理。Solr 是高度可扩展的，并提供了分布式搜索和索引复制</p>
</li>
</ul>
<h3 id="搜索引擎特性"><a class="markdownIt-Anchor" href="#搜索引擎特性"></a> 搜索引擎特性</h3>
<p>以 Elasticsearch 为例： 优点如下：</p>
<ul>
<li><strong>查询效率高</strong> - 对海量数据进行近实时的处理</li>
<li><strong>可扩展性</strong> - 基于集群环境可以方便横向扩展，可以承载 PB 级数据</li>
<li><strong>高可用</strong> - Elasticsearch 集群弹性-他们将发现新的或失败的节点，重组和重新平衡数据，确保数据是安全的和可访问的</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong> - 单一文档的数据是 ACID 的，包含多个文档的事务时不支持事务的正常回滚，支持 I(Isolation)隔离性（基于乐观锁机制的），D(Durability)持久性，<strong>不支持 A(Atomicity)原子性，C(Consistency)一致性</strong></li>
<li>对类似数据库中通过外键的复杂的多表关联操作支持较弱。</li>
<li><strong>读写有一定延时</strong>，写入的数据，最快 1s 中能被检索到</li>
<li><strong>更新性能较低</strong>，底层实现是先删数据，再插入新数据</li>
<li><strong>内存占用大</strong>，因为 Lucene 将索引部分加载到内存中</li>
</ul>
<h3 id="搜索引擎场景"><a class="markdownIt-Anchor" href="#搜索引擎场景"></a> 搜索引擎场景</h3>
<p>适用场景如下：</p>
<ul>
<li><strong>搜索引擎和数据分析引擎</strong> - 全文检索，结构化检索，数据分析</li>
<li><strong>对海量数据进行近实时的处理</strong> - 可以将海量数据分散到多台服务器上去存储和检索</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li><strong>数据需要频繁更新</strong></li>
<li><strong>需要复杂关联查询</strong></li>
</ul>
<h2 id="六-图数据库"><a class="markdownIt-Anchor" href="#六-图数据库"></a> 六、图数据库</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015751.png" alt="img" /></p>
<p><strong>图形数据库应用图论存储实体之间的关系信息</strong>。最常见例子就是社会网络中人与人之间的关系。关系型数据库用于存储“关系型”数据的效果并不好，其查询复杂、缓慢、超出预期，而图形数据库的独特设计恰恰弥补了这个缺陷，解决关系型数据库存储和处理复杂关系型数据功能较弱的问题。</p>
<h3 id="图数据库产品"><a class="markdownIt-Anchor" href="#图数据库产品"></a> 图数据库产品</h3>
<ul>
<li>
<p>Neo4j</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015817.png" alt="img" /></p>
<p>Neo4j 是由 Neo4j，Inc。开发的图形数据库管理系统。由其开发人员描述为具有原生图存储和处理的符合 ACID 的事务数据库，根据 DB-Engines 排名， Neo4j 是最流行的图形数据库。</p>
</li>
<li>
<p>ArangoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015858.png" alt="img" /></p>
<p>ArangoDB 是由 triAGENS GmbH 开发的原生多模型数据库系统。数据库系统支持三个重要的数据模型（键/值，文档，图形），其中包含一个数据库核心和统一查询语言 AQL（ArangoDB 查询语言）。查询语言是声明性的，允许在单个查询中组合不同的数据访问模式。ArangoDB 是一个 NoSQL 数据库系统，但 AQL 在很多方面与 SQL 类似。</p>
</li>
<li>
<p>Titan</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015923.png" alt="img" /></p>
<p>Titan 是一个可扩展的图形数据库，针对存储和查询包含分布在多机群集中的数百亿个顶点和边缘的图形进行了优化。Titan 是一个事务性数据库，可以支持数千个并发用户实时执行复杂的图形遍历。</p>
</li>
</ul>
<h3 id="图数据库特性"><a class="markdownIt-Anchor" href="#图数据库特性"></a> 图数据库特性</h3>
<p>以 Neo4j 为例：</p>
<p>Neo4j 使用数据结构中图（graph）的概念来进行建模。 Neo4j 中两个最基本的概念是节点和边。节点表示实体，边则表示实体之间的关系。节点和边都可以有自己的属性。不同实体通过各种不同的关系关联起来，形成复杂的对象图。</p>
<p>针对关系数据，2 种 2 数据库的存储结构不同：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b2cebaf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="2种存储结构" /></p>
<p>Neo4j 中，存储节点时使用了”index-free adjacency”，即每个节点都有指向其邻居节点的指针，可以让我们在 O(1)的时间内找到邻居节点。另外，按照官方的说法，在 Neo4j 中边是最重要的,是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b3a0f7b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>如下优点：</p>
<ul>
<li><strong>高性能</strong> - 图的遍历是图数据结构所具有的独特算法，即从一个节点开始，根据其连接的关系，可以快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索</li>
<li><strong>设计的灵活性</strong> - 数据结构的自然伸展特性及其非结构化的数据格式，让图数据库设计可以具有很大的伸缩性和灵活性。因为随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用</li>
<li><strong>开发的敏捷性</strong> - 直观明了的数据模型，从需求的讨论开始，到程序开发和实现，以及最终保存在数据库中的样子，它的模样似乎没有什么变化，甚至可以说本来就是一模一样的</li>
<li><strong>完全支持 ACID</strong> - 不像别的 NoSQL 数据库 Neo4j 还具有完全事务管理特性，完全支持 ACID 事务管理</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>存在支持节点，关系和属性的数量的限制。</li>
<li>不支持拆分。</li>
</ul>
<h3 id="图数据库场景"><a class="markdownIt-Anchor" href="#图数据库场景"></a> 图数据库场景</h3>
<p>适用场景如下：</p>
<ul>
<li>关系性强的数据中，如社交网络</li>
<li>推荐引擎。如果我们将数据以图的形式表现，那么将会非常有益于推荐的制定</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li>记录大量基于事件的数据（例如日志条目或传感器数据）</li>
<li>对大规模分布式数据进行处理</li>
<li>保存在关系型数据库中的结构化数据</li>
<li>二进制数据存储</li>
</ul>
<h2 id="七-总结"><a class="markdownIt-Anchor" href="#七-总结"></a> 七、总结</h2>
<p>关系型数据库和 NoSQL 数据库的选型，往往需要考虑几个指标：</p>
<ul>
<li>数据量</li>
<li>并发量</li>
<li>实时性</li>
<li>一致性要求</li>
<li>读写分布和类型</li>
<li>安全性</li>
<li>运维成本</li>
</ul>
<p>常见软件系统数据库选型参考如下：</p>
<ul>
<li><strong>中后台管理型系统</strong> - 如运营系统，数据量少，并发量小，首选关系型数据库。</li>
<li><strong>大流量系统</strong> - 如电商单品页，后台考虑选关系型数据库，前台考虑选内存型数据库。</li>
<li><strong>日志型系统</strong> - 原始数据考虑选列式数据库，日志搜索考虑选搜索引擎。</li>
<li><strong>搜索型系统</strong> - 例如站内搜索，非通用搜索，如商品搜索，后台考虑选关系型数据库，前台考虑选搜索引擎。</li>
<li><strong>事务型系统</strong> - 如库存，交易，记账，考虑选关系型数据库+K-V 数据库（作为缓存）+分布式事务。</li>
<li><strong>离线计算</strong> - 如大量数据分析，考虑选列式数据库或关系型数据。</li>
<li><strong>实时计算</strong> - 如实时监控，可以考虑选内存型数据库或者列式数据库。</li>
</ul>
<p>设计实践中，要基于需求、业务驱动架构，无论选用 RDB/NoSQL/DRDB,<strong>一定是以需求为导向，最终数据存储方案必然是各种权衡的综合性设计</strong></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d62ddf265da0f491bd200">NoSQL 还是 SQL ？这一篇讲清楚</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jimmy"
      src="/images/avatar2.gif">
  <p class="site-author-name" itemprop="name">Jimmy</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ichunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ichunhui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hustzch@163.com" title="E-Mail → mailto:hustzch@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备17019300号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jimmy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jimmyblog-2.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
