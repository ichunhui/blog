<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ichunhui.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不忘初心，方得始终.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy&#39;s Blog">
<meta property="og:url" content="https://ichunhui.github.io/page/4/index.html">
<meta property="og:site_name" content="Jimmy&#39;s Blog">
<meta property="og:description" content="不忘初心，方得始终.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jimmy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ichunhui.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jimmy's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Jimmy's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jimmy's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">靡不有初，鲜克有终.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">192</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">114</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">41</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/ichunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/2fb7319c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2fb7319c.html" class="post-title-link" itemprop="url">OAuth 2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2fb7319c.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2fb7319c.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="oauth-20"><a class="markdownIt-Anchor" href="#oauth-20"></a> OAuth 2.0</h1>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。</p>
</blockquote>
<p>简单来说，<strong>OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p>OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li><strong>授权码模式（authorization code）</strong></li>
<li><strong>简化模式（implicit）</strong></li>
<li><strong>密码模式（resource owner password credentials）</strong></li>
<li><strong>客户端模式（client credentials）</strong></li>
</ul>
<h2 id="授权码模式"><a class="markdownIt-Anchor" href="#授权码模式"></a> 授权码模式</h2>
<p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<h2 id="隐藏模式"><a class="markdownIt-Anchor" href="#隐藏模式"></a> 隐藏模式</h2>
<p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）“隐藏式”（implicit）。</strong></p>
<h2 id="密码模式"><a class="markdownIt-Anchor" href="#密码模式"></a> 密码模式</h2>
<p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。</strong></p>
<h2 id="客户端凭证模式"><a class="markdownIt-Anchor" href="#客户端凭证模式"></a> 客户端凭证模式</h2>
<p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h2 id="令牌的使用"><a class="markdownIt-Anchor" href="#令牌的使用"></a> 令牌的使用</h2>
<h2 id="令牌的更新"><a class="markdownIt-Anchor" href="#令牌的更新"></a> 令牌的更新</h2>
<p>如果用户访问的时候，客户端的&quot;访问令牌&quot;已经过期，则需要使用&quot;更新令牌&quot;申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为&quot;refresh</em>token&quot;，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.rfcreader.com/#rfc6749">RFC 6749</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0</a></li>
<li><a target="_blank" rel="noopener" href="https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb">The Simplest Guide To OAuth 2.0</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/c93d0ed2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/c93d0ed2.html" class="post-title-link" itemprop="url">《数据密集型应用系统设计》之分布式数据系统笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 23:32:00" itemprop="dateCreated datePublished" datetime="2021-08-26T23:32:00+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/c93d0ed2.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="c93d0ed2.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据密集型应用系统设计之分布式数据系统笔记"><a class="markdownIt-Anchor" href="#数据密集型应用系统设计之分布式数据系统笔记"></a> 《数据密集型应用系统设计》之分布式数据系统笔记</h1>
<p>出于以下目的，我们需要在多台机器上分布数据：</p>
<ul>
<li>扩展性：当数据量或者读写负载巨大，严重超出了单台机器的处理上限，需要将负载分散到多台机器上。</li>
<li>容错与高可用性：当单台机器（或者多台，以及网络甚至整个数据中心）出现故障，还希望应用系统可以继续工作，这时需要采用多台机器提供冗余。这样某些组件失效之后，冗余组件可以迅速接管。</li>
<li>延迟考虑：如果客户遍布世界各地，通常需要考虑在全球范围内部署服务，以方便用户就近访问最近数据中心所提供的服务，从而避免数据请求跨越了半个地球才能到达目标。</li>
</ul>
<p>将数据分布在多节点时有两种常见的方式：</p>
<ul>
<li><strong>复制</strong>：在多个节点上保存相同数据的副本，每个副本具体的存储位置可能不尽相同。复制方住可以提供冗余</li>
<li><strong>分区</strong>：将一个大块头的数据库拆分成多个较小的子集即分区，不同的分区分配给不同的节点（也称为分片）。我们在第 6 章主要介绍分区技术。</li>
</ul>
<h2 id="1-单主节点数据复制"><a class="markdownIt-Anchor" href="#1-单主节点数据复制"></a> 1. 单主节点数据复制</h2>
<p>复制主要指通过网络在多台机器上保存相同数据的副本。</p>
<p>数据复制的作用：</p>
<ul>
<li>使数据在地理位置上更接近用户，从而<strong>降低访问延迟</strong>。</li>
<li>当部分组件出现位障，系统依然可以继续工作，从而<strong>提高可用性</strong>。</li>
<li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong>。</li>
</ul>
<p>复制方式：</p>
<ul>
<li>主从复制</li>
<li>多主节点复制</li>
<li>无主节点复制</li>
</ul>
<p>复制需要考虑的问题：</p>
<ul>
<li>同步还是异步</li>
<li>如何处理失败的副本</li>
<li>如何保证数据一致</li>
</ul>
<h3 id="11-主节点与从节点"><a class="markdownIt-Anchor" href="#11-主节点与从节点"></a> 1.1. 主节点与从节点</h3>
<p>每个保存数据库完整数据集的节点称之为副本。有了多副本，必然会面临一个问题：如何确保所有副本之间的数据是一致的？</p>
<p>主从复制的工作原理如下：</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求：从客户端的角度来看，从副本都是只读的。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302202101.png" alt="img" /></p>
<p>典型应用：</p>
<ul>
<li>数据库：MySql、MongoDB 等</li>
<li>消息队列：Kafka、RabbitMQ 等</li>
</ul>
<h3 id="12-同步复制与异步复制"><a class="markdownIt-Anchor" href="#12-同步复制与异步复制"></a> 1.2. 同步复制与异步复制</h3>
<p>基本流程是，客户将更新请求发送给主节点，主节点接收到请求，接下来将数据更新转发给从节点。最后，由<br />
主节点来通知客户更新完成。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302202158.png" alt="img" /></p>
<p>通常情况下， 复制速度会非常快，例如多数数据库系统可以在一秒之内完成所有从节点的更新。但是，系统其<br />
实并没有保证一定会在多段时间内完成复制。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如，由于从节点刚从故障中恢复，或者系统已经接近最大设计上限，或者节点之间的网络出现问题。</p>
<ul>
<li><strong>同步复制的优点</strong>： 一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</li>
<li><strong>同步复制的缺点</strong>：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因）， 写入就不能视为成功。主节点会阻塞其后所有的写操作，直到同步副本确认完成。</li>
</ul>
<p>因此，把所有从节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。</p>
<p>实际应用中，很多数据库推荐的模式是：只要有一个从节点或半数以上的从节点同步成功，就视为同步，直接返回结果；剩下的节点都通过异步方式同步。</p>
<ul>
<li><strong>异步复制的优点</strong>：不管从节点上数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好。</li>
<li><strong>异步复制的缺点</strong>：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。</li>
</ul>
<p>主从复制还经常会被配置为全异步模式。此时如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写操作， 却无法保证数据的持久化。</p>
<h3 id="13-配置新的从节点"><a class="markdownIt-Anchor" href="#13-配置新的从节点"></a> 1.3. 配置新的从节点</h3>
<p>配置新的从节点的主要操作步骤：</p>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具， 如 MySQL 的 innobackupex。</li>
<li>将此快照拷贝到新的从节点。</li>
<li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称呼，如 PostgreSQL 将其称为“ log sequence number” （日志序列号），而 MySQL 将其称为“ binlog coordinates ” 。</li>
<li>获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化。井重复步骤 1 ～步骤 4 。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异。</p>
<h3 id="14-处理节点失效"><a class="markdownIt-Anchor" href="#14-处理节点失效"></a> 1.4. 处理节点失效</h3>
<p>如何通过主从复制技术来实现系统高可用呢？</p>
<h4 id="从节点失效-追赶式恢复"><a class="markdownIt-Anchor" href="#从节点失效-追赶式恢复"></a> 从节点失效： 追赶式恢复</h4>
<p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点发生崩溃，然后顺利重启，或者主从节点之间的网络发生暂时中断（闪断），则恢复比较容易，根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p>
<h4 id="主节点失效节点切换"><a class="markdownIt-Anchor" href="#主节点失效节点切换"></a> 主节点失效：节点切换</h4>
<p>选择某个从节点将其提升为主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这一过程称之为切换。</p>
<p>步骤通常如下：</p>
<ol>
<li><strong>确认主节点失效</strong>。有很多种出错可能性，所以大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳悄息，如果发现某一个节点在一段比较长时间内（例如 30s ）没有响应，即认为该节点发生失效。</li>
<li><strong>选举新的主节点</strong>。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。让所有节点同意新的主节点是个典型的共识问题。</li>
<li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</li>
</ol>
<p>上述切换过程依然充满了很多变数：</p>
<ul>
<li>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作会发生什么？新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</li>
<li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。例如，在 GitHub 的一个事故中，某个数据并非完全同步的 MySQL 从节点被提升为主副本，数据库使用了自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（ 即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部 Redis 所引用，结果出现 MySQL 和 Redis 之间的不一致，最后导致了某些私有数据被错误地泄露给了其他用户。</li>
<li>在某些故障情况下，可能会发生两个节点同时－都自认为是主节点。这种情况被称为<strong>脑裂</strong>，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法，最后数据可能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。然而，如果设计或者实现考虑不周，可能会出现两个节点都被关闭的情况。</li>
<li>如何设置合适的超时来检测主节点失效呢？ 主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。但如果超时设置太短，可能会导致很多不必要的切换。例如，突发的负载峰值会导致节点的响应时间变长甚至超肘，或者由于网络故障导致延迟增加。如果系统此时已经处于高负载压力或网络已经出现严重拥塞，不必要的切换操作只会使总体情况变得更糟。</li>
</ul>
<h3 id="15-复制日志的实现"><a class="markdownIt-Anchor" href="#15-复制日志的实现"></a> 1.5. 复制日志的实现</h3>
<h4 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h4>
<p>最简单的情况，主节点记录所执行的每个写请求（操作语句）井将该操作语句作为日志发送给从节点。对于关系数据库，这意味着每个 INSERT 、UPDATE 或 DELETE 语句都会转发给从节点，并且每个从节点都会分析井执行这些 SQU 吾句，如同它们是来自客户端那样。</p>
<p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p>
<ul>
<li>任何调用非确定性函数的语句，如 <code>NOW()</code> 获取当前时间，或 <code>RAND()</code> 获取一个随机数等，可能会在不同的副本上产生不同的值。</li>
<li>如果语句中使用了自增列，或者依赖于数据库的现有数据（例如， <code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行的事务时， 会有很大的限制。</li>
<li>有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用。</li>
</ul>
<p>有可能采取一些特殊措施来解决这些问题，例如，主节点可以在记录操作语句时将非确定性函数替换为执行之后的确定的结果，这样所有节点直接使用相同的结果值。但是，这里面存在太多边界条件需要考虑，因此目前通常首选的是其他复制实现方案。</p>
<p>MySQL 5.1 版本之前采用基于操作语句的复制。现在由于逻辑紧凑，依然在用，但是默认情况下，如果语句中存在一些不确定性操作，则 MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用基于语句的复制，它通过事务级别的确定性来保证复制的安全。</p>
<h4 id="基于预写日志wal传输"><a class="markdownIt-Anchor" href="#基于预写日志wal传输"></a> 基于预写日志（WAL）传输</h4>
<p>通常每个写操作都是以追加写的方式写入到日志中：</p>
<ul>
<li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li>
<li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩溃，通过索引更新的方式迅速恢复到此前一致状态。</li>
</ul>
<p>不管哪种情况，所有对数据库写入的字节序列都被记入日志。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外， 主节点还可以通过网络将其发送给从节点。</p>
<p>PostgreSQL 、Oracle 以及其他系统等支持这种复制方式。其主要缺点是日志描述的数据结果非常底层： 一个 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密搞合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无能支持主从节点上运行不同版本的软件。</p>
<h4 id="基于行的逻辑日志复制"><a class="markdownIt-Anchor" href="#基于行的逻辑日志复制"></a> 基于行的逻辑日志复制</h4>
<p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值。</li>
<li>对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。</li>
<li>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。</li>
</ul>
<p>如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。MySQL 的二进制日志 binlog （当配置为基于行的复制时）使用该方式。</p>
<p>由于逻辑日志与存储引擎逻辑解耦，因此可以更容易地保持向后兼容，从而使主从节点能够运行不同版本的软件甚至是不同的存储引擎。</p>
<p>对于外部应用程序来说，逻辑日志格式也更容易解析。</p>
<h4 id="基于触发器的复制"><a class="markdownIt-Anchor" href="#基于触发器的复制"></a> 基于触发器的复制</h4>
<p>在某些情况下，我们可能需要更高的灵活性。例如，只想复制数据的一部分，或者想从一种数据库复制到另一种数据库，或者需要订制、管理冲突解决逻辑（ 参阅本章后面的“处理写冲突”），则需要将复制控制交给应用程序层。</p>
<p>有一些工具，可以通过读取数据库日志让应用程序获取数据变更。另一种方法则是借助许多关系数据库都支持的功能：触发器和存储过程。</p>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。Oracle 的 Databus 和 Postgres 的 Bucardo 就是这种技术的典型代表。基于触发器的复制通常比其他复制方式开销更高， 也比数据库内置复制更容易出错，或者暴露一些限制。然而，其高度灵活性仍有用武之地。</p>
<h3 id="16-复制滞后问题"><a class="markdownIt-Anchor" href="#16-复制滞后问题"></a> 1.6. 复制滞后问题</h3>
<p>主从复制要求所有写请求都经由主节点，而任何副本只能接受只读查询。对于读操作密集的负载（如 Web ），这是一个不错的选择：创建多个从副本，将读请求分发给这些从副本，从而减轻主节点负载井允许读取请求就近满足。</p>
<p>在这种扩展体系下，只需添加更多的从副本，就可以提高读请求的服务吞吐量。但是，这种方法实际上只能用于异步复制，如果试图同步复制所有的从副本，则单个节点故障或网络中断将使整个系统无法写入。而且节点越多，发生故障的概率越高，所以完全同步的配置现实中反而非常不可靠。</p>
<p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点，则应用可能会读到过期的信息。这会导致数据库中出现明显的不一致：由于并非所有的写入都反映在从副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的结果。经过一段时间之后，从节点最终会赶上并与主节点数据保持一致。这种效应也被称为最终一致性。</p>
<h4 id="读自己的写"><a class="markdownIt-Anchor" href="#读自己的写"></a> 读自己的写</h4>
<p>许多应用让用户提交一些数据，接下来查看他们自己所提交的内容。例如客户数据库中的记录，亦或者是讨论主题的评论等。提交新数据须发送到主节点，但是当用户读取数据时，数据可能来自从节点。这对于读密集和偶尔写入的负载是个非常合适的方案。</p>
<p>然而对于异步复制存在这样一个问题，如图 5-3 所示，用户在写人不久即查看数据，则新数据可能尚未到达从节点。对用户来讲， 看起来似乎是刚刚提交的数据丢失了，显然用户不会高兴。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302204836.png" alt="img" /></p>
<p>对于这种情况，我们需要强一致性。如何实现呢？有以下方案：</p>
<ul>
<li>如果用户访问可能会被修改的内容，从主节点读取； 否则，在从节点读取。这背后就要求有一些方法在实际执行查询之前，就已经知道内容是否可能会被修改。例如，社交网络上的用户首页信息通常只能由所有者编辑，而其他人无法编辑。因此，这就形成一个简单的规则： 总是从主节点读取用户自己的首页配置文件，而在从节点读取其他用户的配置文件。</li>
<li>如果应用的大部分内容都可能被所有用户修改，那么上述方法将不太有效，它会导致大部分内容都必须经由主节点，这就丧失了读操作的扩展性。此时需要其他方案来判断是否从主节点读取。例如，跟踪最近更新的时间，如果更新后一分钟之内，则总是在主节点读取；井监控从节点的复制滞后程度，避免从那些滞后时间超过一分钟的从节点读取。</li>
<li>客户端还可以记住最近更新时的时间戳，井附带在读请求中，据此信息，系统可以确保对该用户提供读服务时都应该至少包含了该时间戳的更新。如果不够新，要么交由另一个副本来处理，要么等待直到副本接收到了最近的更新。时间戳可以是逻辑时间戳（例如用来指示写入顺序的日志序列号）或实际系统时钟（在这<br />
种情况下，时钟同步又称为一个关键点， 请参阅第 8 章“不可靠的时钟”）。</li>
<li>如果副本分布在多数据中心（例如考虑与用户的地理接近，以及高可用性），情况会更复杂些。必须先把请求路由到主节点所在的数据中心（该数据中心可能离用户很远）。</li>
</ul>
<p>如果同一用户可能会从多个设备访问数据，情况会更加复杂。</p>
<ul>
<li>记住用户上次更新时间戳的方法实现起来会比较困难，因为在一台设备上运行的代码完全无法知道在其他设备上发生了什么。此时，元数据必须做到全局共享。</li>
<li>如果副本分布在多数据中心，无法保证来自不同设备的连接经过路由之后都到达同一个数据中心。例如，用户的台式计算机使用了家庭宽带连接，而移动设备则使用蜂窝数据网络，不同设备的网络连接线路可能完全不同。如果方案要求必须从主节点读取，则首先需要想办毡确保将来自不同设备的请求路由到同一个数据中心。</li>
</ul>
<h4 id="单调读"><a class="markdownIt-Anchor" href="#单调读"></a> 单调读</h4>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303093658.png" alt="img" /></p>
<p>用户看到了最新内窑之后又读到了过期的内容，好像时间被回拨， 此时需要单调读一致性。</p>
<p>单调读一致性可以确保不会发生这种异常。这是一个比强一致性弱，但比最终一致性强的保证。当读取数据时，单调读保证，如果某个用户依次进行多次读取，则他绝不会看到回攘现象，即在读取较新值之后又发生读旧值的情况。</p>
<p>实现单调读的一种方式是，确保每个用户总是从固定的同一副本执行读取（而不同的用户可以从不同的副本读取）。</p>
<h4 id="前缀一致读"><a class="markdownIt-Anchor" href="#前缀一致读"></a> 前缀一致读</h4>
<p>前缀一致读：对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序。</p>
<p>如果数据库总是以相同的顺序写入，则读取总是看到一致的序列，不会发生这种反常。然而，在许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序。这就导致当用户从数据库中读数据时，可能会看到数据库的某部分旧值和另一部分新值。</p>
<h2 id="2-多主节点复制"><a class="markdownIt-Anchor" href="#2-多主节点复制"></a> 2. 多主节点复制</h2>
<p>主从复制存在一个明显的缺点：系统只有一个主节点，而所有写人都必须经由主节点。主从复制方案就会影响所有的写入操作。</p>
<h3 id="21-适用场景"><a class="markdownIt-Anchor" href="#21-适用场景"></a> 2.1. 适用场景</h3>
<p>在一个数据中心内部使用多主节点基本没有太大意义，其复杂性已经超过所能带来的好处。</p>
<p>以下场景这种配置则是合理的：</p>
<ul>
<li>多数据中心</li>
<li>离线客户端操作</li>
<li>协作编辑</li>
</ul>
<h4 id="多数据中心"><a class="markdownIt-Anchor" href="#多数据中心"></a> 多数据中心</h4>
<p>部署单主节点的主从复制方案与多主复制方案之间的差异</p>
<ul>
<li><strong>性能</strong>：对于主从复制，每个写请求都必须经由广域网传送至主节点所在的数据中心。这会大大增加写入延迟，井基本偏离了采用多数据中心的初衷（即就近访问）。而在多主节点模型中，每个写操作都可以在本地数据中心快速响应，然后采用异步复制方式将变化同步到其他数据中心。因此，对上层应用有效屏蔽了数据中心之间的网络延迟，使得终端用户所体验到的性能更好。</li>
<li><strong>容忍数据中心失效</strong>：对于主从复制，如果主节点所在的数据中心发生故障，必须切换至另一个数据中心，将其中的一个从节点被提升为主节点。在多主节点模型中，每个数据中心则可以独立于其他数据中心继续运行，发生故障的数据中心在恢复之后更新到最新状态。</li>
<li><strong>容忍网络问题</strong>：数据中心之间的通信通常经由广域网，它往往不如数据中心内的本地网络可靠。对于主从复制模型，由于写请求是同步操作，对数据中心之间的网络性能和稳定性等更加依赖。多主节点模型则通常采用异步复制，可以更好地容忍此类问题，例如临时网络闪断不会妨碍写请求最终成功。</li>
</ul>
<h3 id="22-处理写冲突"><a class="markdownIt-Anchor" href="#22-处理写冲突"></a> 2.2. 处理写冲突</h3>
<p>多主复制的最大问题是可能发生写冲突。</p>
<h4 id="同步与异步冲突检测"><a class="markdownIt-Anchor" href="#同步与异步冲突检测"></a> 同步与异步冲突检测</h4>
<p>理论上， 也可以做到同步冲突检测，即等待写请求完成对所有副本的同步，然后再通知用户写入成功。但是，这样做将会失去多主节点的主要优势：允许每个主节点独立接受写请求。如果确实想要同步方式冲突检测，或许应该考虑采用单主节点的主从复制模型。</p>
<h4 id="避免冲突"><a class="markdownIt-Anchor" href="#避免冲突"></a> 避免冲突</h4>
<p>处理冲突最理想的策略是避免发生冲突，即如果应用层可以保证对特定记录的写请求总是通过同一个主节点，这样就不会发生写冲突。现实中，由于不少多主节点复制模型所实现的冲突解决方案存在瑕疵，因此，避免冲突反而成为大家普遍推荐的首选方案。</p>
<p>但是，有时可能需要改变事先指定的主节点，例如由于该数据中心发生故障，不得不将流量重新路由到其他数据中心，或者是因为用户已经漫游到另一个位置，因而更靠近新数据中心。此时，冲突避免方式不再有效，必须有措施来处理同时写入冲突的可能性。</p>
<h4 id="收敛于一致状态"><a class="markdownIt-Anchor" href="#收敛于一致状态"></a> 收敛于一致状态</h4>
<p>对干主从复制模型，数据更新符合顺序性原则，即如果同一个字段有多个更新，则最后一个写操作将决定该字段的最终值。</p>
<p>对于多主节点复制模型，由于不存在这样的写入顺序，所以最终值也会变得不确定。</p>
<p>实现收敛的冲突解决有以下可能的方式：</p>
<ul>
<li>给每个写入分配唯一的 ID ，例如， 一个时间戳， 二个足够长的随机数， 一个 UUID 或者一个基于键－值的 Jl 合希，挑选最高 ID 的写入作为胜利者，并将其他写入丢弃。如果基于时间戳，这种技术被称为最后写入者获胜。虽然这种方陆很流行，但是很容易造成数据丢失。</li>
<li>为每个副本分配一个唯一的 ID ，井制定规则，例如序号高的副本写入始终优先于序号低的副本。这种方法也可能会导致数据丢失。</li>
<li>以某种方式将这些值合并在一起。例如，按字母顺序排序，然后拼接在一起</li>
<li>利用预定义好的格式来记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突（可能会提示用户） 。</li>
</ul>
<h4 id="自定义冲突解决逻辑"><a class="markdownIt-Anchor" href="#自定义冲突解决逻辑"></a> 自定义冲突解决逻辑</h4>
<p>解决冲突最合适的方式可能还是依靠应用层，所以大多数多主节点复制模型都有工具来让用户编写应用代码来解决冲突。可以在写入时或在读取时执行这些代码逻辑：</p>
<ul>
<li>在写入时执行：只要数据库系统在复制变更日志时检测到冲突，就会调用应用层的冲突处理程序。</li>
<li>在读取时执行：当检测到冲突时，所有冲突写入值都会暂时保存下来。下一次读取数据时，会将数据的多个版本读返回给应用层。应用层可能会提示用户或自动解决冲突， 井将最后的结果返回到数据库。</li>
</ul>
<h2 id="3-无主节点复制"><a class="markdownIt-Anchor" href="#3-无主节点复制"></a> 3. 无主节点复制</h2>
<p>客户端将写请求发送到多个节点上，读取时从多个节点上并行读取，以此检测和纠正某些过期数据。</p>
<h2 id="4-数据分区"><a class="markdownIt-Anchor" href="#4-数据分区"></a> 4. 数据分区</h2>
<blockquote>
<p>在不同系统中，分区有着不同的称呼，例如它对应于 MongoDB, Elasticsearch 和 SolrCloud 中的 shard, HBase 的 region, Bigtable 中的<br />
tablet, Cassandra 和 Riak 中的 vnode ，以及 Couch base 中的 vBucket。总体而言，分区是最普遍的术语。</p>
</blockquote>
<p>采用数据分区的主要目的是提高可扩展性。不同的分区可以放在不同的节点上，这样一个大数据集可以分散在更多的磁盘上，查询负载也随之分布到更多的处理器上。</p>
<p>对单个分区进行查询时，每个节点对自己所在分区可以独立执行查询操作，因此添加更多的节点可以提高查询吞吐量。超大而复杂的查询尽管比较困难，但也可能做到跨节点的并行处理。</p>
<h3 id="41-数据分区与数据复制"><a class="markdownIt-Anchor" href="#41-数据分区与数据复制"></a> 4.1. 数据分区与数据复制</h3>
<p>分区通常与复制结合使用，即每个分区在多个节点都存有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。</p>
<p>一个节点上可能存储了多个分区。每个分区都有自己的主副本，例如被分配给某节点，而从副本则分配在其他一些节点。一个节点可能即是某些分区的主副本，同时又是其他分区的从副本。</p>
<h3 id="42-键-值数据的分区"><a class="markdownIt-Anchor" href="#42-键-值数据的分区"></a> 4.2. 键－值数据的分区</h3>
<p>分区的主要目标是将数据和查询负载均匀分布在所有节点上。如果节点平均分担负载，那么理论上 10 个节点应该能够处理 10 倍的数据量和 10 倍于单个节点的读写吞吐量（忽略复制） 。</p>
<p>而如果分区不均匀，则会出现某些分区节点比其他分区承担更多的数据量或查询负载，称之为倾斜。倾斜会导致分区效率严重下降，在极端情况下，所有的负载可能会集中在一个分区节点上，这就意味着 10 个节点 9 个空闲，系统的瓶颈在最繁忙的那个节点上。这种负载严重不成比例的分区即成为系统热点。</p>
<h4 id="基于关键字区间分区"><a class="markdownIt-Anchor" href="#基于关键字区间分区"></a> 基于关键字区间分区</h4>
<p>一种分区方式是为每个分区分配一段连续的关键字或者关键宇区间范围（以最小值和最大值来指示）。</p>
<p>关键字的区间段不一定非要均匀分布，这主要是因为数据本身可能就不均匀。</p>
<p>每个分区内可以按照关键字排序保存（参阅第 3 章的“ SSTables 和 LSM Trees ”）。这样可以轻松支持区间查询，即将关键字作为一个拼接起来的索引项从而一次查询得到多个相关记录。</p>
<p>然而，基于关键字的区间分区的缺点是某些访问模式会导致热点。如果关键字是时间戳，则分区对应于一个时间范围，所有的写入操作都集中在同一个分区（即当天的分区），这会导致该分区在写入时负载过高，而其他分区始终处于空闲状态。为了避免上述问题，需要使用时间戳以外的其他内容作为关键字的第一项。</p>
<h4 id="基于关键字晗希值分区"><a class="markdownIt-Anchor" href="#基于关键字晗希值分区"></a> 基于关键字晗希值分区</h4>
<p>一且找到合适的关键宇 H 合希函数，就可以为每个分区分配一个哈希范围（而不是直接作用于关键宇范围），关键字根据其哈希值的范围划分到不同的分区中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303105925.png" alt="img" /></p>
<p>这种方总可以很好地将关键字均匀地分配到多个分区中。分区边界可以是均匀间隔，也可以是伪随机选择（ 在这种情况下，该技术有时被称为一致性哈希） 。</p>
<p>然而，通过关键宇 II 合希进行分区，我们丧失了良好的区间查询特性。即使关键字相邻，但经过哈希之后会分散在不同的分区中，区间查询就失去了原有的有序相邻的特性。</p>
<h4 id="负载倾斜与热点"><a class="markdownIt-Anchor" href="#负载倾斜与热点"></a> 负载倾斜与热点</h4>
<p>基于哈希的分区方能可以减轻热点，但无住做到完全避免。一个极端情况是，所有的读／写操作都是针对同一个关键字，则最终所有请求都将被路由到同一个分区。</p>
<p>一个简单的技术就是在关键字的开头或结尾处添加一个随机数。只需一个两位数的十进制随机数就可以将关键字的写操作分布到 100 个不同的关键字上，从而分配到不同的分区上。但是，随之而来的问题是，之后的任何读取都需要些额外的工作，必须从所有 100 个关键字中读取数据然后进行合井。因此通常只对少量的热点关键字附加随机数才有意义。</p>
<h3 id="43-分区与二级索引"><a class="markdownIt-Anchor" href="#43-分区与二级索引"></a> 4.3. 分区与二级索引</h3>
<p>二级索引通常不能唯一标识一条记录，而是用来加速特定值的查询。</p>
<p>二级索引带来的主要挑战是它们不能规整的地映射到分区中。有两种主要的方法来支持对二级索引进行分区：基于文档的分区和基于词条的分区。</p>
<h4 id="基于文档分区的二级索引"><a class="markdownIt-Anchor" href="#基于文档分区的二级索引"></a> 基于文档分区的二级索引</h4>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303111528.png" alt="img" /></p>
<p>在这种索引方法中，每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档而不关心其他分区中数据。每当需要写数据库时，包括添加，删除或更新文档等，只需要处理包含目标文档 ID 的那一个分区。因此文档分区索引也被称为本地索引，而不是全局索引。</p>
<p>这种查询分区数据库的方陆有时也称为分散／聚集，显然这种二级索引的查询代价高昂。即使采用了并行查询，也容易导致读延迟显著放大。尽管如此，它还是广泛用于实践： MongoDB 、Riak、Cassandra、Elasticsearch 、SolrCloud 和 VoltDB 都支持基于文档分区二级索引。</p>
<h4 id="基于词条的二级索引分区"><a class="markdownIt-Anchor" href="#基于词条的二级索引分区"></a> 基于词条的二级索引分区</h4>
<p>可以对所有的数据构建全局索引，而不是每个分区维护自己的本地索引。</p>
<p>为避免成为瓶颈，不能将全局索引存储在一个节点上，否则就破坏了设计分区均衡的目标。所以，全局索引也必须进行分区，且可以与数据关键字采用不同的分区策略。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303112708.png" alt="img" /></p>
<p>可以直接通过关键词来全局划分索引，或者对其取哈希值。直接分区的好处是可以支持高效的区间查询；而采用哈希的方式则可以更均句的划分分区。</p>
<p>这种全局的词条分区相比于文档分区索引的主要优点是，它的读取更为高效，即它不需要采用 scatter/gather 对所有的分区都执行一遍查询。</p>
<p>然而全局索引的不利之处在于， 写入速度较慢且非常复杂，主要因为单个文档的更新时，里面可能会涉及多个二级索引，而二级索引的分区又可能完全不同甚至在不同的节点上，由此势必引人显著的写放大。</p>
<p>理想情况下，索引应该时刻保持最新，即写入的数据要立即反映在最新的索引上。但是，对于词条分区来讲，这需要一个跨多个相关分区的分布式事务支持，写入速度会受到极大的影响，所以现有的数据库都不支持同步更新二级索引。</p>
<h3 id="44-分区再均衡"><a class="markdownIt-Anchor" href="#44-分区再均衡"></a> 4.4. 分区再均衡</h3>
<p>随着时间的推移，数据库可能总会出现某些变化：</p>
<ul>
<li>查询压力增加，因此需要更多的 C PU 来处理负载。</li>
<li>数据规模增加，因此需要更多的磁盘和内存来存储数据。</li>
<li>节点可能出现故障，因此需要其他机器来接管失效的节点。</li>
</ul>
<p>所有这些变化都要求数据和请求可以从一个节点转移到另一个节点。这样一个迁移负载的过程称为再平衡（或者动态平衡）。无论对于哪种分区方案， 分区再平衡通常至少要满足：</p>
<ul>
<li>平衡之后，负载、数据存储、读写请求等应该在集群范围更均匀地分布。</li>
<li>再平衡执行过程中，数据库应该可以继续正常提供读写服务。</li>
<li>避免不必要的负载迁移，以加快动态再平衡，井尽量减少网络和磁盘 I/O 影响。</li>
</ul>
<h4 id="动态再平衡的策略"><a class="markdownIt-Anchor" href="#动态再平衡的策略"></a> 动态再平衡的策略</h4>
<h5 id="为什么不用取模"><a class="markdownIt-Anchor" href="#为什么不用取模"></a> 为什么不用取模？</h5>
<p>最好将哈希值划分为不同的区间范围，然后将每个区间分配给一个分区。</p>
<p>为什么不直接使用 mod，对节点数取模方怯的问题是，如果节点数 N 发生了变化，会导致很多关键字需要从现有的节点迁移到另一个节点。</p>
<h5 id="固定数量的分区"><a class="markdownIt-Anchor" href="#固定数量的分区"></a> 固定数量的分区</h5>
<p>创建远超实际节点数的分区数，然后为每个节点分配多个分区。</p>
<p>接下来， 如果集群中添加了一个新节点，该新节点可以从每个现有的节点上匀走几个分区，直到分区再次达到全局平衡。</p>
<h5 id="动态分区"><a class="markdownIt-Anchor" href="#动态分区"></a> 动态分区</h5>
<p>对于采用关键宇区间分区的数据库，如果边界设置有问题，最终可能会出现所有数据都挤在一个分区而其他分区基本为空，那么设定固定边界、固定数量的分区将非常不便：而手动去重新配置分区边界又非常繁琐。</p>
<p>因此， 一些数据库如 HBas e 和 RethinkDB 等采用了动态创建分区。当分区的数据增长超过一个可配的参数阔值（ HBase 上默认值是 lOGB ），它就拆分为两个分区，每个承担一半的数据量［26］。相反，如果大量数据被删除，并且分区缩小到某个阑值以下，则将其与相邻分区进行合井。</p>
<p>每个分区总是分配给一个节点，而每个节点可以承载多个分区，这点与固定数量的分区一样。当一个大的分区发生分裂之后，可以将其中的一半转移到其他某节点以平衡负载。</p>
<p>但是，需要注意的是，对于一个空的数据库， 因为没有任何先验知识可以帮助确定分区的边界，所以会从一个分区开始。可能数据集很小，但直到达到第一个分裂点之前，所有的写入操作都必须由单个节点来处理， 而其他节点则处于空闲状态。</p>
<h5 id="按节点比例分区"><a class="markdownIt-Anchor" href="#按节点比例分区"></a> 按节点比例分区</h5>
<p>采用动态分区策略，拆分和合并操作使每个分区的大小维持在设定的最小值和最大值之间，因此分区的数量与数据集的大小成正比关系。另一方面，对于固定数量的分区方式，其每个分区的大小也与数据集的大小成正比。两种情况，分区的数量都与节点数无关。</p>
<p>Cassandra 和 Ketama 则采用了第三种方式，使分区数与集群节点数成正比关系。换句话说，每个节点具有固定数量的分区。此时， 当节点数不变时，每个分区的大小与数据集大小保持正比的增长关系； 当节点数增加时，分区则会调整变得更小。较大的数据量通常需要大量的节点来存储，因此这种方陆也使每个分区大小保持稳定。当一个</p>
<p>新节点加入集群时，它随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一半数据量，将另一半数据留在原节点。随机选择分区边界的前提要求采用基于哈希分区（可以从哈希函数产生的数字范围里设置边界）</p>
<h4 id="自动与手动再平衡操作"><a class="markdownIt-Anchor" href="#自动与手动再平衡操作"></a> 自动与手动再平衡操作</h4>
<p>全自动式再平衡会更加方便，它在正常维护之外所增加的操作很少。但是，也有可能出现结果难以预测的情况。再平衡总体讲是个比较昂贵的操作，它需要重新路由请求井将大量数据从一个节点迁移到另一个节点。万一执行过程中间出现异常，会使网络或节点的负载过重，井影响其他请求的性能。</p>
<p>将自动平衡与自动故障检测相结合也可能存在一些风险。例如，假设某个节点负载过重，对请求的响应暂时受到影响，而其他节点可能会得到结论：该节点已经失效；接下来激活自动平衡来转移其负载。客观上这会加重该节点、其他节点以及网络的负荷，可能会使总体情况变得更槽，甚至导致级联式的失效扩散。</p>
<h3 id="45-请求路由"><a class="markdownIt-Anchor" href="#45-请求路由"></a> 4.5. 请求路由</h3>
<p>处理策略</p>
<ol>
<li>允许客户端链接任意的节点（例如，采用循环式的负载均衡器）。如果某节点恰好拥有所请求的分区，贝 lj 直接处理该请求：否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。</li>
<li>将所有客户端的请求都发送到一个路由层，由后者负责将请求转发到对应的分区节点上。路由层本身不处理任何请求，它仅充一个分区感知的负载均衡器。</li>
<li>客户端感知分区和节点分配关系。此时，客户端可以直接连接到目标节点，而不需要任何中介。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220304120137.png" alt="img" /></p>
<p>许多分布式数据系统依靠独立的协调服务（如 ZooKeeper ）跟踪集群范围内的元数据。每个节点都向 ZooKeeper 中注册自己， ZooKeeper 维护了分区到节点的最终映射关系。其他参与者（如路由层或分区感知的客户端）可以向 ZooKeeper 订阅此信息。一旦分区发生了改变，或者添加、删除节点， ZooKeeper 就会主动通知路由层，这样使路由信息保持最新状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220304163629.png" alt="img" /></p>
<h2 id="5-事务"><a class="markdownIt-Anchor" href="#5-事务"></a> 5. 事务</h2>
<p>事务中的所有读写是一个执行的整体，整事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。</p>
<h3 id="51-深入理解事务"><a class="markdownIt-Anchor" href="#51-深入理解事务"></a> 5.1. 深入理解事务</h3>
<p>ACID：原子性（ Atomicity ）， 一致性（ Consistency ），隔离性（ Isolation ）与持久性（ Durability ）</p>
<h3 id="52-若隔离级别"><a class="markdownIt-Anchor" href="#52-若隔离级别"></a> 5.2. 若隔离级别</h3>
<h3 id="53-串行化"><a class="markdownIt-Anchor" href="#53-串行化"></a> 5.3. 串行化</h3>
<h2 id="6-分布式系统的挑战"><a class="markdownIt-Anchor" href="#6-分布式系统的挑战"></a> 6. 分布式系统的挑战</h2>
<p><strong>所有可能出错的事情一定会出错</strong>。</p>
<p>分布式系统中可能发生各种问题：</p>
<ul>
<li><strong>不可靠的网络</strong>：当通过网络发送数据包时，数据包可能会丢失或者延迟；同样，回复也可能会丢失或延迟。所以如果没有收到回复，并不能确定消息是否发送成功。</li>
<li><strong>不可靠的时钟</strong>：节点的时钟可能会与其他节点存在明显的不同步（尽管尽最大努力设置了 NTP 服务器），时钟还可能会突然向前跳跃或者倒退， 依靠精确的时钟存在一些风险，没有特别简单的办法来精确测量时钟的偏差范围。</li>
<li>进程可能在执行过程中的任意时候遭遇长度未知的暂停（ 一个重要的原因是垃圾回收），结果它被其他节点宣告为失效，尽管后来又恢复执行，却对中间的暂停毫无所知。</li>
</ul>
<p>部分失效可能是分布式系统的关键特征。对于分布式环境，应该具备必要的容错能力。这样即使某些部件发生失效，系统整体还可以继续运行。</p>
<p>为了容忍错误，第一步是检测错误。多数系统没有检测节点是否发生故障的准确机制，因此分布式算法更多依靠超时来确定远程节点是否仍然可用。但是，超时无法区分网络和节点故障，且可变的网络延迟有时会导致节点被误判<br />
为宕机。此外，节点可能处于一种降级状态： 例如，由于驱动程序错误，千兆网络接口可能突然降到 l kb/s 的吞吐量 。这样一个处于“残废”的节点比彻底挂掉的故障节点更难处理。</p>
<p>检测到错误之后，让系统容忍失效也不容易。在典型的分布式环境下，没有全局变量， 没有共享内存，没有约定的尝试或其他跨节点的共享状态。节点甚至不太清楚现在的准确时间， 更不用说其他更高级的了。信息从一个节点流动到另一个节点只能是通过不可靠的网络来发送。单个节点无住安全的做出任何决策，而是需要多个节点之<br />
间的共识协议，井争取达到法定票数（通常为半数以上）。</p>
<h2 id="7-一致性和共识"><a class="markdownIt-Anchor" href="#7-一致性和共识"></a> 7. 一致性和共识</h2>
<p>分布式系统最重要的抽象之一就是共识： 所有的节点就某一项提议达成一致。</p>
<h3 id="71-一致性保证"><a class="markdownIt-Anchor" href="#71-一致性保证"></a> 7.1. 一致性保证</h3>
<p>分布式一致性则主要是针对延迟和故障等问题来协调副本之间的状态。</p>
<h3 id="72-可线性化"><a class="markdownIt-Anchor" href="#72-可线性化"></a> 7.2. 可线性化</h3>
<p>在最终一致性数据库中，同时查陶两个不同的副本可能会得到两个不同的答案。</p>
<p>线性化（一种流行的一致性模型） ： 其目标是使多副本对外看起来好像是单一副本，然后所有操作以原子方<br />
式运行，就像一个单线程程序操作变量一样。</p>
<p>在有些场景下，线性化对于保证系统正确工作至关重要。</p>
<p><strong>加锁与主节点选举</strong>：主从复制的系统需要确保有且只有一个主节点，否则会产生脑裂。选举新的主节点常见的方住是使用锁：即每个启动的节点都试图获得锁，其中只有一个可以成功即成为主节点 。不管锁具体如何实现，它必须满足可线性化：所有节点都必须同意哪个节点持有锁，否则就会出现问题。</p>
<p><strong>约束与唯一性保证</strong>：常见如关系型数据库中主键的约束，则需要线性化保证。其他如外键或属性约束，则并不要求一定线性化 。</p>
<p><strong>跨通道的时间依赖</strong>：</p>
<h4 id="实现线性化系统"><a class="markdownIt-Anchor" href="#实现线性化系统"></a> 实现线性化系统</h4>
<p>线性化本质上意味着“表现得好像只有一个数据副本，且其上的所有操作都是原子的，所以最简单的方案自然是只用一个数据副本。</p>
<ul>
<li>主从复制（部分支持可线性化）：只有主节点承担数据写入，从节点则在各自节点上维护数据的备份副本。如果从主节点或者同步更新的从节点上读取，则可以满足线性化</li>
<li>共识算挂（可线性化）：共识协议通常内置一些措施来防止裂脑和过期的副本。</li>
<li>多主复制（不可线性化）：具有多主节点复制的系统通常无怯线性化的，主要由于它们同时在多个节点上执行并发写入，并将数据异步复制到其他节点。因此它们可能会产生冲突的写入。</li>
<li>无主复制（可能不可线性化）</li>
</ul>
<h4 id="线性化的代价"><a class="markdownIt-Anchor" href="#线性化的代价"></a> 线性化的代价</h4>
<p>多主复制非常适合多数据中心。</p>
<p>如果两个数据中心之间发生网络中断，会发生什么情况？</p>
<p>基于多主复制的数据库，每个数据中心内都可以继续正常运行： 由于从一个数据中心到另一个数据中心的复制是异步，期间发生的写操作都暂存在本地队列，等网络恢复之后再继续同步。</p>
<p>与之对比，如果是主从复制，则主节点肯定位于其中的某一个数据中心。所有写请求和线性化读取都必须发送给主节点，因此，对于那些连接到非主节点所在数据中心的客户端，读写请求都必须通过数据中心之间的网络，同步发送到主节点所在的数据中。</p>
<p>对于这样的主从复制系统，数据中心之间的网络一旦中断，连接到从数据中心的客户端无怯再联系上主节点，也就无法完成任何数据库写入和线性化读取。从节点可以提供读服务，但内容可能是过期的（非线性化保证）。</p>
<h4 id="cap-理论"><a class="markdownIt-Anchor" href="#cap-理论"></a> CAP 理论</h4>
<h3 id="73-顺序保证"><a class="markdownIt-Anchor" href="#73-顺序保证"></a> 7.3. 顺序保证</h3>
<p>因果关系对事件进行了某种排序（根据事件发生的原因－结果依赖关系）。线性化是将所有操作都放在唯一的、全局有序时间线上，而因果性则不同，它为我们提供了一个弱一致性模型： 允许存在某些井发事件，所以版本历史<br />
是一个包含多个分支与合井的时间线。因果一致性避免了线性化昂贵的协调开销，且对网络延迟的敏感性要低很多。</p>
<h3 id="74-分布式事务与共识"><a class="markdownIt-Anchor" href="#74-分布式事务与共识"></a> 7.4. 分布式事务与共识</h3>
<p>共识意味着就某一项提议，所有节点做出一致的决定，而且决定不可撤销。</p>
<p>如果系统只存在一个节点， 或者愿意把所有决策功能者都委托给某一个节点，那么事情就变得很简单。这和主从复制数据库的情形是一样的，即由主节点负责所有的决策事直，正因如此，这样的数据库可以提供线性化操作、H 住一性约束、完全有序的复制日志等。</p>
<p>然而，如果唯一的主节点发生故障，或者出现网络中断而导致主节点不可达，这样的系统就会陷入停顿状态。有以下三种基本思路来处理这种情况：</p>
<ul>
<li>系统服务停止，等待主节点恢复</li>
<li>人为介入选择新主节点，并重新配置系统使之生效</li>
<li>采用算 i 法来自动选择新的主节点。这需要一个共识算法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/85f228ab.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/85f228ab.html" class="post-title-link" itemprop="url">《数据密集型应用系统设计》之数据系统基础笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 23:32:00" itemprop="dateCreated datePublished" datetime="2021-08-26T23:32:00+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/85f228ab.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="85f228ab.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据密集型应用系统设计之数据系统基础笔记"><a class="markdownIt-Anchor" href="#数据密集型应用系统设计之数据系统基础笔记"></a> 《数据密集型应用系统设计》之数据系统基础笔记</h1>
<h2 id="第-1-章-可靠-可扩展与可维护的应用系统"><a class="markdownIt-Anchor" href="#第-1-章-可靠-可扩展与可维护的应用系统"></a> 第 1 章 可靠、可扩展与可维护的应用系统</h2>
<h3 id="认识数据系统"><a class="markdownIt-Anchor" href="#认识数据系统"></a> 认识数据系统</h3>
<p>很多应用系统都包含以下数据处理系统：</p>
<ul>
<li>数据库：用以存储数据，这样之后应用可以再次面问。</li>
<li>高速缓存： 缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。</li>
<li>索引： 用户可以按关键字搜索数据井支持各种过掳。</li>
<li>流式处理：持续发送消息至另一个进程，处理采用异步方式。</li>
<li>批处理： 定期处理大量的累积数据。</li>
</ul>
<p>设计数据系统或数据服务时，需要考虑很多因素，其中最重要的三个问题：</p>
<ul>
<li><strong>可靠性（Reliability）</strong>：当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。</li>
<li><strong>可扩展性（Scalability）</strong>：随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。</li>
<li><strong>可维护性（Maintainability）</strong>：随着时间的推移，许多新的人员参与到系统开发和运维， 以维护现有功能或适配新场景等，系统都应高效运转。</li>
</ul>
<h3 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h3>
<p>可靠性意味着：即时发生了某些错误，系统仍然可以继续正常工作。</p>
<p>系统可应对错误则称为容错（fault tolerant）或者弹性（resilient）。</p>
<p>常见的故障类型：</p>
<ul>
<li>硬件故障：通常是随机的，如：硬盘崩溃、内存故障、电网停电、断网等。常见应对策略：使用集群去冗余。</li>
<li>软件故障：各种难以预料的 bug。</li>
<li>人为故障：如操作不当。</li>
</ul>
<h3 id="可扩展性"><a class="markdownIt-Anchor" href="#可扩展性"></a> 可扩展性</h3>
<p>可扩展性是指负载增加时， 有效保持系统性能的相关技术策略。</p>
<p>吞吐量：每秒可处理的记录数</p>
<p>响应时间：中位数指标比平均响应时间更适合描述等待时间。</p>
<p>如何应对负载：垂直扩展（升级硬件）和水平扩展（集群、分布式）</p>
<h3 id="可维护性"><a class="markdownIt-Anchor" href="#可维护性"></a> 可维护性</h3>
<ul>
<li>可运维性：方便运营团队来保持系统平稳运行。</li>
<li>简单性：简化系统复杂性，使新工程师能够轻松理解系统。</li>
<li>可演化性：后续工程师能够轻松地对系统进行改进，井根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性或可塑性。</li>
</ul>
<p>主要措施：</p>
<ul>
<li>良好的抽象可以帮助降低复杂性， 井使系统更易于修改和适配新场景。</li>
<li>良好的可操作性意味着对系统健康状况有良好的可观测性和有效的管理方战。</li>
</ul>
<h2 id="第-2-章-数据模型与查询语言"><a class="markdownIt-Anchor" href="#第-2-章-数据模型与查询语言"></a> 第 2 章 数据模型与查询语言</h2>
<p>复杂的应用程序可能会有更多的中间层，每层都通过提供一个简洁的数据模型来隐藏下层的复杂性。</p>
<p>如果数据大多是一对多关系（树结构数据）或者记录之间没有关系，那么文档模型是最合适的。</p>
<p>关系模型能够处理简单的多对多关系，但是随着数据之间的关联越来越复杂，将数据建模转化为图模型会更加自然。</p>
<h2 id="第-3-章-数据存储与检索"><a class="markdownIt-Anchor" href="#第-3-章-数据存储与检索"></a> 第 3 章 数据存储与检索</h2>
<p>从最基本的层面看，数据库只需做两件事情：存储和检索。</p>
<h3 id="数据库核心数据结构"><a class="markdownIt-Anchor" href="#数据库核心数据结构"></a> 数据库核心：数据结构</h3>
<p>为了高效地查找数据库中特定键的值， 需要新的数据结构： 索引。</p>
<p>存储系统的设计权衡：适当的索引可以加速读取查询，但每个索引都会减慢写速度。数据库通常不会对所有内容进行索引。</p>
<p>索引类型：</p>
<ul>
<li>哈希索引</li>
<li>B+ 树</li>
<li>LSM 树</li>
<li>等等</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></p>
</blockquote>
<h3 id="事务处理与分析处理"><a class="markdownIt-Anchor" href="#事务处理与分析处理"></a> 事务处理与分析处理</h3>
<h3 id="列式存储"><a class="markdownIt-Anchor" href="#列式存储"></a> 列式存储</h3>
<p>如果表中有数以万亿行、PB 大小的数据，则适合用于存储在列式存储中。</p>
<h2 id="第-4-章-数据编码与演化"><a class="markdownIt-Anchor" href="#第-4-章-数据编码与演化"></a> 第 4 章 数据编码与演化</h2>
<p>本章节主要介绍各种序列化、反序列化方式。略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/bbe3aafc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bbe3aafc.html" class="post-title-link" itemprop="url">架构实战案例解析笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 23:32:00" itemprop="dateCreated datePublished" datetime="2021-08-26T23:32:00+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/bbe3aafc.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="bbe3aafc.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>708</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="架构实战案例解析"><a class="markdownIt-Anchor" href="#架构实战案例解析"></a> 架构实战案例解析</h1>
<h2 id="架构的本质如何打造一个有序的系统"><a class="markdownIt-Anchor" href="#架构的本质如何打造一个有序的系统"></a> 架构的本质：如何打造一个有序的系统？</h2>
<p><strong>架构的本质</strong>：通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。</p>
<p>首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。</p>
<p>其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。</p>
<p><strong>架构的分类</strong></p>
<ul>
<li>业务架构</li>
<li>应用架构</li>
<li>技术架构</li>
</ul>
<p><strong>架构师的自我修养</strong></p>
<ul>
<li>优秀的程序员</li>
<li>沟通交流</li>
<li>权衡取舍</li>
<li>多领域知识</li>
<li>技术前瞻性</li>
<li>看透问题本质</li>
<li>抽象思维</li>
</ul>
<h2 id="业务架构作为开发你真的了解业务吗"><a class="markdownIt-Anchor" href="#业务架构作为开发你真的了解业务吗"></a> 业务架构：作为开发，你真的了解业务吗？</h2>
<p>产品经理的职责是定义产品的外观。</p>
<p>架构师的职责是将业务抽象为结构化的模块体系。</p>
<h2 id="可扩展架构如何打造一个善变的柔性系统"><a class="markdownIt-Anchor" href="#可扩展架构如何打造一个善变的柔性系统"></a> 可扩展架构：如何打造一个善变的柔性系统？</h2>
<p>系统 = 模块 + 关系</p>
<p>模块的要求：</p>
<ul>
<li>定位明确，概念完整</li>
<li>自成体系，粒度适中</li>
</ul>
<p>依赖关系的要求：</p>
<ul>
<li>最好是单向的</li>
<li>最好是层次化结构</li>
</ul>
<p>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p>
<h2 id="可扩展架构案例一电商平台架构是如何演变的"><a class="markdownIt-Anchor" href="#可扩展架构案例一电商平台架构是如何演变的"></a> 可扩展架构案例（一）：电商平台架构是如何演变的？</h2>
<p>电商平台的大致发展：</p>
<p>单体 -&gt; 分布式 -&gt; SOA -&gt; 微服务 -&gt; 中台</p>
<p>SOA vs. 微服务</p>
<ul>
<li>SOA 中的 ESB 采用集中式管理</li>
<li>微服务采用去中心化管理</li>
</ul>
<h2 id="可扩展架构案例二app-服务端架构是如何升级的"><a class="markdownIt-Anchor" href="#可扩展架构案例二app-服务端架构是如何升级的"></a> 可扩展架构案例（二）：App 服务端架构是如何升级的？</h2>
<h2 id="可扩展架构案例三你真的需要一个中台吗"><a class="markdownIt-Anchor" href="#可扩展架构案例三你真的需要一个中台吗"></a> 可扩展架构案例（三）：你真的需要一个中台吗？</h2>
<p>前台：面向 C 端的应用</p>
<p>后台：企业内部系统</p>
<p>中台：通过实现基础业务的平台化，实现了企业级业务能力的快速复用</p>
<h2 id="可复用架构如何实现高层次的复用"><a class="markdownIt-Anchor" href="#可复用架构如何实现高层次的复用"></a> 可复用架构：如何实现高层次的复用？</h2>
<p>技术复用</p>
<ul>
<li>代码复用</li>
<li>组件复用</li>
</ul>
<p>业务复用</p>
<h2 id="可复用架构案例一如何设计一个基础服务"><a class="markdownIt-Anchor" href="#可复用架构案例一如何设计一个基础服务"></a> 可复用架构案例（一）：如何设计一个基础服务？</h2>
<h2 id="可复用架构案例二如何对现有系统做微服务改造"><a class="markdownIt-Anchor" href="#可复用架构案例二如何对现有系统做微服务改造"></a> 可复用架构案例（二）：如何对现有系统做微服务改造？</h2>
<h2 id="可复用架构案例三中台是如何炼成的"><a class="markdownIt-Anchor" href="#可复用架构案例三中台是如何炼成的"></a> 可复用架构案例（三）：中台是如何炼成的？</h2>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046301">架构实战案例解析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/73dedef0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/73dedef0.html" class="post-title-link" itemprop="url">海量数据处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-19 22:15:16" itemprop="dateCreated datePublished" datetime="2021-08-19T22:15:16+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/73dedef0.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="73dedef0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="海量数据处理"><a class="markdownIt-Anchor" href="#海量数据处理"></a> 海量数据处理</h1>
<h2 id="如何从海量的-url-中找出相同的-url"><a class="markdownIt-Anchor" href="#如何从海量的-url-中找出相同的-url"></a> 如何从海量的 URL 中找出相同的 URL？</h2>
<h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3>
<p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p>
<h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3>
<p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。</p>
<blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn><mo>∗</mo><mn>64</mn><mi>B</mi><mo>≈</mo><mn>5</mn><mi>G</mi><mi>B</mi><mo>∗</mo><mn>64</mn><mo>=</mo><mn>320</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">5,000,000,000 * 64 B ≈ 5 GB * 64 = 320 GB
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
</blockquote>
<p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p>
<p>思路如下：</p>
<p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p>
<p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p>
<h3 id="方案总结"><a class="markdownIt-Anchor" href="#方案总结"></a> 方案总结</h3>
<ul>
<li>分而治之，进行哈希取余；</li>
<li>对每个子文件进行 HashSet 统计。</li>
</ul>
<h2 id="如何从海量数据中找出高频词"><a class="markdownIt-Anchor" href="#如何从海量数据中找出高频词"></a> 如何从海量数据中找出高频词？</h2>
<h3 id="问题描述-2"><a class="markdownIt-Anchor" href="#问题描述-2"></a> 问题描述</h3>
<p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p>
<h3 id="解决思路-2"><a class="markdownIt-Anchor" href="#解决思路-2"></a> 解决思路</h3>
<p>由于内存限制，无法直接将大文件的所有词一次读到内存中。因此，可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p>
<p><strong>思路如下</strong>：</p>
<p>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 Ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p>
<p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 <code>HashMap</code> 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> 若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p>
<p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p>
<h3 id="方案总结-2"><a class="markdownIt-Anchor" href="#方案总结-2"></a> 方案总结</h3>
<ul>
<li>分而治之，进行哈希取余；</li>
<li>使用 <code>HashMap</code> 统计频数；</li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ul>
<h2 id="如何找出某一天访问百度网站最多的-ip"><a class="markdownIt-Anchor" href="#如何找出某一天访问百度网站最多的-ip"></a> 如何找出某一天访问百度网站最多的 IP？</h2>
<h3 id="问题描述-3"><a class="markdownIt-Anchor" href="#问题描述-3"></a> 问题描述</h3>
<p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p>
<h3 id="解决思路-3"><a class="markdownIt-Anchor" href="#解决思路-3"></a> 解决思路</h3>
<p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p>
<blockquote>
<p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p>
</blockquote>
<h3 id="方法总结"><a class="markdownIt-Anchor" href="#方法总结"></a> 方法总结</h3>
<ul>
<li>分而治之，进行哈希取余；</li>
<li>使用 HashMap 统计频数；</li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ul>
<h2 id="如何在大量的数据中找出不重复的整数"><a class="markdownIt-Anchor" href="#如何在大量的数据中找出不重复的整数"></a> 如何在大量的数据中找出不重复的整数？</h2>
<h3 id="问题描述-4"><a class="markdownIt-Anchor" href="#问题描述-4"></a> 问题描述</h3>
<p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p>
<h3 id="解决思路-4"><a class="markdownIt-Anchor" href="#解决思路-4"></a> 解决思路</h3>
<h4 id="方法一分治法"><a class="markdownIt-Anchor" href="#方法一分治法"></a> 方法一：分治法</h4>
<p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p>
<h4 id="方法二位图法"><a class="markdownIt-Anchor" href="#方法二位图法"></a> 方法二：位图法</h4>
<p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p>
<p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p>
<p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>依次遍历，结束后，位数组是这样的：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>每个为 1 的位，它的下标都表示了一个数：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> bits<span class="selector-attr">[i]</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>这样我们其实就已经实现了排序。</p>
<p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。</p>
<p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p>
<ul>
<li>00 表示这个数字没出现过；</li>
<li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li>
<li>10 表示这个数字出现了多次。</li>
</ul>
<p>那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p>
<p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p>
<h3 id="方法总结-2"><a class="markdownIt-Anchor" href="#方法总结-2"></a> 方法总结</h3>
<p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p>
<h2 id="如何在大量的数据中判断一个数是否存在"><a class="markdownIt-Anchor" href="#如何在大量的数据中判断一个数是否存在"></a> 如何在大量的数据中判断一个数是否存在？</h2>
<h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3>
<p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p>
<h3 id="解答思路"><a class="markdownIt-Anchor" href="#解答思路"></a> 解答思路</h3>
<h4 id="方法一分治法-2"><a class="markdownIt-Anchor" href="#方法一分治法-2"></a> 方法一：分治法</h4>
<p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p>
<h4 id="方法二位图法-2"><a class="markdownIt-Anchor" href="#方法二位图法-2"></a> 方法二：位图法</h4>
<p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。</p>
<p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p>
<h3 id="方法总结-3"><a class="markdownIt-Anchor" href="#方法总结-3"></a> 方法总结</h3>
<p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p>
<h2 id="如何查询最热门的查询串"><a class="markdownIt-Anchor" href="#如何查询最热门的查询串"></a> 如何查询最热门的查询串？</h2>
<h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3>
<p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。</p>
<p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p>
<h3 id="解答思路-2"><a class="markdownIt-Anchor" href="#解答思路-2"></a> 解答思路</h3>
<p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p>
<h4 id="方法一分治法-3"><a class="markdownIt-Anchor" href="#方法一分治法-3"></a> 方法一：分治法</h4>
<p>分治法依然是一个非常实用的方法。</p>
<p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p>
<p>方法可行，但不是最好，下面介绍其他方法。</p>
<h4 id="方法二hashmap-法"><a class="markdownIt-Anchor" href="#方法二hashmap-法"></a> 方法二：HashMap 法</h4>
<p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。</p>
<p><strong>思路如下</strong>：</p>
<p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code>。</p>
<p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p>
<p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code>。</p>
<h4 id="方法三前缀树法字典树"><a class="markdownIt-Anchor" href="#方法三前缀树法字典树"></a> 方法三：前缀树法（字典树）</h4>
<p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p>
<p><strong>思路如下</strong>：</p>
<p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p>
<p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p>
<h3 id="方法总结-4"><a class="markdownIt-Anchor" href="#方法总结-4"></a> 方法总结</h3>
<p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p>
<h2 id="如何统计不同电话号码的个数"><a class="markdownIt-Anchor" href="#如何统计不同电话号码的个数"></a> 如何统计不同电话号码的个数？</h2>
<h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3>
<p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p>
<h3 id="解答思路-3"><a class="markdownIt-Anchor" href="#解答思路-3"></a> 解答思路</h3>
<p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p>
<p>对于本题，8 位电话号码可以表示的号码个数为 $$10^8$$ 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p>
<p><strong>思路如下</strong>：</p>
<p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p>
<h3 id="方法总结-5"><a class="markdownIt-Anchor" href="#方法总结-5"></a> 方法总结</h3>
<p>求解数据重复问题，记得考虑位图法。</p>
<h2 id="如何从-5-亿个数中找出中位数"><a class="markdownIt-Anchor" href="#如何从-5-亿个数中找出中位数"></a> 如何从 5 亿个数中找出中位数？</h2>
<h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3>
<p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p>
<h3 id="解答思路-4"><a class="markdownIt-Anchor" href="#解答思路-4"></a> 解答思路</h3>
<p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code>。这里使用其他方法。</p>
<h4 id="方法一双堆法"><a class="markdownIt-Anchor" href="#方法一双堆法"></a> 方法一：双堆法</h4>
<p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p>
<p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Integer::compareTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> minHeap.size();</span><br><span class="line">        <span class="keyword">if</span> (size1 - size2 &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size2 - size1 &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> minHeap.size();</span><br><span class="line"></span><br><span class="line">        <span class="type">return</span> <span class="variable">size1</span> <span class="operator">=</span>= size2</span><br><span class="line">            ? (maxHeap.peek() + minHeap.peek()) * <span class="number">1.0</span> / <span class="number">2</span></span><br><span class="line">            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>见 LeetCode No.295：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-median-from-data-stream/">https://leetcode.com/problems/find-median-from-data-stream/</a></p>
</blockquote>
<p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p>
<h4 id="方法二分治法"><a class="markdownIt-Anchor" href="#方法二分治法"></a> 方法二：分治法</h4>
<p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p>
<p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p>
<p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p>
<blockquote>
<p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p>
</blockquote>
<p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p>
<blockquote>
<p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p>
</blockquote>
<h3 id="方法总结-6"><a class="markdownIt-Anchor" href="#方法总结-6"></a> 方法总结</h3>
<p>分治法，真香！</p>
<h2 id="如何找出排名前-500-的数"><a class="markdownIt-Anchor" href="#如何找出排名前-500-的数"></a> 如何找出排名前 500 的数？</h2>
<h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3>
<p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p>
<h3 id="解答思路-5"><a class="markdownIt-Anchor" href="#解答思路-5"></a> 解答思路</h3>
<p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p>
<p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p>
<p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p>
<p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p>
<blockquote>
<p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> https://github.com/yanglbme</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataWithSource</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;DataWithSource&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录数值来源的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录数值在数组中的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataWithSource</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> source, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改</span></span><br><span class="line"><span class="comment">     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(DataWithSource o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o.getValue(), <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getTop(<span class="type">int</span>[][] data) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowSize</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columnSize</span> <span class="operator">=</span> data[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个columnSize大小的数组，存放结果</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[columnSize];</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;DataWithSource&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowSize; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将每个数组的最大一个元素放入堆中</span></span><br><span class="line">            <span class="type">DataWithSource</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataWithSource</span>(data[i][<span class="number">0</span>], i, <span class="number">0</span>);</span><br><span class="line">            maxHeap.add(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; columnSize) &#123;</span><br><span class="line">            <span class="comment">// 删除堆顶元素</span></span><br><span class="line">            <span class="type">DataWithSource</span> <span class="variable">d</span> <span class="operator">=</span> maxHeap.poll();</span><br><span class="line">            result[num++] = d.getValue();</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= columnSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            d.setValue(data[d.getSource()][d.getIndex() + <span class="number">1</span>]);</span><br><span class="line">            d.setIndex(d.getIndex() + <span class="number">1</span>);</span><br><span class="line">            maxHeap.add(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] data = &#123;</span><br><span class="line">                &#123;<span class="number">29</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">19</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">30</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] top = getTop(data);</span><br><span class="line">        System.out.println(Arrays.toString(top)); <span class="comment">// [30, 29, 25, 20, 19]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法总结-7"><a class="markdownIt-Anchor" href="#方法总结-7"></a> 方法总结</h3>
<p>求 TopK，不妨考虑一下堆排序？</p>
<h2 id="如何按照-query-的频度排序"><a class="markdownIt-Anchor" href="#如何按照-query-的频度排序"></a> 如何按照 query 的频度排序？</h2>
<h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3>
<p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p>
<h3 id="解答思路-6"><a class="markdownIt-Anchor" href="#解答思路-6"></a> 解答思路</h3>
<p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p>
<h4 id="方法一hashmap-法"><a class="markdownIt-Anchor" href="#方法一hashmap-法"></a> 方法一：HashMap 法</h4>
<p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。</p>
<h4 id="方法二分治法-2"><a class="markdownIt-Anchor" href="#方法二分治法-2"></a> 方法二：分治法</h4>
<p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p>
<p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p>
<h3 id="方法总结-8"><a class="markdownIt-Anchor" href="#方法总结-8"></a> 方法总结</h3>
<ul>
<li>内存若够，直接读入进行排序；</li>
<li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/d1bcfbe7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/d1bcfbe7.html" class="post-title-link" itemprop="url">从0开始学微服务学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 15:27:00" itemprop="dateCreated datePublished" datetime="2021-08-15T15:27:00+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/d1bcfbe7.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="d1bcfbe7.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从-0-开始学微服务学习笔记"><a class="markdownIt-Anchor" href="#从-0-开始学微服务学习笔记"></a> 从 0 开始学微服务学习笔记</h1>
<h2 id="1-到底什么是微服务"><a class="markdownIt-Anchor" href="#1-到底什么是微服务"></a> 1. 到底什么是微服务？</h2>
<blockquote>
<p>微服务定义</p>
<p>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。</p>
<p>——Martin Fowler 和 James Lewis</p>
</blockquote>
<p>单体应用的问题</p>
<ul>
<li>部署效率低</li>
<li>团队协作开发成本高</li>
<li>单点故障问题</li>
<li>线上发布变慢</li>
</ul>
<p>服务化：本地方法调用 转为 远程方法调用（RPC）</p>
<p>微服务和服务化的差异：</p>
<ul>
<li>服务拆分粒度更细</li>
<li>服务独立部署、维护</li>
<li>服务治理要求高</li>
</ul>
<h2 id="2-从单体应用走向服务化"><a class="markdownIt-Anchor" href="#2-从单体应用走向服务化"></a> 2. 从单体应用走向服务化</h2>
<h3 id="21-什么时候进行服务化拆分"><a class="markdownIt-Anchor" href="#21-什么时候进行服务化拆分"></a> 2.1. 什么时候进行服务化拆分？</h3>
<p>经验：开发人员超过 10 人（沟通成本变高），就可以考虑服务化拆分</p>
<h3 id="22-服务化拆分的两种姿势"><a class="markdownIt-Anchor" href="#22-服务化拆分的两种姿势"></a> 2.2. 服务化拆分的两种姿势</h3>
<p><strong>纵向拆分</strong>，从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p><strong>横向拆分</strong>，从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<h3 id="23-服务化拆分的前置条件"><a class="markdownIt-Anchor" href="#23-服务化拆分的前置条件"></a> 2.3. 服务化拆分的前置条件</h3>
<ul>
<li><strong>服务如何定义</strong>。通过接口来约定。</li>
<li><strong>服务如何发布和订阅</strong>。通过服务注册和发现。</li>
<li><strong>服务如何监控</strong>。<strong>故障如何定位</strong>。服务化需要链路监控。</li>
<li><strong>服务如何治理</strong>。超时和重试、流量控制。</li>
</ul>
<h2 id="3-初探微服务架构"><a class="markdownIt-Anchor" href="#3-初探微服务架构"></a> 3. 初探微服务架构</h2>
<p>微服务通过注册中心，实现发布订阅模式。</p>
<p>服务调用主要依赖几个基本组件：</p>
<ul>
<li>服务描述：常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。
<ul>
<li>RESTful API 代表：Swagger</li>
<li>XML 代表：Dubbo</li>
<li>IDL 代表：Thrift、gRPC</li>
</ul>
</li>
<li>注册中心
<ul>
<li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li>
<li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li>
<li>注册中心返回服务提供者地址列表给服务消费者。</li>
<li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li>
</ul>
</li>
<li>服务框架
<ul>
<li>通信协议：选择 TCP、UDP、HTTP，还是其他？</li>
<li>数据传输方式：同步、异步、多路复用？</li>
<li>序列化方式：JDK 序列化、Json、二进制（Protobuf、Thrift）？</li>
</ul>
</li>
<li>服务监控
<ul>
<li>数据采集</li>
<li>数据处理</li>
<li>数据展示</li>
</ul>
</li>
<li>服务追踪</li>
<li>工作原理：通过 requestId、spanId 分别表示一次请求、请求中的某一环节</li>
<li>服务治理：
<ul>
<li>超时、重试</li>
<li>负载均衡</li>
<li>故障转移</li>
<li>流量控制</li>
</ul>
</li>
</ul>
<h2 id="4-如何发布和引用服务"><a class="markdownIt-Anchor" href="#4-如何发布和引用服务"></a> 4. 如何发布和引用服务？</h2>
<p><strong>RESTful API</strong>：主要被<strong>用作 HTTP 或者 HTTPS 协议的接口定义</strong>。代表：Eureka</p>
<p><strong>XML 配置</strong>：代表：Dubbo。工作步骤：</p>
<ul>
<li>服务提供者定义接口，并实现接口。</li>
<li>服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。</li>
<li>服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。</li>
</ul>
<p>IDL 文件：IDL 就是接口描述语言（interface description language）的缩写。主要<strong>用作跨语言平台的服务之间的调用</strong>。有两种最常用的 IDL：Thrift、gRPC。</p>
<h2 id="5-如何注册和发现服务"><a class="markdownIt-Anchor" href="#5-如何注册和发现服务"></a> 5. 如何注册和发现服务？</h2>
<p>微服务架构下，主要有三种角色：</p>
<ul>
<li>服务提供者（RPC Server）</li>
<li>服务消费者（RPC Client）</li>
<li>服务注册中心（Registry）</li>
</ul>
<h3 id="51-注册中心实现方式"><a class="markdownIt-Anchor" href="#51-注册中心实现方式"></a> 5.1. 注册中心实现方式</h3>
<p>注册中心必须提供以下最基本的 API，例如：</p>
<ul>
<li>
<p>服务注册接口</p>
</li>
<li>
<p>服务注销接口</p>
</li>
<li>
<p>心跳汇报接口</p>
</li>
<li>
<p>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</p>
</li>
<li>
<p>服务变更查询接口</p>
</li>
<li>
<p>服务查询接口</p>
</li>
<li>
<p>服务修改接口</p>
</li>
</ul>
<h3 id="52-集群部署"><a class="markdownIt-Anchor" href="#52-集群部署"></a> 5.2. 集群部署</h3>
<p>注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>以 ZooKeeper 的工作原理为例：</p>
<ul>
<li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li>
<li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li>
<li>Leader 负责处理数据更新等操作（ZAB 协议）。</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li>
</ul>
<h3 id="53-目录存储"><a class="markdownIt-Anchor" href="#53-目录存储"></a> 5.3. 目录存储</h3>
<p>注册中心存储服务信息一般采用层次化的目录结构：</p>
<ul>
<li>每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。</li>
<li>znode 可以包含数据和子 znode。</li>
<li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<h3 id="54-服务健康状态检测"><a class="markdownIt-Anchor" href="#54-服务健康状态检测"></a> 5.4. 服务健康状态检测</h3>
<p>ZooKeeper 客户端和服务端维持的是一个长连接。连接成功后，会生成一个全局唯一的 Session ID，客户端定期发送心跳消息，服务端收到后重置会话超时时间。如果超时，则认为连接结束。</p>
<p>如果一个服务将 ZooKeeper 作为服务注册中心，一旦连接超时，ZooKeeper 会认为这个服务节点已经不可用，就会将其信息删除。</p>
<h3 id="55-服务状态变更通知"><a class="markdownIt-Anchor" href="#55-服务状态变更通知"></a> 5.5. 服务状态变更通知</h3>
<p>ZooKeeper 支持 Watch 机制。服务消费者可以监听服务提供者的节点信息。一旦服务提供者的节点信息哟变化，就可以获取到变更状态。</p>
<h3 id="56-白名单机制"><a class="markdownIt-Anchor" href="#56-白名单机制"></a> 5.6. 白名单机制</h3>
<p>通常注册中心会有多套环境，区分开发、测试、线上等环境。如果弄错了，会出现意想不到的后果，为此需要引入白名单保护机制。只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h2 id="6-如何实现-rpc-远程服务调用"><a class="markdownIt-Anchor" href="#6-如何实现-rpc-远程服务调用"></a> 6. 如何实现 RPC 远程服务调用？</h2>
<p>客户端和服务端如何建立网络连接？</p>
<ul>
<li><strong>HTTP 通信</strong>：三次握手建立连接；四次挥手断开连接</li>
<li><strong>Socket 通信</strong>
<ul>
<li>服务器监听</li>
<li>客户端请求</li>
<li>连接确认</li>
<li>数据传输</li>
</ul>
</li>
</ul>
<p>服务端如何处理请求？</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<p>数据传输采用什么协议？</p>
<ul>
<li>Http</li>
<li>Dubbo</li>
</ul>
<p>数据该如何序列化和反序列化？</p>
<ul>
<li>JDK</li>
<li>JSON</li>
<li>二进制（PB、Thrift 等）</li>
</ul>
<h2 id="7-如何监控微服务调用"><a class="markdownIt-Anchor" href="#7-如何监控微服务调用"></a> 7. 如何监控微服务调用？</h2>
<p>监控对象</p>
<ul>
<li>客户端监控</li>
<li>接口监控</li>
<li>资源监控</li>
<li>基础监控</li>
</ul>
<p>监控指标</p>
<ul>
<li>请求量</li>
<li>响应时间</li>
<li>错误率</li>
</ul>
<p>监控维度</p>
<ul>
<li>全局维度</li>
<li>机房维度</li>
<li>单机维度</li>
<li>时间维度</li>
<li>重要性维度</li>
</ul>
<p>监控关键点</p>
<ul>
<li>数据采集
<ul>
<li>主动上报</li>
<li>代理收集</li>
</ul>
</li>
<li>数据传输
<ul>
<li>UDP</li>
<li>Kafka</li>
</ul>
</li>
<li>数据处理
<ul>
<li>全文检索：如 Elasticsearch</li>
<li>时序数据库：如 InfluxDB、OpenTSDB</li>
<li>流计算：如 Spark、Storm、Flink</li>
</ul>
</li>
<li>数据展示</li>
</ul>
<h2 id="8-如何追踪微服务调用"><a class="markdownIt-Anchor" href="#8-如何追踪微服务调用"></a> 8. 如何追踪微服务调用？</h2>
<h3 id="81-服务追踪的作用"><a class="markdownIt-Anchor" href="#81-服务追踪的作用"></a> 8.1. 服务追踪的作用</h3>
<ul>
<li>定位整个系统的瓶颈点</li>
<li>优化链路调用</li>
<li>生成网络拓扑</li>
<li>透明传输数据</li>
</ul>
<h3 id="82-服务追踪系统原理"><a class="markdownIt-Anchor" href="#82-服务追踪系统原理"></a> 8.2. 服务追踪系统原理</h3>
<p>经典论文：<a target="_blank" rel="noopener" href="http://bigbully.github.io/Dapper-translation/"><code>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</code></a></p>
<ul>
<li><strong>traceId</strong>，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><strong>spanId</strong>，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><strong>annotation</strong>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li>
</ul>
<h3 id="83-服务追踪系统实现"><a class="markdownIt-Anchor" href="#83-服务追踪系统实现"></a> 8.3. 服务追踪系统实现</h3>
<p>服务追踪系统可以分为三层。</p>
<ul>
<li>数据采集层，负责数据埋点并上报。</li>
<li>数据处理层，负责数据的存储与计算。</li>
<li>数据展示层，负责数据的图形化展示。</li>
</ul>
<h2 id="9-微服务治理的手段有哪些"><a class="markdownIt-Anchor" href="#9-微服务治理的手段有哪些"></a> 9. 微服务治理的手段有哪些？</h2>
<p>服务调用失败原因：</p>
<ul>
<li>服务提供者自身问题，如宕机、进程退出等；</li>
<li>网络问题</li>
</ul>
<h3 id="91-节点管理"><a class="markdownIt-Anchor" href="#91-节点管理"></a> 9.1. 节点管理</h3>
<ul>
<li><strong>注册中心主动摘除机制</strong>：服务提供者定时发送心跳，如果超时，注册中心把节点从服务列表中删除</li>
<li><strong>服务消费者摘除机制</strong>：如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除。</li>
</ul>
<h3 id="92-负载均衡"><a class="markdownIt-Anchor" href="#92-负载均衡"></a> 9.2. 负载均衡</h3>
<ul>
<li>随机算法</li>
<li>轮询算法</li>
<li>最少活跃调用算法</li>
<li>一致性 Hash 算法</li>
</ul>
<h3 id="93-服务路由"><a class="markdownIt-Anchor" href="#93-服务路由"></a> 9.3. 服务路由</h3>
<p>为什么要制定路由规则呢？</p>
<ul>
<li>业务存在灰度发布的需求</li>
<li>多机房就近访问的需求</li>
</ul>
<p>如何配置路由规则</p>
<ul>
<li>静态配置：修改服务消费者本地配置，上线后生效</li>
<li>动态配置：修改注册中心的配置，服务消费者在下一个同步周期之后，就会动态更新</li>
</ul>
<h3 id="94-服务容错"><a class="markdownIt-Anchor" href="#94-服务容错"></a> 9.4. 服务容错</h3>
<ul>
<li>FailOver：失败自动切换。</li>
<li>FailBack：失败通知。</li>
<li>FailCache：失败缓存。</li>
<li>FailFast：快速失败。</li>
</ul>
<p>一般情况下对于幂等的调用，可以选择 FailOver 或者 FailCache，非幂等的调用可以选择 FailBack 或者 FailFast。</p>
<h2 id="10-dubbo-框架里的微服务组件"><a class="markdownIt-Anchor" href="#10-dubbo-框架里的微服务组件"></a> 10. Dubbo 框架里的微服务组件</h2>
<h2 id="11-服务发布和引用的实践"><a class="markdownIt-Anchor" href="#11-服务发布和引用的实践"></a> 11. 服务发布和引用的实践</h2>
<p>XML 配置方式的服务发布和引用流程</p>
<ul>
<li>服务提供者定义接口</li>
<li>服务提供者发布接口</li>
<li>服务消费者引用接口</li>
</ul>
<p>服务发布和引用的那些坑</p>
<h2 id="12-如何将注册中心落地"><a class="markdownIt-Anchor" href="#12-如何将注册中心落地"></a> 12. 如何将注册中心落地？</h2>
<p>注册中心如何存储服务信息</p>
<p>服务一般会分成多个不同的分组</p>
<ul>
<li>核心与非核心，从业务的核心程度来分。</li>
<li>机房，从机房的维度来分。</li>
<li>线上环境与测试环境，从业务场景维度来区分。</li>
</ul>
<p>所以注册中心存储的服务信息一般包含三部分内容：<strong>分组</strong>、<strong>服务名</strong>以及<strong>节点信息</strong>，节点信息又包括节点地址和节点其他信息。</p>
<h3 id="121-注册中心工作流程"><a class="markdownIt-Anchor" href="#121-注册中心工作流程"></a> 12.1. 注册中心工作流程</h3>
<ul>
<li>服务提供者注册流程。</li>
<li>服务提供者反注册流程。</li>
<li>服务消费者查询流程。</li>
<li>服务消费者订阅变更流程。</li>
</ul>
<h3 id="122-如何注册节点"><a class="markdownIt-Anchor" href="#122-如何注册节点"></a> 12.2. 如何注册节点</h3>
<ul>
<li>首先查看要注册的节点是否在白名单内？如果不在就抛出异常，在的话继续下一步。</li>
<li>其次要查看注册的 Cluster（服务的接口名）是否存在？如果不存在就抛出异常，存在的话继续下一步。</li>
<li>然后要检查 Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下一步。</li>
<li>最后将节点信息添加到对应的 Service 和 Cluster 下面的存储中。</li>
</ul>
<h3 id="123-如何反注册"><a class="markdownIt-Anchor" href="#123-如何反注册"></a> 12.3. 如何反注册</h3>
<ul>
<li>查看 Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>查看 Cluster（服务的接口名）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>删除存储中 Service 和 Cluster 下对应的节点信息。</li>
<li>更新 Cluster 的 sign 值。</li>
</ul>
<h3 id="124-如何查询节点信息"><a class="markdownIt-Anchor" href="#124-如何查询节点信息"></a> 12.4. 如何查询节点信息</h3>
<p>首先从 localcache（本机内存）中查找，如果没有就继续下一步。</p>
<p>接着从 snapshot（本地快照）中查找，如果没有就继续下一步。</p>
<h3 id="125-如何订阅服务变更"><a class="markdownIt-Anchor" href="#125-如何订阅服务变更"></a> 12.5. 如何订阅服务变更</h3>
<ul>
<li>服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的 sign 值。</li>
<li>服务消费者每隔一段时间，调用 getSign() 函数，从注册中心获取服务端该 Cluster 的 sign 值，并与本地保留的 sign 值做对比，如果不一致，就从服务端拉取新的节点信息，并更新 localcache 和 snapshot。</li>
</ul>
<h3 id="126-注册与发现的几个问题"><a class="markdownIt-Anchor" href="#126-注册与发现的几个问题"></a> 12.6. 注册与发现的几个问题</h3>
<ul>
<li>
<p>多注册中心</p>
</li>
<li>
<p>并行订阅服务</p>
</li>
<li>
<p>批量反注册服务</p>
</li>
<li>
<p>服务变更信息增量更新</p>
</li>
</ul>
<h2 id="13-开源服务注册中心如何选型"><a class="markdownIt-Anchor" href="#13-开源服务注册中心如何选型"></a> 13. 开源服务注册中心如何选型？</h2>
<ul>
<li><strong>应用内注册与发现</strong>：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。典型代表：Eureka</li>
<li><strong>应用外注册与发现</strong>：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。典型代表：Consul</li>
</ul>
<p>二者对比：</p>
<ul>
<li>用内的解决方案一般适用于服务提供者和服务消费者同属于一个技术体系；</li>
<li>应用外的解决方案一般适合服务提供者和服务消费者采用了不同技术体系的业务场景</li>
</ul>
<p>注册中心选型要考虑的两个问题</p>
<ul>
<li>高可用性</li>
<li>数据一致性
<ul>
<li>CP 型：牺牲可用性来保证数据强一致性。代表：ZooKeeper、Etcd、Consul</li>
<li>AP 型：代表：Eureka、Nacos</li>
</ul>
</li>
</ul>
<p>而对于注册中心来说，最主要的功能是服务的注册和发现，在网络出现问题的时候，可用性的需求要远远高于数据一致性。即使因为数据不一致，注册中心内引入了不可用的服务节点，也可以通过其他措施来避免，比如客户端的快速失败机制等，只要实现最终一致性，对于注册中心来说就足够了。因此，选择 AP 型注册中心，一般更加合适。</p>
<h2 id="14-开源-rpc-框架如何选型"><a class="markdownIt-Anchor" href="#14-开源-rpc-框架如何选型"></a> 14. 开源 RPC 框架如何选型？</h2>
<p>限定语言 RPC</p>
<ul>
<li>Dubbo：仅支持 Java</li>
<li>Motan：仅支持 Java</li>
<li>Tars：仅支持 C++</li>
<li>Spring Cloud：仅支持 Java</li>
</ul>
<p>跨语言 RPC</p>
<ul>
<li>gRPC：支持 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言</li>
<li>Thrift：支持 C++、Java、PHP、Python、Ruby、Erlang 等多种语言</li>
</ul>
<h2 id="15-如何搭建一个可靠的监控系统"><a class="markdownIt-Anchor" href="#15-如何搭建一个可靠的监控系统"></a> 15. 如何搭建一个可靠的监控系统？</h2>
<p>日志解决方案：<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/">ELK</a></p>
<p>时序数据库解决方案：<a target="_blank" rel="noopener" href="http://graphite.readthedocs.io/en/latest/index.html">Graphite</a>、<a target="_blank" rel="noopener" href="https://www.influxdata.com/time-series-platform/">TICK</a>和<a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a></p>
<h2 id="16-如何搭建一套适合你的服务追踪系统"><a class="markdownIt-Anchor" href="#16-如何搭建一套适合你的服务追踪系统"></a> 16. 如何搭建一套适合你的服务追踪系统？</h2>
<p>代表：Zipkin、PinPoint</p>
<h2 id="17-如何识别服务节点是否存活"><a class="markdownIt-Anchor" href="#17-如何识别服务节点是否存活"></a> 17. 如何识别服务节点是否存活？</h2>
<h3 id="171-心跳开关保护机制"><a class="markdownIt-Anchor" href="#171-心跳开关保护机制"></a> 17.1. 心跳开关保护机制</h3>
<p>问题：服务消费者同时并发访问注册中心获取最新服务信息导致注册中心带宽被打满</p>
<p>方案：需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。</p>
<h3 id="172-服务节点摘除保护机制"><a class="markdownIt-Anchor" href="#172-服务节点摘除保护机制"></a> 17.2. 服务节点摘除保护机制</h3>
<p>问题：服务提供者节点被大量摘除导致服务消费者没有足够的节点可以调用</p>
<p>方案：需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。</p>
<p>静态注册中心</p>
<h2 id="18-如何使用负载均衡算法"><a class="markdownIt-Anchor" href="#18-如何使用负载均衡算法"></a> 18. 如何使用负载均衡算法？</h2>
<h3 id="181-负载均衡算法"><a class="markdownIt-Anchor" href="#181-负载均衡算法"></a> 18.1. 负载均衡算法</h3>
<ul>
<li>
<p><strong>随机算法</strong></p>
</li>
<li>
<p><strong>轮询算法</strong></p>
</li>
<li>
<p><strong>加权轮询算法</strong></p>
</li>
<li>
<p><strong>最少活跃连接算法</strong></p>
</li>
<li>
<p><strong>一致性 hash 算法</strong></p>
</li>
</ul>
<h2 id="19-如何使用服务路由"><a class="markdownIt-Anchor" href="#19-如何使用服务路由"></a> 19. 如何使用服务路由？</h2>
<p><strong>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求</strong>。</p>
<p>服务路由的应用场景</p>
<ul>
<li><strong>分组调用</strong></li>
<li><strong>灰度发布</strong></li>
<li><strong>流量切换</strong></li>
<li><strong>读写分离</strong></li>
</ul>
<p>服务路由的规则</p>
<ul>
<li>条件路由
<ul>
<li>排除某个服务节点</li>
<li>白名单和黑名单功能</li>
<li>机房隔离</li>
<li>读写分离</li>
</ul>
</li>
<li>脚本路由</li>
</ul>
<p>服务路由的获取方式</p>
<ul>
<li>本地配置</li>
<li>配置中心管理</li>
<li>动态下发</li>
</ul>
<h2 id="20-服务端出现故障时该如何应对"><a class="markdownIt-Anchor" href="#20-服务端出现故障时该如何应对"></a> 20. 服务端出现故障时该如何应对？</h2>
<p>微服务故障种类</p>
<ul>
<li>集群故障。解决：流量控制
<ul>
<li>限流</li>
<li>降级</li>
</ul>
</li>
<li>单 IDC 故障。解决：多 IDC 部署、流量切换
<ul>
<li>多 IDC 部署
<ul>
<li>同城多活</li>
<li>异地多活</li>
</ul>
</li>
<li>流量切换
<ul>
<li>DNS 解析流量切换</li>
<li>RPC 流量切换</li>
</ul>
</li>
</ul>
</li>
<li>单机故障</li>
</ul>
<h2 id="21-服务调用失败时有哪些处理手段"><a class="markdownIt-Anchor" href="#21-服务调用失败时有哪些处理手段"></a> 21. 服务调用失败时有哪些处理手段？</h2>
<p>超时</p>
<p>重试</p>
<p>流量控制</p>
<h2 id="22-如何管理服务配置"><a class="markdownIt-Anchor" href="#22-如何管理服务配置"></a> 22. 如何管理服务配置？</h2>
<p>配置类型：</p>
<ul>
<li>本地配置</li>
<li>配置中心</li>
</ul>
<p>配置中心代表：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-config">Spring Cloud Config</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ctripcorp/apollo">Apollo</a></li>
</ul>
<h2 id="23-如何搭建微服务治理平台"><a class="markdownIt-Anchor" href="#23-如何搭建微服务治理平台"></a> 23. 如何搭建微服务治理平台？</h2>
<p>服务管理</p>
<ul>
<li>服务上下线</li>
<li>节点添加 / 删除</li>
<li>服务查询</li>
<li>服务节点查询。这个操作会调用注册中心的节点查询接口，来查询某个服务下一共有多少个节点。</li>
</ul>
<p>服务治理</p>
<ul>
<li>限流</li>
<li>降级</li>
<li>切流量</li>
</ul>
<p>服务监控</p>
<p>问题定位</p>
<p>日志查询</p>
<p>服务运维</p>
<ul>
<li>发布部署</li>
<li>弹性伸缩</li>
</ul>
<h2 id="24-微服务架构该如何落地"><a class="markdownIt-Anchor" href="#24-微服务架构该如何落地"></a> 24. 微服务架构该如何落地？</h2>
<p>（略）</p>
<h2 id="25-微服务为什么要容器化"><a class="markdownIt-Anchor" href="#25-微服务为什么要容器化"></a> 25. 微服务为什么要容器化？</h2>
<p>微服务引入的问题</p>
<p>设计复杂</p>
<p>测试复杂</p>
<p>运维困难</p>
<h2 id="26-微服务容器化运维镜像仓库和资源调度"><a class="markdownIt-Anchor" href="#26-微服务容器化运维镜像仓库和资源调度"></a> 26. 微服务容器化运维：镜像仓库和资源调度</h2>
<p>容器运维平台的组成部分</p>
<ul>
<li>镜像仓库</li>
<li>资源调度</li>
<li>容器调度</li>
<li>服务编排</li>
</ul>
<h2 id="27-微服务容器化运维容器调度和服务编排"><a class="markdownIt-Anchor" href="#27-微服务容器化运维容器调度和服务编排"></a> 27. 微服务容器化运维：容器调度和服务编排</h2>
<p>容器调度系统代表：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/">Swarm</a>、<a target="_blank" rel="noopener" href="http://mesos.apache.org/">Mesos</a>，<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a></p>
<p>容器调度要解决的问题</p>
<ul>
<li><strong>主机过滤</strong>
<ul>
<li>存活过滤</li>
<li>硬件过滤</li>
</ul>
</li>
<li><strong>调度策略</strong></li>
<li><strong>服务编排</strong></li>
<li><strong>服务依赖</strong>：代表方案：<a target="_blank" rel="noopener" href="https://github.com/docker/compose">Docker Compose</a></li>
<li><strong>服务发现</strong>
<ul>
<li>基于 Nginx 的服务发现</li>
<li>基于注册中心的服务发现</li>
<li>弹性伸缩</li>
</ul>
</li>
</ul>
<h2 id="28-微服务容器化运维微博容器运维平台-dcp"><a class="markdownIt-Anchor" href="#28-微服务容器化运维微博容器运维平台-dcp"></a> 28. 微服务容器化运维：微博容器运维平台 DCP</h2>
<h2 id="29-微服务如何实现-devops"><a class="markdownIt-Anchor" href="#29-微服务如何实现-devops"></a> 29. 微服务如何实现 DevOps？</h2>
<ul>
<li><strong>CI（Continuous Integration）</strong>，持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。
<ul>
<li>代码检查</li>
<li>单元测试</li>
<li>集成测试</li>
</ul>
</li>
<li><strong>CD（Continuous Deploy）</strong>，持续部署。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li>
</ul>
<h2 id="30-如何做好微服务容量规划"><a class="markdownIt-Anchor" href="#30-如何做好微服务容量规划"></a> 30. 如何做好微服务容量规划？</h2>
<p>微服务容量规划的问题</p>
<ul>
<li>服务数量众多</li>
<li>服务的接口表现差异巨大</li>
<li>服务部署的集群规模大小不同</li>
<li>服务之间还存在依赖关系</li>
</ul>
<p>容量规划系统的作用是<strong>根据各个微服务部署集群的最大容量和线上实际运行的负荷，来决定各个微服务是否需要弹性扩缩容，以及需要扩缩容多少台机器</strong>。</p>
<p>容量规划系统实施的关键在于两点：</p>
<ul>
<li>容量评估
<ul>
<li>选择合适的压测指标
<ul>
<li>系统类指标：CPU、内存、I/O、带宽等</li>
<li>服务类指标：响应时间、P999 耗时、错误率等</li>
</ul>
</li>
<li>压测获取单机的最大容量
<ul>
<li>单机压测
<ul>
<li>通过日志回放等手段，模拟线上流量来对单机进行压测；</li>
<li>通过 TCP-Copy 的方式，把线上机器的流量拷贝过来对单机进行压测。</li>
</ul>
</li>
<li>集群压测</li>
</ul>
</li>
<li>实时和获取集群的运行负荷</li>
</ul>
</li>
<li>调度决策
<ul>
<li>可以使用<strong>水位线</strong>来进行调度决策：当集群的水位线位于致命线以下时，就需要立即扩容，在扩容一定数量的机器后，水位线回到安全线以上并保持一段时间后，就可以进行缩容了。</li>
<li>扩容
<ul>
<li>按数量</li>
<li>按比例</li>
</ul>
</li>
<li>缩容</li>
<li>逐步缩容</li>
<li>为了避免因扩容、缩容导致的水位线抖动，可以多次采集水位线数据，超过 60% 数据满足库哦哦让条件，才真正触发扩容。</li>
</ul>
</li>
</ul>
<h2 id="31-微服务多机房部署实践"><a class="markdownIt-Anchor" href="#31-微服务多机房部署实践"></a> 31. 微服务多机房部署实践</h2>
<p>多机房负载均衡：利用七层负载均衡和四层负载均衡，将流量根据用户就近访问的原则切分流量。</p>
<h2 id="32-多机房数据同步"><a class="markdownIt-Anchor" href="#32-多机房数据同步"></a> 32. 多机房数据同步</h2>
<h4 id="主从机房架构"><a class="markdownIt-Anchor" href="#主从机房架构"></a> 主从机房架构</h4>
<ul>
<li>由主机房的处理机来更新本机房的缓存和数据库</li>
<li>其他机房的缓存也通过主机房的处理机来更新</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<h4 id="独立机房架构"><a class="markdownIt-Anchor" href="#独立机房架构"></a> 独立机房架构</h4>
<ul>
<li>每个机房的处理机接收到写请求后更新各自机房的缓存</li>
<li>只有主机房会更新数据库</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<p>WMB 消息同步组件的功能就是把一个机房的写请求发给另外一个机房</p>
<ul>
<li>reship，负责把本机房的写请求分发一份给别的机房。</li>
<li>collector，负责从别的机房读取写请求，然后再把请求转发给本机房的处理机。</li>
</ul>
<p>实现 WMB 的消息同步功能有两种方案：</p>
<ul>
<li>MQ：两个机房的 MQ 通过维护状态机来读写请求</li>
<li>RPC</li>
</ul>
<h4 id="多机房数据一致性"><a class="markdownIt-Anchor" href="#多机房数据一致性"></a> 多机房数据一致性</h4>
<h2 id="33-微服务混合云部署实践"><a class="markdownIt-Anchor" href="#33-微服务混合云部署实践"></a> 33. 微服务混合云部署实践</h2>
<h3 id="331-跨云服务的负载均衡"><a class="markdownIt-Anchor" href="#331-跨云服务的负载均衡"></a> 33.1. 跨云服务的负载均衡</h3>
<p>当服务上云后还需要考虑把一定比例的用户请求路由到云上部署的服务</p>
<h3 id="332-跨云服务的数据同步"><a class="markdownIt-Anchor" href="#332-跨云服务的数据同步"></a> 33.2. 跨云服务的数据同步</h3>
<p>私有云与公有云之间的网络隔离</p>
<p>一般来讲，出于安全的需要，企业内部机房同公有云机房之间的网络是隔离的，为了实现互通，需要架设专门的 VPN 网络或者专线。</p>
<p>数据库能否上云</p>
<p>数据库能否上云的关键取决于数据的隐私性。</p>
<h3 id="333-跨云服务的容器运维"><a class="markdownIt-Anchor" href="#333-跨云服务的容器运维"></a> 33.3. 跨云服务的容器运维</h3>
<p>跨云的主机管理：跨云主机管理的关键点在于，如何对内部私有云的机器和公有云的 ECS 进行管理，</p>
<p>跨云服务发现</p>
<p>跨云弹性扩容</p>
<p>跨云服务编排</p>
<h2 id="34-下一代微服务架构-service-mesh"><a class="markdownIt-Anchor" href="#34-下一代微服务架构-service-mesh"></a> 34. 下一代微服务架构 Service Mesh</h2>
<p>为什么需要 Service Mesh</p>
<ul>
<li>
<p>跨语言服务调用的需要</p>
</li>
<li>
<p>云原生应用服务治理的需要</p>
</li>
</ul>
<h2 id="35-service-mesh-的实现原理"><a class="markdownIt-Anchor" href="#35-service-mesh-的实现原理"></a> 35. Service Mesh 的实现原理</h2>
<p>Service Mesh 实现的关键点：</p>
<ul>
<li>轻量级网络代理 SideCar，它的作用就是转发服务之间的调用；</li>
<li>基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>请求路由</li>
<li>故障处理</li>
<li>安全认证</li>
<li>监控上报</li>
<li>日志记录</li>
<li>配额控制</li>
</ul>
<h2 id="36-istioservice-mesh-的代表产品"><a class="markdownIt-Anchor" href="#36-istioservice-mesh-的代表产品"></a> 36. Istio：Service Mesh 的代表产品</h2>
<h3 id="361-istio-整体架构"><a class="markdownIt-Anchor" href="#361-istio-整体架构"></a> 36.1. Istio 整体架构</h3>
<p>Istio 的架构可以说由两部分组成，分别是 Proxy 和 Control Plane。</p>
<ul>
<li>Proxy，就是前面提到的 SideCar，与应用程序部署在同一个主机上，应用程序之间的调用都通过 Proxy 来转发，目前支持 HTTP/1.1、HTTP/2、gRPC 以及 TCP 请求。</li>
<li>Control Plane，与 Proxy 通信，来实现各种服务治理功能，包括三个基本组件：Pilot、Mixer 以及 Citadel。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/8fd71c46.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/8fd71c46.html" class="post-title-link" itemprop="url">左耳听风学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 15:27:00" itemprop="dateCreated datePublished" datetime="2021-08-15T15:27:00+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/8fd71c46.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="8fd71c46.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>375</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="左耳听风学习笔记"><a class="markdownIt-Anchor" href="#左耳听风学习笔记"></a> 左耳听风学习笔记</h1>
<h2 id="洞悉技术的本质"><a class="markdownIt-Anchor" href="#洞悉技术的本质"></a> 洞悉技术的本质</h2>
<h2 id="分布式系统架构的本质"><a class="markdownIt-Anchor" href="#分布式系统架构的本质"></a> 分布式系统架构的本质</h2>
<p>分布式系统架构的优点：</p>
<ul>
<li>高性能</li>
<li>高可用</li>
</ul>
<p>分布式系统架构的缺点：</p>
<ul>
<li>设计复杂</li>
<li>运维复杂</li>
</ul>
<p>分布式系统的技术栈</p>
<p>提高性能的技术</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>异步</li>
<li>分片</li>
</ul>
<p>提供可用性的技术</p>
<ul>
<li>服务拆分</li>
<li>服务冗余</li>
<li>流量控制</li>
<li>高可用架构：多租户、多活架构、灾备</li>
<li>高可用运维：监控、DevOps</li>
</ul>
<p>分布式系统的关键技术</p>
<ul>
<li>服务治理</li>
<li>服务、资源调度</li>
<li>DevOps</li>
<li>监控</li>
</ul>
<h2 id="编程范式游记"><a class="markdownIt-Anchor" href="#编程范式游记"></a> 编程范式游记</h2>
<h2 id="分布式系统设计模式"><a class="markdownIt-Anchor" href="#分布式系统设计模式"></a> 分布式系统设计模式</h2>
<h2 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h2>
<h2 id="程序员练级攻略"><a class="markdownIt-Anchor" href="#程序员练级攻略"></a> 程序员练级攻略</h2>
<h2 id="面试攻略"><a class="markdownIt-Anchor" href="#面试攻略"></a> 面试攻略</h2>
<h2 id="高效学习"><a class="markdownIt-Anchor" href="#高效学习"></a> 高效学习</h2>
<p>浅度学习和深度学习</p>
<ul>
<li><strong>高质量的信息源和第一手的知识</strong>。</li>
<li><strong>把知识连成地图，将自己的理解反述出来</strong>。</li>
<li><strong>不断地反思和思辨，与不同年龄段的人讨论</strong>。</li>
<li><strong>举一反三，并践行之，把知识转换成技能</strong>。</li>
</ul>
<p>深度，归纳和坚持实践</p>
<ol>
<li><strong>这个技术出现的背景、初衷和目标</strong>。</li>
<li><strong>这个技术的优势和劣势分别是什么</strong></li>
<li><strong>这个技术适用的场景</strong></li>
<li><strong>技术的组成部分和关键点</strong>。</li>
<li><strong>技术的底层原理和关键实现</strong>。</li>
<li><strong>已有的实现和它之间的对比</strong>。</li>
</ol>
<h2 id="高效沟通"><a class="markdownIt-Anchor" href="#高效沟通"></a> 高效沟通</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/136dffe0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/136dffe0.html" class="post-title-link" itemprop="url">电商</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 23:42:12" itemprop="dateCreated datePublished" datetime="2021-08-05T23:42:12+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/136dffe0.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="136dffe0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>94</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电商"><a class="markdownIt-Anchor" href="#电商"></a> 电商</h1>
<h2 id="基本业务架构"><a class="markdownIt-Anchor" href="#基本业务架构"></a> 基本业务架构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210805222544.jpg" alt="img" /></p>
<h3 id="订单"><a class="markdownIt-Anchor" href="#订单"></a> 订单</h3>
<p>订单服务一般不主动调用其他服务</p>
<p>订单服务不负责和第三方集成</p>
<p>订单服务不提供优惠计算或成本分摊逻辑</p>
<h4 id="订单信息管理"><a class="markdownIt-Anchor" href="#订单信息管理"></a> 订单信息管理</h4>
<ul>
<li>用户</li>
<li>商品</li>
<li>收货人</li>
<li>收货地址</li>
<li>收货时间</li>
<li>订单状态</li>
</ul>
<h4 id="优惠券"><a class="markdownIt-Anchor" href="#优惠券"></a> 优惠券</h4>
<h2 id="典型问题"><a class="markdownIt-Anchor" href="#典型问题"></a> 典型问题</h2>
<p>秒杀活动</p>
<p>超卖</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/18d5e418.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/18d5e418.html" class="post-title-link" itemprop="url">高并发系统设计40问学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 23:42:00" itemprop="dateCreated datePublished" datetime="2021-08-05T23:42:00+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/18d5e418.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="18d5e418.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高并发系统设计-40-问学习笔记"><a class="markdownIt-Anchor" href="#高并发系统设计-40-问学习笔记"></a> 高并发系统设计 40 问学习笔记</h1>
<h2 id="1-基础篇"><a class="markdownIt-Anchor" href="#1-基础篇"></a> 1. 基础篇</h2>
<h3 id="11-高并发系统它的通用设计方法是什么"><a class="markdownIt-Anchor" href="#11-高并发系统它的通用设计方法是什么"></a> 1.1. 高并发系统：它的通用设计方法是什么？</h3>
<p>并发、异步、缓存</p>
<h3 id="12-架构分层我们为什么一定要这么做"><a class="markdownIt-Anchor" href="#12-架构分层我们为什么一定要这么做"></a> 1.2. 架构分层：我们为什么一定要这么做？</h3>
<p>分层架构典型代表：</p>
<ul>
<li>MVC（Model-View-Controller）</li>
<li>表现层、逻辑层和数据访问层</li>
<li>OSI 七层网络模型</li>
</ul>
<p>分层的好处</p>
<ul>
<li><strong>分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。</strong></li>
<li><strong>再有，分层之后可以做到很高的复用。</strong></li>
<li><strong>分层架构可以让我们更容易做横向扩展。</strong></li>
</ul>
<p>分层架构的不足</p>
<ul>
<li>增加了代码的复杂度</li>
</ul>
<h3 id="13-系统设计目标一如何提升系统性能"><a class="markdownIt-Anchor" href="#13-系统设计目标一如何提升系统性能"></a> 1.3. 系统设计目标（一）：如何提升系统性能？</h3>
<p>讲述了性能指标和性能量化方式。</p>
<h3 id="14-系统设计目标二系统怎样做到高可用"><a class="markdownIt-Anchor" href="#14-系统设计目标二系统怎样做到高可用"></a> 1.4. 系统设计目标（二）：系统怎样做到高可用？</h3>
<p>故障转移</p>
<ul>
<li>健康检查：心跳检测</li>
<li>选举：Paxos、Raft</li>
<li>负载均衡</li>
</ul>
<p>流量控制：</p>
<ul>
<li>超时与重试</li>
<li>限流</li>
<li>降级</li>
</ul>
<p>系统运维</p>
<ul>
<li>灰度发布</li>
<li>故障演练</li>
<li>CI/CD</li>
</ul>
<p>多活架构</p>
<h3 id="15-系统设计目标三如何让系统易于扩展"><a class="markdownIt-Anchor" href="#15-系统设计目标三如何让系统易于扩展"></a> 1.5. 系统设计目标（三）：如何让系统易于扩展？</h3>
<p><strong>拆分首先考虑的维度是业务维度</strong></p>
<p>其次，当吞吐量达到单机瓶颈，针对存储做水平差费</p>
<h2 id="2-数据库篇"><a class="markdownIt-Anchor" href="#2-数据库篇"></a> 2. 数据库篇</h2>
<h4 id="池化技术如何减少频繁创建数据库连接的性能损耗"><a class="markdownIt-Anchor" href="#池化技术如何减少频繁创建数据库连接的性能损耗"></a> 池化技术：如何减少频繁创建数据库连接的性能损耗？</h4>
<p>池化技术解决频繁创建连接、创建对象的成本</p>
<h3 id="21-数据库优化方案一查询请求增加时如何做主从分离"><a class="markdownIt-Anchor" href="#21-数据库优化方案一查询请求增加时如何做主从分离"></a> 2.1. 数据库优化方案（一）：查询请求增加时，如何做主从分离？</h3>
<p>读写分离：写入时只写主库，在读数据时只读从库。通常采用一主多从架构。</p>
<p>读写分离的问题：<strong>主从同步的延迟</strong></p>
<p>读写分离的关键：</p>
<ul>
<li>主从复制</li>
<li>读写流量分发</li>
<li>代理：Cobar、Mycat</li>
<li>客户端：sharding-jdbc、TDDL</li>
</ul>
<h3 id="22-数据库优化方案二写入数据量增加时如何实现分库分表"><a class="markdownIt-Anchor" href="#22-数据库优化方案二写入数据量增加时如何实现分库分表"></a> 2.2. 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？</h3>
<p>垂直拆分：从业务维度，将表分为不同的库</p>
<p>水平拆分：分区 key 是关键。应使用合理策略，分库分表。如：hash 取 mod 法、范围划分</p>
<h3 id="23-发号器如何保证分库分表后-id-的全局唯一性"><a class="markdownIt-Anchor" href="#23-发号器如何保证分库分表后-id-的全局唯一性"></a> 2.3. 发号器：如何保证分库分表后 ID 的全局唯一性？</h3>
<p>分布式 ID：UUID、Snowflake 算法</p>
<h3 id="24-nosql在高并发场景下数据库和-nosql-如何做到互补"><a class="markdownIt-Anchor" href="#24-nosql在高并发场景下数据库和-nosql-如何做到互补"></a> 2.4. NoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？</h3>
<p>LSM 树：牺牲了一定的读性能来换取写入数据的高性能，Hbase、Cassandra、LevelDB 都是用这种算法作为存储的引擎。</p>
<p>数据首先会写入到一个叫做 MemTable 的内存结构中，在 MemTable 中数据是按照写入的 Key 来排序的。为了防止 MemTable 里面的数据因为机器掉电或者重启而丢失，一般会通过写 Write Ahead Log 的方式将数据备份在磁盘上。</p>
<p>MemTable 在累积到一定规模时，它会被刷新生成一个新的文件，我们把这个文件叫做 SSTable（Sorted String Table）。当 SSTable 达到一定数量时，我们会将这些 SSTable 合并，减少文件的数量，因为 SSTable 都是有序的，所以合并的速度也很快。</p>
<p>当从 LSM 树里面读数据时，我们首先从 MemTable 中查找数据，如果数据没有找到，再从 SSTable 中查找数据。因为存储的数据都是有序的，所以查找的效率是很高的，只是因为数据被拆分成多个 SSTable，所以读取的效率会低于 B+ 树索引。</p>
<h2 id="3-缓存篇"><a class="markdownIt-Anchor" href="#3-缓存篇"></a> 3. 缓存篇</h2>
<h3 id="31-缓存数据库成为瓶颈后动态数据的查询要如何加速"><a class="markdownIt-Anchor" href="#31-缓存数据库成为瓶颈后动态数据的查询要如何加速"></a> 3.1. 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？</h3>
<p>缓存分类：静态缓存、进程内缓存、分布式缓存</p>
<h3 id="32-缓存的使用姿势一如何选择缓存的读写策略"><a class="markdownIt-Anchor" href="#32-缓存的使用姿势一如何选择缓存的读写策略"></a> 3.2. 缓存的使用姿势（一）：如何选择缓存的读写策略？</h3>
<h3 id="33-cache-aside旁路缓存策略"><a class="markdownIt-Anchor" href="#33-cache-aside旁路缓存策略"></a> 3.3. Cache Aside（旁路缓存）策略</h3>
<p>先写表，再写缓存，可能会导致缓存和数据库数据不一致</p>
<p>更新表，删除缓存 key；读数据时，从表中读取。</p>
<p><strong>读策略的步骤</strong></p>
<ul>
<li>从缓存中读取数据；</li>
<li>如果缓存命中，则直接返回数据；</li>
<li>如果缓存不命中，则从数据库中查询数据；</li>
<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>
</ul>
<p><strong>写策略的步骤</strong></p>
<ul>
<li>更新数据库中的记录；</li>
<li>删除缓存记录。</li>
</ul>
<p>Cache Aside 理论上还是有较小概率导致数据不一致。</p>
<p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</p>
<p><strong>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</strong></p>
<ol>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。</li>
</ol>
<h4 id="readwrite-through读穿-写穿策略"><a class="markdownIt-Anchor" href="#readwrite-through读穿-写穿策略"></a> Read/Write Through（读穿 / 写穿）策略</h4>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210155.jpg" alt="img" /></p>
<h3 id="34-write-back写回策略"><a class="markdownIt-Anchor" href="#34-write-back写回策略"></a> 3.4. Write Back（写回）策略</h3>
<p>核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210420.jpg" alt="img" /></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210511.jpg" alt="img" /></p>
<p>这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。</p>
<p>但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p>
<h3 id="35-缓存的使用姿势二缓存如何做到高可用"><a class="markdownIt-Anchor" href="#35-缓存的使用姿势二缓存如何做到高可用"></a> 3.5. 缓存的使用姿势（二）：缓存如何做到高可用？</h3>
<p><strong>分布式缓存的高可用方案</strong></p>
<ul>
<li>客户端方案：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</li>
<li>代理层方案：客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</li>
<li>服务度方案：Redis Sentinel 方案</li>
</ul>
<h3 id="36-缓存的使用姿势三缓存穿透了怎么办"><a class="markdownIt-Anchor" href="#36-缓存的使用姿势三缓存穿透了怎么办"></a> 3.6. 缓存的使用姿势（三）：缓存穿透了怎么办？</h3>
<p>缓存穿透解決方案：</p>
<ul>
<li>保存 null 值</li>
<li>布隆过滤器</li>
</ul>
<h2 id="4-消息队列篇"><a class="markdownIt-Anchor" href="#4-消息队列篇"></a> 4. 消息队列篇</h2>
<h3 id="41-消息队列秒杀时如何处理每秒上万次的下单请求"><a class="markdownIt-Anchor" href="#41-消息队列秒杀时如何处理每秒上万次的下单请求"></a> 4.1. 消息队列：秒杀时如何处理每秒上万次的下单请求？</h3>
<p>削峰、异步处理、系统解耦</p>
<h3 id="42-消息投递如何保证消息仅仅被消费一次"><a class="markdownIt-Anchor" href="#42-消息投递如何保证消息仅仅被消费一次"></a> 4.2. 消息投递：如何保证消息仅仅被消费一次？</h3>
<h3 id="43-系统架构每秒-1-万次请求的系统要做服务化拆分吗"><a class="markdownIt-Anchor" href="#43-系统架构每秒-1-万次请求的系统要做服务化拆分吗"></a> 4.3. 系统架构：每秒 1 万次请求的系统要做服务化拆分吗？</h3>
<p>系统中，使用的资源出现扩展性问题，尤其是数据库的连接数出现瓶颈；</p>
<p>大团队共同维护一套代码，带来研发效率的降低，和研发成本的提升；</p>
<p>系统部署成本越来越高。</p>
<h3 id="44-微服务架构微服务化后系统架构要如何改造"><a class="markdownIt-Anchor" href="#44-微服务架构微服务化后系统架构要如何改造"></a> 4.4. 微服务架构：微服务化后，系统架构要如何改造？</h3>
<p>服务拆分时要遵循哪些原则？</p>
<p>服务的边界如何确定？服务的粒度是怎样呢？</p>
<p>在服务化之后，会遇到哪些问题呢？我们又将如何来解决？</p>
<h2 id="5-分布式服务篇"><a class="markdownIt-Anchor" href="#5-分布式服务篇"></a> 5. 分布式服务篇</h2>
<h2 id="6-维护篇"><a class="markdownIt-Anchor" href="#6-维护篇"></a> 6. 维护篇</h2>
<h3 id="61-给系统加上眼睛服务端监控要怎么做"><a class="markdownIt-Anchor" href="#61-给系统加上眼睛服务端监控要怎么做"></a> 6.1. 给系统加上眼睛：服务端监控要怎么做？</h3>
<p>CPU、内存、磁盘、网络</p>
<p><strong>道路千万条，监控第一条，监控不到位，领导两行泪</strong></p>
<p>监控指标</p>
<p>采集方式</p>
<ul>
<li>Agent</li>
<li>埋点</li>
<li>日志</li>
</ul>
<p>处理和展示</p>
<h3 id="62-应用性能管理用户的使用体验应该如何监控"><a class="markdownIt-Anchor" href="#62-应用性能管理用户的使用体验应该如何监控"></a> 6.2. 应用性能管理：用户的使用体验应该如何监控？</h3>
<h3 id="63-压力测试怎样设计全链路压力测试平台"><a class="markdownIt-Anchor" href="#63-压力测试怎样设计全链路压力测试平台"></a> 6.3. 压力测试：怎样设计全链路压力测试平台？</h3>
<h3 id="64-配置管理成千上万的配置项要如何管理"><a class="markdownIt-Anchor" href="#64-配置管理成千上万的配置项要如何管理"></a> 6.4. 配置管理：成千上万的配置项要如何管理？</h3>
<ul>
<li>配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；</li>
<li>配置中心可以提供配置变更通知的功能，可以实现配置的热更新；</li>
<li>配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到 99.999%，甚至会是 99.9999%。</li>
</ul>
<h2 id="7-实战篇"><a class="markdownIt-Anchor" href="#7-实战篇"></a> 7. 实战篇</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/64f7c861.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/64f7c861.html" class="post-title-link" itemprop="url">分布式算法 Gossip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-13 09:18:41" itemprop="dateCreated datePublished" datetime="2021-07-13T09:18:41+08:00">2021-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">分布式理论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/64f7c861.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="64f7c861.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式算法-gossip"><a class="markdownIt-Anchor" href="#分布式算法-gossip"></a> 分布式算法 Gossip</h1>
<p>Gossip 也叫 Epidemic Protocol （流行病协议），这个协议基于<strong>最终一致性</strong>以及<strong>去中心化</strong>设计思想。主要用于<strong>分布式节点之间进行信息交换和数据同步</strong>，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络（去中心化）。</p>
<p>Gossip 协议最早是在 1987 年发表在 ACM 上的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出，其理论基础来源于流行病学的数学模型，这种场景的一个最大特点就是组成的网络的节点都是去中心化的对等节点，在信息同步过程中不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，实现最终一致性协议。</p>
<p>Gossip 协议是集群中节点相互通信的内部通信技术。 Gossip 是一种高效、轻量级、可靠的节点间广播协议，用于传播数据。它是去中心化的、“流行病”的、容错的和点对点通信协议。 Cassandra 使用八卦进行对等发现和元数据传播。</p>
<h2 id="1-应用"><a class="markdownIt-Anchor" href="#1-应用"></a> 1. 应用</h2>
<p>在 CASSANDRA 中，节点间使用 Gossip 协议交换信息，因此所有节点都可以快速了解集群中的所有其他节点。</p>
<p>Consul 使用名为 SERF 的 Gossip 协议有两个作用：</p>
<ul>
<li>发现新节点和宕机的节点</li>
<li>可靠且快速的事件广播，用于选举 Leader 等</li>
</ul>
<h2 id="2-gossip-协议的执行过程"><a class="markdownIt-Anchor" href="#2-gossip-协议的执行过程"></a> 2. Gossip 协议的执行过程</h2>
<p>Gossip 协议在概念上非常简单，代码也非常简单。它们背后的基本思想是：一个节点想要与网络中的其他节点共享一些信息。然后周期性地从节点集中随机选择一个节点并交换信息。接收信息的节点做同样的事情。信息定期发送到 N 个目标，N 称为扇出（<code>Fanout</code>）。</p>
<p>循环：传播信息的回合数<br />
扇出：一个节点在每个循环中闲聊的节点数。当一个节点想要广播一条消息时，它从系统中随机选择 t 个节点并将消息发送给它们。</p>
<p><strong>Gossip 协议的执行过程</strong>：</p>
<p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p>
<p><strong>为了表述清楚，我们先做一些前提设定</strong></p>
<ul>
<li><strong>种子节点</strong>周期性的散播消息，把周期限定为 1 秒</li>
<li>被感染节点随机选择 N 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。</li>
<li>节点只接收消息不反馈结果。</li>
<li>每次散播消息都选择<strong>尚未发送过的节点</strong>进行散播</li>
<li>收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。</li>
</ul>
<p>注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。<strong>异步是它的优点，而消息冗余则是它的缺点</strong>。</p>
<p>Goosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个<strong>最终一致性</strong>协议。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210708234308.gif" alt="img" /></p>
<h2 id="3-gossip-的特点"><a class="markdownIt-Anchor" href="#3-gossip-的特点"></a> 3. Gossip 的特点</h2>
<h3 id="31-gossip-的优点"><a class="markdownIt-Anchor" href="#31-gossip-的优点"></a> 3.1. Gossip 的优点</h3>
<ul>
<li><strong>扩展性</strong>：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</li>
<li><strong>容错</strong>：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</li>
<li><strong>去中心化</strong>：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li>
<li><strong>一致性收敛</strong>：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</li>
<li><strong>简单</strong>：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</li>
</ul>
<h3 id="32-gossip-的缺陷"><a class="markdownIt-Anchor" href="#32-gossip-的缺陷"></a> 3.2. Gossip 的缺陷</h3>
<p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p>
<ul>
<li><strong>消息的延迟</strong>：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</li>
<li><strong>消息冗余</strong>：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。</li>
</ul>
<h2 id="4-gossip-类型"><a class="markdownIt-Anchor" href="#4-gossip-类型"></a> 4. Gossip 类型</h2>
<p>Gossip 有两种类型：</p>
<ul>
<li><strong>Anti-Entropy(反熵)</strong>：以固定的概率传播所有的数据。Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。</li>
<li><strong>Rumor-Mongering(谣言传播)</strong>：仅传播新到达的数据。Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。</li>
</ul>
<p>熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致。</p>
<p>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p>
<p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p>
<p>但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p>
<p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p>
<p>一般来说，为了在通信代价和可靠性之间取得折中，需要将这两种方法结合使用。</p>
<p><strong>Gossip 中的通信模式</strong></p>
<p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p>
<ul>
<li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li>
<li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li>
<li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li>
</ul>
<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf">Epidemic Algorithms for Replicated Database Maintenance</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议</a></li>
<li><a target="_blank" rel="noopener" href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/">INTRODUCTION TO GOSSIP</a></li>
<li><a target="_blank" rel="noopener" href="https://flopezluis.github.io/gossip-simulator/">Goosip 协议仿真动画</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jimmy"
      src="/images/avatar2.gif">
  <p class="site-author-name" itemprop="name">Jimmy</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ichunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ichunhui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hustzch@163.com" title="E-Mail → mailto:hustzch@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备17019300号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jimmy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jimmyblog-2.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
