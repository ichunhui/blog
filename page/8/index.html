<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ichunhui.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不忘初心，方得始终.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy&#39;s Blog">
<meta property="og:url" content="https://ichunhui.github.io/page/8/index.html">
<meta property="og:site_name" content="Jimmy&#39;s Blog">
<meta property="og:description" content="不忘初心，方得始终.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jimmy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ichunhui.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jimmy's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Jimmy's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jimmy's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">靡不有初，鲜克有终.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">192</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">114</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">41</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/ichunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/8c71b936.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/8c71b936.html" class="post-title-link" itemprop="url">Mysql 索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 11:14:07" itemprop="dateCreated datePublished" datetime="2020-07-16T11:14:07+08:00">2020-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/8c71b936.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="8c71b936.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-索引"><a class="markdownIt-Anchor" href="#mysql-索引"></a> Mysql 索引</h1>
<blockquote>
<p>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200715172009.png" alt="img" /></p>
<h2 id="1-索引简介"><a class="markdownIt-Anchor" href="#1-索引简介"></a> 1. 索引简介</h2>
<p><strong>索引是数据库为了提高查找效率的一种数据结构</strong>。</p>
<p>索引对于良好的性能非常关键，在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，索引优化应该是查询性能优化的最有效手段。</p>
<h3 id="11-索引的优缺点"><a class="markdownIt-Anchor" href="#11-索引的优缺点"></a> 1.1. 索引的优缺点</h3>
<p>B 树是最常见的索引，按照顺序存储数据，所以 Mysql 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B 树也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p>
<p>✔ 索引的优点：</p>
<ul>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong>，从而加快检索速度。</li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong>。</li>
<li><strong>索引可以将随机 I/O 变为顺序 I/O</strong>。</li>
<li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>❌ 索引的缺点：</p>
<ul>
<li><strong>创建和维护索引要耗费时间</strong>，这会随着数据量的增加而增加。</li>
<li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li><strong>写操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低</strong>。</li>
</ul>
<h3 id="12-何时使用索引"><a class="markdownIt-Anchor" href="#12-何时使用索引"></a> 1.2. 何时使用索引</h3>
<blockquote>
<p>索引能够轻易将查询性能提升几个数量级。</p>
</blockquote>
<p>✔ 什么情况<strong>适用</strong>索引：</p>
<ul>
<li><strong>频繁读操作（ <code>SELECT</code> ）</strong></li>
<li><strong>表的数据量比较大</strong>。</li>
<li><strong>列名经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</strong>。</li>
</ul>
<p>❌ 什么情况<strong>不适用</strong>索引：</p>
<ul>
<li><strong>频繁写操作</strong>（ <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> ），也就意味着需要更新索引。</li>
<li><strong>列名不经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</strong>，也就意味着索引会经常无法命中，没有意义，还增加空间开销。</li>
<li><strong>非常小的表</strong>，对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li><strong>特大型的表</strong>，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
</ul>
<h2 id="2-索引的数据结构"><a class="markdownIt-Anchor" href="#2-索引的数据结构"></a> 2. 索引的数据结构</h2>
<p>在 Mysql 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准；不同存储引擎的索引的数据结构也不相同。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<p>数组是用连续的内存空间来存储数据，并且支持随机访问。</p>
<p>有序数组可以使用二分查找法，其时间复杂度为 <code>O(log n)</code>，无论是等值查询还是范围查询，都非常高效。</p>
<p>但数组有两个重要限制：</p>
<ul>
<li>数组的空间大小固定，如果要扩容只能采用复制数组的方式。</li>
<li>插入、删除时间复杂度为 <code>O(n)</code>。</li>
</ul>
<p>这意味着，如果使用数组作为索引，如果要保证数组有序，其更新操作代价高昂。</p>
<h3 id="21-哈希索引"><a class="markdownIt-Anchor" href="#21-哈希索引"></a> 2.1. 哈希索引</h3>
<p>哈希表是一种以键 - 值（key-value）对形式存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。</p>
<p><strong>哈希表</strong> 使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。哈希表的本质是一个数组，其思路是：使用 Hash 函数将 Key 转换为数组下标，利用数组的随机访问特性，使得我们能在 <code>O(1)</code> 的时间代价内完成检索。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320201844.png" alt="img" /></p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射 数据结构的实现之一，用于存储键值对。</li>
</ul>
<p>哈希索引基于哈希表实现，<strong>只适用于等值查询</strong>。对于每一行数据，哈希索引都会将所有的索引列计算一个哈希码（<code>hashcode</code>），哈希码是一个较小的值。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在 Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<p>✔ 哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>❌ 哈希索引的<strong>缺点</strong>：</p>
<ul>
<li>哈希索引值包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li><strong>哈希索引数据不是按照索引值顺序存储的</strong>，所以<strong>无法用于排序</strong>。</li>
<li>哈希索引<strong>不支持部分索引匹配查找</strong>，因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引<strong>只支持等值比较查询</strong>，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；不支持任何范围查询，如 <code>WHERE price &gt; 100</code>。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong>
<ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。</p>
</blockquote>
<h3 id="22-b-树索引"><a class="markdownIt-Anchor" href="#22-b-树索引"></a> 2.2. B 树索引</h3>
<p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的<code>B+Tree</code>。</p>
<p><code>B+Tree</code>中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h4 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h4>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 $$O(log(N))$$。</p>
<p>当然为了维持 $$O(log(N))$$ 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 $$O(log(N))$$。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h4 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> B+ 树</h4>
<p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解<code>B+Tree</code>时，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的<code>B+Tree</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200304235424.jpg" alt="img" /></p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>聚簇索引（clustered）</strong>：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。<strong>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary）</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快</strong>。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</p>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="23-全文索引"><a class="markdownIt-Anchor" href="#23-全文索引"></a> 2.3. 全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="24-空间数据索引"><a class="markdownIt-Anchor" href="#24-空间数据索引"></a> 2.4. 空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="3-索引的类型"><a class="markdownIt-Anchor" href="#3-索引的类型"></a> 3. 索引的类型</h2>
<p>主流的关系型数据库一般都支持以下索引类型：</p>
<h3 id="31-主键索引primary"><a class="markdownIt-Anchor" href="#31-主键索引primary"></a> 3.1. 主键索引（<code>PRIMARY</code>）</h3>
<p>主键索引：一种特殊的唯一索引，不允许有空值。一个表只能有一个主键（在 InnoDB 中本质上即聚簇索引），一般是在建表的时候同时创建主键索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="32-唯一索引unique"><a class="markdownIt-Anchor" href="#32-唯一索引unique"></a> 3.2. 唯一索引（<code>UNIQUE</code>）</h3>
<p>唯一索引：<strong>索引列的值必须唯一，但允许有空值</strong>。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">UNIQUE</span> indexName (title(length))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="33-普通索引index"><a class="markdownIt-Anchor" href="#33-普通索引index"></a> 3.3. 普通索引（<code>INDEX</code>）</h3>
<p>普通索引：最基本的索引，没有任何限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    ...</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="34-全文索引fulltext"><a class="markdownIt-Anchor" href="#34-全文索引fulltext"></a> 3.4. 全文索引（<code>FULLTEXT</code>）</h3>
<p>全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</p>
<p>全文索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 WHERE 语句的参数匹配。全文索引配合 <code>match against</code> 操作使用，而不是一般的 WHERE 语句加 LIKE。它可以在 <code>CREATE TABLE</code>，<code>ALTER TABLE</code> ，<code>CREATE INDEX</code> 使用，不过目前只有 <code>char</code>、<code>varchar</code>，<code>text</code> 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 <code>CREATE INDEX</code> 创建全文索引，要比先为一张表建立全文索引然后再将数据写入的速度快很多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    `content` text <span class="type">CHARACTER</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ...</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="35-联合索引"><a class="markdownIt-Anchor" href="#35-联合索引"></a> 3.5. 联合索引</h3>
<p>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    ...</span><br><span class="line">    INDEX index_name (title(length), title(length), ...)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="4-索引的策略"><a class="markdownIt-Anchor" href="#4-索引的策略"></a> 4. 索引的策略</h2>
<p>假设有以下表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<h3 id="41-索引基本原则"><a class="markdownIt-Anchor" href="#41-索引基本原则"></a> 4.1. 索引基本原则</h3>
<ul>
<li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li>
<li>要<strong>尽量避免冗余和重复索引</strong>。</li>
<li>要<strong>考虑删除未使用的索引</strong>。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。</li>
<li><strong>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引</strong>。</li>
</ul>
<h3 id="42-独立的列"><a class="markdownIt-Anchor" href="#42-独立的列"></a> 4.2. 独立的列</h3>
<p><strong>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p>
<p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>如果查询中的列不是独立的列，则数据库不会使用索引。</p>
<p>❌ 错误示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> TO_DAYS(<span class="built_in">current_date</span>) <span class="operator">-</span> TO_DAYS(date_col) <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="43-覆盖索引"><a class="markdownIt-Anchor" href="#43-覆盖索引"></a> 4.3. 覆盖索引</h3>
<p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要回表查询数据。</strong></p>
<p>【示例】范围查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>需要执行几次树的搜索操作，会扫描多少行？</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。索引包含所有需要查询的字段的值，称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="44-使用索引来排序"><a class="markdownIt-Anchor" href="#44-使用索引来排序"></a> 4.4. 使用索引来排序</h3>
<p>Mysql 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。</p>
<p><strong>索引最好既满足排序，又用于查找行</strong>。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。</p>
<p>这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引 (city,name,age) 找到第一个满足 city='杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。</li>
</ol>
<h3 id="45-前缀索引"><a class="markdownIt-Anchor" href="#45-前缀索引"></a> 4.5. 前缀索引</h3>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p>
<p>这时，可以使用前缀索引，即只索引开始的部分字符，这样可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。但这样也<strong>会降低索引的选择性</strong>。对于 <code>BLOB</code>/<code>TEXT</code>/<code>VARCHAR</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p><strong>索引的选择性</strong>是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。</p>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>那么，如何确定前缀索引合适的长度呢？</p>
<p>可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>当然，<strong>使用前缀索引很可能会损失区分度</strong>，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<p>此外，<strong><code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引</strong>。</p>
<h3 id="46-最左前缀匹配原则"><a class="markdownIt-Anchor" href="#46-最左前缀匹配原则"></a> 4.6. 最左前缀匹配原则</h3>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>MySQL 会一直向右匹配直到遇到范围查询 <code>(&gt;,&lt;,BETWEEN,LIKE)</code> 就停止匹配。</p>
<ul>
<li>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<strong>联合索引</strong>。</li>
<li>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询(&gt;、&lt;、between、like 左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>
<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>
</ul>
<p><strong>不要为每个列都创建独立索引</strong>。</p>
<p><strong>将选择性高的列或基数大的列优先排在多列索引最前列</strong>。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<p>例如：<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。</p>
<p>让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>
<h3 id="47-和-in-可以乱序"><a class="markdownIt-Anchor" href="#47-和-in-可以乱序"></a> 4.7. = 和 in 可以乱序</h3>
<p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p>
<h2 id="5-索引最佳实践"><a class="markdownIt-Anchor" href="#5-索引最佳实践"></a> 5. 索引最佳实践</h2>
<p>创建了索引，并非一定有效。比如不满足前缀索引、最左前缀匹配原则、查询条件涉及函数计算等情况都无法使用索引。此外，即使 SQL 本身符合索引的使用条件，MySQL 也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。</p>
<p>因此，在尝试通过索引进行 SQL 性能优化的时候，务必通过执行计划（<code>EXPLAIN</code>）或实际的效果来确认索引是否能有效改善性能问题，否则增加了索引不但没解决性能问题，还增加了数据库增删改的负担。如果对 EXPLAIN 给出的执行计划有疑问的话，你还可以利用 <code>optimizer_trace</code> 查看详细的执行计划做进一步分析。</p>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/d1955f63.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/d1955f63.html" class="post-title-link" itemprop="url">Redis 面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-13 17:03:42" itemprop="dateCreated datePublished" datetime="2020-07-13T17:03:42+08:00">2020-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/d1955f63.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="d1955f63.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-面试总结"><a class="markdownIt-Anchor" href="#redis-面试总结"></a> Redis 面试总结</h1>
<h2 id="redis-数据类型"><a class="markdownIt-Anchor" href="#redis-数据类型"></a> Redis 数据类型</h2>
<p>【问题】</p>
<ul>
<li>Redis 有哪些数据类型？</li>
<li>Redis 的数据类型分别适用于什么样的场景？</li>
</ul>
<hr />
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 数据类型和应用</em></strong></p>
<p>数据类型的特性和应用细节点较多，详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-datatype.md">Redis 数据类型</a></p>
</blockquote>
<p>（1）Redis 支持五种基本数据类型：</p>
<ul>
<li>String：常用于 KV 缓存</li>
<li>Hash：存储结构化数据，如：产品信息、用户信息等。</li>
<li>List：存储列表，如：粉丝列表、文章评论列表等。可以通过 lrange 命令进行分页查询。</li>
<li>Set：存储去重列表，如：粉丝列表等。可以基于 set 玩儿交集、并集、差集的操作。例如：求两个人的共同好友列表。</li>
<li>Sorted Set：存储含评分的去重列表，如：各种排行榜。</li>
</ul>
<p>（2）除此以外，还有 Bitmaps、HyperLogLogs、GEO、Streams 等高级数据类型。</p>
<h2 id="redis-内存淘汰"><a class="markdownIt-Anchor" href="#redis-内存淘汰"></a> Redis 内存淘汰</h2>
<p>【问题】</p>
<ul>
<li>Redis 有哪些内存淘汰策略？</li>
<li>这些淘汰策略分别适用于什么场景？</li>
<li>Redis 有哪些删除失效 key 的方法？</li>
<li>如何设置 Redis 中键的过期时间？</li>
<li>如果让你实现一个 LRU 算法，怎么做？</li>
</ul>
<hr />
<p>【解答】</p>
<p>（1）Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li>消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。</li>
<li>主动方法（active way），定期从设置了失效时间的主键中选择一部分失效的主键删除。</li>
</ul>
<p>（2）Redis 内存淘汰策略：</p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<p>（3）如何选择内存淘汰策略：</p>
<ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code>。</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li><code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</li>
<li>将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</li>
</ul>
<p>（4）LRU 算法实现思路：可以继承 LinkedHashMap，并覆写 removeEldestEntry 方法来实现一个最简单的 LRUCache</p>
<h2 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> Redis 持久化</h2>
<p>【问题】</p>
<ul>
<li>Redis 有几种持久化方式？</li>
<li>Redis 的不同持久化方式的特性和原理是什么？</li>
<li>RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？</li>
<li>Redis 执行持久化时，可以处理请求吗？</li>
<li>AOF 有几种同步频率？</li>
</ul>
<hr />
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 持久化</em></strong></p>
<p>详情可以参考：<a href="04.Redis%E6%8C%81%E4%B9%85%E5%8C%96.md">Redis 持久化</a></p>
</blockquote>
<p>（1）Redis 支持两种持久化方式：RDB 和 AOF。</p>
<p>（2）RDB 即某一时刻的二进制数据快照。</p>
<p>Redis 会周期性生成 RDB 文件。</p>
<p>生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。</p>
<p>RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。</p>
<p>（3）AOF 会将写命令不断追加到 AOF 文本日志末尾。</p>
<p>AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。</p>
<p>一般，AOF 设置 <code>appendfsync</code> 同步频率为 <strong><code>everysec</code></strong> 即可。</p>
<p>（4）RDB or AOF</p>
<p>建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<h2 id="redis-事务"><a class="markdownIt-Anchor" href="#redis-事务"></a> Redis 事务</h2>
<p>【问题】</p>
<ul>
<li>Redis 的并发竞争问题是什么？如何解决这个问题？</li>
<li>Redis 支持事务吗？</li>
<li>Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。</li>
<li>Redis 事务如何工作？</li>
<li>了解 Redis 事务中的 CAS 行为吗？</li>
</ul>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 的事务特性、原理</em></strong></p>
<p>详情参考：<a href="02.Redis%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.md#%E5%85%ADredis-%E4%BA%8B%E5%8A%A1">Redis 应用指南之 事务</a></p>
</blockquote>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
<p>Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h2 id="redis-管道"><a class="markdownIt-Anchor" href="#redis-管道"></a> Redis 管道</h2>
<p>【问题】</p>
<ul>
<li>除了事务，还有其他批量执行 Redis 命令的方式吗？</li>
</ul>
<p>【解答】</p>
<p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
<h2 id="redis-高并发"><a class="markdownIt-Anchor" href="#redis-高并发"></a> Redis 高并发</h2>
<p>【问题】</p>
<ul>
<li>Redis 是单线程模型，为何吞吐量还很高？</li>
<li>Redis 的 IO 多路复用原理是什么？</li>
<li>Redis 集群如何分片和寻址？</li>
<li>Redis 集群如何扩展？</li>
<li>Redis 集群如何保证数据一致？</li>
<li>Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？</li>
</ul>
<hr />
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 集群</em></strong></p>
<p>详情可以参考：<a href="07.Redis%E9%9B%86%E7%BE%A4.md">Redis 集群</a></p>
</blockquote>
<p>（1）单线程</p>
<p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。</p>
<p>Redis 单线程模型，依然有很高的并发吞吐，原因在于：</p>
<ul>
<li>Redis 读写都是内存操作。</li>
<li>Redis 基于<strong>非阻塞的 IO 多路复用机制</strong>，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</li>
<li>单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。</li>
</ul>
<p>（2）扩展并发吞吐量、存储容量</p>
<p>Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。</p>
<p>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。</p>
<p>一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。</p>
<p>进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。</p>
<p>（3）Redis 集群数据一致性</p>
<p>Redis 集群基于复制特性实现节点间的数据一致性。</p>
<h2 id="redis-复制"><a class="markdownIt-Anchor" href="#redis-复制"></a> Redis 复制</h2>
<p>【问题】</p>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
<hr />
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 复制</em></strong></p>
<p>详情可以参考：<a href="05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></p>
</blockquote>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> 用于断线后重复制。
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
</li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ul>
<li>步骤 1. 设置主从服务器</li>
<li>步骤 2. 主从服务器建立 TCP 连接。</li>
<li>步骤 3. 发送 PING 检查通信状态。</li>
<li>步骤 4. 身份验证。</li>
<li>步骤 5. 发送端口信息。</li>
<li>步骤 6. 同步。</li>
<li>步骤 7. 命令传播。</li>
</ul>
<h2 id="redis-哨兵"><a class="markdownIt-Anchor" href="#redis-哨兵"></a> Redis 哨兵</h2>
<p>【问题】</p>
<ul>
<li>Redis 如何实现高可用？</li>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
<hr />
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 哨兵</em></strong></p>
<p>详情可以参考：<a href="06.Redis%E5%93%A8%E5%85%B5.md">Redis 哨兵</a></p>
</blockquote>
<p>（1）Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<p>由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png" alt="img" /></p>
<h2 id="redis-vs-memcached"><a class="markdownIt-Anchor" href="#redis-vs-memcached"></a> Redis vs. Memcached</h2>
<p>【问题】</p>
<p>Redis 和 Memcached 有什么区别？</p>
<p>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</p>
<p>Redis 和 Memcached 各自的线程模型是怎样的？</p>
<p>为什么单线程的 Redis 性能却不输于多线程的 Memcached？</p>
<p>【解答】</p>
<p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。</p>
<p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中</p>
<p>redis 的速度比 memcached 快很多</p>
<p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis与Memcached的区别与比较" /></p>
<p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached 与 Redis》</strong>：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/23549">www.imooc.com/article/23549</a></p>
<p><strong>终极策略：</strong> 使用 Redis 的 String 类型做的事，都可以用 Memcached 替换，以此换取更好的性能提升； 除此以外，优先考虑 Redis；</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66">面试中关于 Redis 的问题看这篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98">advanced-java</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/d801015e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/d801015e.html" class="post-title-link" itemprop="url">Mysql 应用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-13 10:08:37" itemprop="dateCreated datePublished" datetime="2020-07-13T10:08:37+08:00">2020-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/d801015e.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="d801015e.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-应用指南"><a class="markdownIt-Anchor" href="#mysql-应用指南"></a> Mysql 应用指南</h1>
<h2 id="1-sql-执行过程"><a class="markdownIt-Anchor" href="#1-sql-执行过程"></a> 1. SQL 执行过程</h2>
<p>学习 Mysql，最好是先从宏观上了解 Mysql 工作原理。</p>
<blockquote>
<p>参考：<a href="docs/sql/mysql/mysql-index.md">Mysql 工作流</a></p>
</blockquote>
<h2 id="2-存储引擎"><a class="markdownIt-Anchor" href="#2-存储引擎"></a> 2. 存储引擎</h2>
<p>在文件系统中，Mysql 将每个数据库（也可以成为 schema）保存为数据目录下的一个子目录。创建表示，Mysql 会在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。因为 Mysql 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体平台密切相关。Windows 中大小写不敏感；类 Unix 中大小写敏感。<strong>不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 Mysql 服务层统一处理的。</strong></p>
<h3 id="21-选择存储引擎"><a class="markdownIt-Anchor" href="#21-选择存储引擎"></a> 2.1. 选择存储引擎</h3>
<h4 id="mysql-内置的存储引擎"><a class="markdownIt-Anchor" href="#mysql-内置的存储引擎"></a> Mysql 内置的存储引擎</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW ENGINES;</span></span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>InnoDB</strong> - Mysql 的默认事务型存储引擎，并且提供了行级锁和外键的约束。性能不错且支持自动崩溃恢复。</li>
<li><strong>MyISAM</strong> - Mysql 5.1 版本前的默认存储引擎。特性丰富但不支持事务，也不支持行级锁和外键，也没有崩溃恢复功能。</li>
<li><strong>CSV</strong> - 可以将 CSV 文件作为 Mysql 的表来处理，但这种表不支持索引。</li>
<li><strong>Memory</strong> - 适合快速访问数据，且数据不会被修改，重启丢失也没有关系。</li>
<li><strong>NDB</strong> - 用于 Mysql 集群场景。</li>
</ul>
<h4 id="如何选择合适的存储引擎"><a class="markdownIt-Anchor" href="#如何选择合适的存储引擎"></a> 如何选择合适的存储引擎</h4>
<p>大多数情况下，InnoDB 都是正确的选择，除非需要用到 InnoDB 不具备的特性。</p>
<p>如果应用需要选择 InnoDB 以外的存储引擎，可以考虑以下因素：</p>
<ul>
<li>事务：如果需要支持事务，InnoDB 是首选。如果不需要支持事务，且主要是 SELECT 和 INSERT 操作，MyISAM 是不错的选择。所以，如果 Mysql 部署方式为主备模式，并进行读写分离。那么可以这么做：主节点只支持写操作，默认引擎为 InnoDB；备节点只支持读操作，默认引擎为 MyISAM。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。所以，InnoDB 并发性能更高。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h4 id="转换表的存储引擎"><a class="markdownIt-Anchor" href="#转换表的存储引擎"></a> 转换表的存储引擎</h4>
<p>下面的语句可以将 mytable 表的引擎修改为 InnoDB</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable ENGINE <span class="operator">=</span> InnoDB</span><br></pre></td></tr></table></figure>
<h3 id="22-myisam"><a class="markdownIt-Anchor" href="#22-myisam"></a> 2.2. MyISAM</h3>
<p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。</p>
<p>MyISAM 引擎使用 B+Tree 作为索引结构，<strong>叶节点的 data 域存放的是数据记录的地址</strong>。</p>
<p>MyISAM 提供了大量的特性，包括：全文索引、压缩表、空间函数等。但是，MyISAM 不支持事务和行级锁。并且 MyISAM 不支持崩溃后的安全恢复。</p>
<h3 id="23-innodb"><a class="markdownIt-Anchor" href="#23-innodb"></a> 2.3. InnoDB</h3>
<p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。</p>
<p>然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而<strong>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构</strong>，这棵树的叶节点 data 域保存了完整的数据记录。这个<strong>索引的 key 是数据表的主键</strong>，因此<strong>InnoDB 表数据文件本身就是主索引</strong>。</p>
<p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）防止幻读。</p>
<p>InnoDB 是基于聚簇索引建立的，与其他存储引擎有很大不同。在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型"></a> 3. 数据类型</h2>
<h3 id="31-整型"><a class="markdownIt-Anchor" href="#31-整型"></a> 3.1. 整型</h3>
<p><code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code> 分别使用 <code>8</code>, <code>16</code>, <code>24</code>, <code>32</code>, <code>64</code> 位存储空间，一般情况下越小的列越好。</p>
<p><strong><code>UNSIGNED</code> 表示不允许负值，大致可以使正数的上限提高一倍</strong>。</p>
<p><code>INT(11)</code> 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h3 id="32-浮点型"><a class="markdownIt-Anchor" href="#32-浮点型"></a> 3.2. 浮点型</h3>
<p><code>FLOAT</code> 和 <code>DOUBLE</code> 为浮点类型。</p>
<p><code>DECIMAL</code> 类型主要用于精确计算，代价较高，应该尽量只在对小数进行精确计算时才使用 <code>DECIMAL</code> ——例如存储财务数据。数据量比较大的时候，可以使用 <code>BIGINT</code> 代替 <code>DECIMAL</code>。</p>
<p><code>FLOAT</code>、<code>DOUBLE</code> 和 <code>DECIMAL</code> 都可以指定列宽，例如 <code>DECIMAL(18, 9)</code> 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h3 id="33-字符串"><a class="markdownIt-Anchor" href="#33-字符串"></a> 3.3. 字符串</h3>
<p>主要有 <code>CHAR</code> 和 <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。</p>
<p><strong><code>VARCHAR</code> 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长</strong>。当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p><code>VARCHAR</code> 会保留字符串末尾的空格，而 <code>CHAR</code> 会删除。</p>
<h3 id="34-时间和日期"><a class="markdownIt-Anchor" href="#34-时间和日期"></a> 3.4. 时间和日期</h3>
<p>MySQL 提供了两种相似的日期时间类型：<code>DATATIME</code> 和 <code>TIMESTAMP</code>。</p>
<h4 id="datatime"><a class="markdownIt-Anchor" href="#datatime"></a> DATATIME</h4>
<p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h4 id="timestamp"><a class="markdownIt-Anchor" href="#timestamp"></a> TIMESTAMP</h4>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h3 id="35-blob-和-text"><a class="markdownIt-Anchor" href="#35-blob-和-text"></a> 3.5. BLOB 和 TEXT</h3>
<p><code>BLOB</code> 和 <code>TEXT</code> 都是为了存储大的数据而设计，前者存储二进制数据，后者存储字符串数据。</p>
<p>不能对 <code>BLOB</code> 和 <code>TEXT</code> 类型的全部内容进行排序、索引。</p>
<h3 id="36-枚举类型"><a class="markdownIt-Anchor" href="#36-枚举类型"></a> 3.6. 枚举类型</h3>
<p>大多数情况下没有使用枚举类型的必要，其中一个缺点是：枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用<code>ALTER TABLE</code>（如果只只是在列表末尾追加元素，不需要重建表）。</p>
<h3 id="37-类型的选择"><a class="markdownIt-Anchor" href="#37-类型的选择"></a> 3.7. 类型的选择</h3>
<ul>
<li>
<p>整数类型通常是标识列最好的选择，因为它们很快并且可以使用 <code>AUTO_INCREMENT</code>。</p>
</li>
<li>
<p><code>ENUM</code> 和 <code>SET</code> 类型通常是一个糟糕的选择，应尽量避免。</p>
</li>
<li>
<p>应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 <code>MD5</code>、<code>SHA</code>、<code>UUID</code> 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 <code>INSERT</code> 以及一些 <code>SELECT</code> 语句变得很慢。</p>
<ul>
<li>如果存储 UUID ，应该移除 <code>-</code> 符号；更好的做法是，用 <code>UNHEX()</code> 函数转换 UUID 值为 16 字节的数字，并存储在一个 <code>BINARY(16)</code> 的列中，检索时，可以通过 <code>HEX()</code> 函数来格式化为 16 进制格式。</li>
</ul>
</li>
</ul>
<h2 id="4-索引"><a class="markdownIt-Anchor" href="#4-索引"></a> 4. 索引</h2>
<blockquote>
<p>详见：<a href="05.Mysql%E7%B4%A2%E5%BC%95.md">Mysql 索引</a></p>
</blockquote>
<h2 id="5-锁"><a class="markdownIt-Anchor" href="#5-锁"></a> 5. 锁</h2>
<blockquote>
<p>详见：<a href="04.Mysql%E9%94%81.md">Mysql 锁</a></p>
</blockquote>
<h2 id="6-事务"><a class="markdownIt-Anchor" href="#6-事务"></a> 6. 事务</h2>
<blockquote>
<p>详见：<a href="03.Mysql%E4%BA%8B%E5%8A%A1.md">Mysql 事务</a></p>
</blockquote>
<h2 id="7-性能优化"><a class="markdownIt-Anchor" href="#7-性能优化"></a> 7. 性能优化</h2>
<blockquote>
<p>详见：<a href="06.Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Mysql 性能优化</a></p>
</blockquote>
<h2 id="8-复制"><a class="markdownIt-Anchor" href="#8-复制"></a> 8. 复制</h2>
<h3 id="81-主从复制"><a class="markdownIt-Anchor" href="#81-主从复制"></a> 8.1. 主从复制</h3>
<p>Mysql 支持两种复制：基于行的复制和基于语句的复制。</p>
<p>这两种方式都是在主库上记录二进制日志，然后在从库重放日志的方式来实现异步的数据复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。</p>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/mysql/master-slave.png" />
</div>
<h3 id="82-读写分离"><a class="markdownIt-Anchor" href="#82-读写分离"></a> 8.2. 读写分离</h3>
<p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。</p>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p>MySQL 读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/mysql/master-slave-proxy.png" />
</div>
------
<p>（分割线）以下为高级特性，也是关系型数据库通用方案</p>
<h2 id="9-分布式事务"><a class="markdownIt-Anchor" href="#9-分布式事务"></a> 9. 分布式事务</h2>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md">分布式事务基本原理</a></p>
</blockquote>
<h2 id="10-分库分表"><a class="markdownIt-Anchor" href="#10-分库分表"></a> 10. 分库分表</h2>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-storage.md">分布式存储基本原理</a></p>
</blockquote>
<h2 id="11-参考资料"><a class="markdownIt-Anchor" href="#11-参考资料"></a> 11. 参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases">How to create unique row ID in sharded databases?</a></li>
<li><a target="_blank" rel="noopener" href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx">SQL Azure Federation – Introduction</a></li>
</ul>
<h2 id="12-传送门"><a class="markdownIt-Anchor" href="#12-传送门"></a> 12. 传送门</h2>
<p>◾ 🏠 <a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial">DB-TUTORIAL 首页</a> ◾ 🎯 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog">我的博客</a> ◾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/2872df3d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2872df3d.html" class="post-title-link" itemprop="url">Redis 数据类型和应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2872df3d.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2872df3d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-数据类型和应用"><a class="markdownIt-Anchor" href="#redis-数据类型和应用"></a> Redis 数据类型和应用</h1>
<blockquote>
<p>Redis 提供了多种数据类型，每种数据类型有丰富的命令支持。</p>
<p>使用 Redis ，不仅要了解其数据类型的特性，还需要根据业务场景，灵活的、高效的使用其数据类型来建模。</p>
</blockquote>
<h2 id="一-redis-基本数据类型"><a class="markdownIt-Anchor" href="#一-redis-基本数据类型"></a> 一、Redis 基本数据类型</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200226113813.png" alt="Redis 数据类型" /></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> STRING</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-string.png" width="400"/>
</div>
**适用场景：缓存、计数器、共享 Session**
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET</code></td>
<td>获取存储在给定键中的值。</td>
</tr>
<tr>
<td><code>SET</code></td>
<td>设置存储在给定键中的值。</td>
</tr>
<tr>
<td><code>DEL</code></td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）。</td>
</tr>
<tr>
<td><code>INCR</code></td>
<td>为键 <code>key</code> 储存的数字值加一</td>
</tr>
<tr>
<td><code>DECR</code></td>
<td>为键 <code>key</code> 储存的数字值减一</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#string">Redis String 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> HASH</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-hash.png" width="400"/>
</div>
**适用场景：存储结构化数据**，如一个对象：用户信息、产品信息等。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HSET</code></td>
<td>在散列里面关联起给定的键值对。</td>
</tr>
<tr>
<td><code>HGET</code></td>
<td>获取指定散列键的值。</td>
</tr>
<tr>
<td><code>HGETALL</code></td>
<td>获取散列包含的所有键值对。</td>
</tr>
<tr>
<td><code>HDEL</code></td>
<td>如果给定键存在于散列里面，那么移除这个键。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#hash">Redis Hash 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key3 value2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> LIST</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-list.png" width="400"/>
</div>
**适用场景：用于存储列表型数据**。如：粉丝列表、商品列表等。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>RPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>LPOP</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>RPOP</code></td>
<td>从列表的右端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LRANGE</code></td>
<td>获取列表在给定范围上的所有值。</td>
</tr>
<tr>
<td><code>LINDEX</code></td>
<td>获取列表在给定位置上的单个元素。</td>
</tr>
<tr>
<td><code>LREM</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LTRIM</code></td>
<td>只保留指定区间内的元素，删除其他元素。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#list">Redis List 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> SET</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-set.png" width="400"/>
</div>
**适用场景：用于存储去重的列表型数据**。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SADD</code></td>
<td>将给定元素添加到集合。</td>
</tr>
<tr>
<td><code>SMEMBERS</code></td>
<td>返回集合包含的所有元素。</td>
</tr>
<tr>
<td><code>SISMEMBER</code></td>
<td>检查给定元素是否存在于集合中。</td>
</tr>
<tr>
<td><code>SREM</code></td>
<td>如果给定的元素存在于集合中，那么移除这个元素。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#set">Redis Set 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>
<h3 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> ZSET</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-zset.png" width="400"/>
</div>
<p>适用场景：由于可以设置 score，且不重复。<strong>适合用于存储各种排行数据</strong>，如：按评分排序的有序商品集合、按时间排序的有序文章集合。</p>
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZADD</code></td>
<td>将一个带有给定分值的成员添加到有序集合里面。</td>
</tr>
<tr>
<td><code>ZRANGE</code></td>
<td>根据元素在有序排列中所处的位置，从有序集合里面获取多个元素。</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE</code></td>
<td>获取有序集合在给定分值范围内的所有元素。</td>
</tr>
<tr>
<td><code>ZREM</code></td>
<td>如果给定成员存在于有序集合，那么移除这个成员。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#sorted_set">Redis ZSet 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3>
<h4 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h4>
<p>Redis 的 <code>SORT</code> 命令可以对 <code>LIST</code>、<code>SET</code>、<code>ZSET</code> 进行排序。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SORT</code></td>
<td><code>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE dest-key]</code>—根据给定选项，对输入 <code>LIST</code>、<code>SET</code>、<code>ZSET</code> 进行排序，然后返回或存储排序的结果。</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; RPUSH &#x27;sort-input&#x27; 23 15 110 7</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27;</span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;23&quot;</span><br><span class="line">4) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; alpha</span><br><span class="line">1) &quot;110&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;23&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-7&#x27; &#x27;field&#x27; 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-15&#x27; &#x27;field&#x27; 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-23&#x27; &#x27;field&#x27; 9</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-110&#x27; &#x27;field&#x27; 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; by &#x27;d-*-&gt;field&#x27;</span><br><span class="line">1) &quot;15&quot;</span><br><span class="line">2) &quot;110&quot;</span><br><span class="line">3) &quot;7&quot;</span><br><span class="line">4) &quot;23&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; by &#x27;d-*-&gt;field&#x27; get &#x27;d-*-&gt;field&#x27;</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;9&quot;</span><br></pre></td></tr></table></figure>
<h4 id="键的过期时间"><a class="markdownIt-Anchor" href="#键的过期时间"></a> 键的过期时间</h4>
<p>Redis 的 <code>EXPIRE</code> 命令可以指定一个键的过期时间，当达到过期时间后，Redis 会自动删除该键。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PERSIST</code></td>
<td><code>PERSIST key-name</code>—移除键的过期时间</td>
</tr>
<tr>
<td><code>TTL</code></td>
<td><code>TTL key-name</code>—查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td><code>EXPIRE</code></td>
<td><code>EXPIRE key-name seconds</code>—让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td><code>EXPIREAT</code></td>
<td><code>EXPIREAT key-name timestamp</code>—将给定键的过期时间设置为给定的 UNIX 时间戳</td>
</tr>
<tr>
<td><code>PTTL</code></td>
<td><code>PTTL key-name</code>—查看给定键距离过期时间还有多少毫秒（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIRE</code></td>
<td><code>PEXPIRE key-name milliseconds</code>—让给定键在指定的毫秒数之后过期（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIREAT</code></td>
<td><code>PEXPIREAT key-name timestamp-milliseconds</code>—将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">&quot;value&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; EXPIRE key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h2 id="二-redis-高级数据类型"><a class="markdownIt-Anchor" href="#二-redis-高级数据类型"></a> 二、Redis 高级数据类型</h2>
<h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> BitMap</h3>
<p>BitMap 即位图。BitMap 不是一个真实的数据结构。而是 STRING 类型上的一组面向 bit 操作的集合。由于 STRING 是二进制安全的 blob，并且它们的最大长度是 512m，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p>
<p>Bitmaps 的最大优点就是存储信息时可以节省大量的空间。例如在一个系统中，不同的用户被一个增长的用户 ID 表示。40 亿（$$2^{32}$$ = $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种信息，例如用户是否登录过。</p>
<h4 id="bitmap-命令"><a class="markdownIt-Anchor" href="#bitmap-命令"></a> BitMap 命令</h4>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html">SETBIT</a> - 对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/getbit.html">GETBIT</a> - 对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitcount.html">BITCOUNT</a> - 计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitpos.html">BITPOS</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitop.html">BITOP</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitfield.html">BITFIELD</a></li>
</ul>
<h4 id="bitmap-示例"><a class="markdownIt-Anchor" href="#bitmap-示例"></a> BitMap 示例</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXISTS bit</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GETBIT bit 10086</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对已存在的 offset 进行 GETBIT</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SETBIT bit 10086 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GETBIT bit 10086</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">BITCOUNT bit</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="bitmap-应用"><a class="markdownIt-Anchor" href="#bitmap-应用"></a> BitMap 应用</h4>
<p>Bitmap 对于一些特定类型的计算非常有效。例如：使用 bitmap 实现用户上线次数统计。</p>
<p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html#setbit">SETBIT key offset value</a> 和 [BITCOUNT key <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitcount.html#bitcount">start] [end]</a> 来实现。</p>
<p>比如说，每当用户在某一天上线的时候，我们就使用 <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html#setbit">SETBIT key offset value</a> ，以用户名作为 <code>key</code>，将那天所代表的网站的上线日作为 <code>offset</code> 参数，并将这个 <code>offset</code> 上的为设置为 <code>1</code> 。</p>
<blockquote>
<p>更详细的实现可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011957758/article/details/74783347">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">Fast, easy, realtime metrics using Redis bitmaps</a></p>
</blockquote>
<h3 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h3>
<p>HyperLogLog 是用于计算唯一事物的概率数据结构（从技术上讲，这被称为估计集合的基数）。如果统计唯一项，项目越多，需要的内存就越多。因为需要记住过去已经看过的项，从而避免多次统计这些项。</p>
<h4 id="hyperloglog-命令"><a class="markdownIt-Anchor" href="#hyperloglog-命令"></a> HyperLogLog 命令</h4>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfadd.html">PFADD</a> - 将任意数量的元素添加到指定的 HyperLogLog 里面。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfcount.html">PFCOUNT</a> - 返回 HyperLogLog 包含的唯一元素的近似数量。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfmerge.html">PFMERGE</a> - 将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。合并得出的 HyperLogLog 会被储存在 <code>destkey</code> 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;Redis&quot;</span>  <span class="string">&quot;MongoDB&quot;</span>  <span class="string">&quot;MySQL&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;Redis&quot;</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;PostgreSQL&quot;</span>    <span class="comment"># 添加一个不存在的元素</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="geo"><a class="markdownIt-Anchor" href="#geo"></a> GEO</h3>
<p>这个功能可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作。</p>
<h4 id="geo-命令"><a class="markdownIt-Anchor" href="#geo-命令"></a> GEO 命令</h4>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geoadd.html">GEOADD</a> - 将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geopos.html">GEOPOS</a> - 从 key 里返回所有给定位置元素的位置（经度和纬度）。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geodist.html">GEODIST</a> - 返回两个给定位置之间的距离。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geohash.html">GEOHASH</a> - 回一个或多个位置元素的标准 Geohash 值，它可以在http://geohash.org/使用。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/georadius.html">GEORADIUS</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/georadiusbymember.html">GEORADIUSBYMEMBER</a></li>
</ul>
<h2 id="三-redis-数据类型应用"><a class="markdownIt-Anchor" href="#三-redis-数据类型应用"></a> 三、Redis 数据类型应用</h2>
<h3 id="案例-最受欢迎文章"><a class="markdownIt-Anchor" href="#案例-最受欢迎文章"></a> 案例-最受欢迎文章</h3>
<p>选出最受欢迎文章，需要支持对文章进行评分。</p>
<h4 id="对文章进行投票"><a class="markdownIt-Anchor" href="#对文章进行投票"></a> 对文章进行投票</h4>
<p>（1）使用 HASH 存储文章</p>
<p>使用 <code>HASH</code> 类型存储文章信息。其中：key 是文章 ID；field 是文章的属性 key；value 是属性对应值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225143038.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>存储文章信息 - 使用 <code>HSET</code> 或 <code>HMGET</code> 命令</li>
<li>查询文章信息 - 使用 <code>HGETALL</code> 命令</li>
<li>添加投票 - 使用 <code>HINCRBY</code> 命令</li>
</ul>
<p>（2）使用 <code>ZSET</code> 针对不同维度集合排序</p>
<p>使用 <code>ZSET</code> 类型分别存储按照时间排序和按照评分排序的文章 ID 集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225145742.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>添加记录 - 使用 <code>ZADD</code> 命令</li>
<li>添加分数 - 使用 <code>ZINCRBY</code> 命令</li>
<li>取出多篇文章 - 使用 <code>ZREVRANGE</code> 命令</li>
</ul>
<p>（3）为了防止重复投票，使用 <code>SET</code> 类型记录每篇文章 ID 对应的投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150105.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>添加投票者 - 使用 <code>SADD</code> 命令</li>
<li>设置有效期 - 使用 <code>EXPIRE</code> 命令</li>
</ul>
<p>（4）假设 user:115423 给 article:100408 投票，分别需要高更新评分排序集合以及投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150138.jpg" alt="img" /></p>
<p>当需要对一篇文章投票时，程序需要用 ZSCORE 命令检查记录文章发布时间的有序集合，判断文章的发布时间是否超过投票有效期（比如：一星期）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">articleVote</span><span class="params">(Jedis conn, String user, String article)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算文章的投票截止时间。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">cutoff</span> <span class="operator">=</span> (System.currentTimeMillis() / <span class="number">1000</span>) - ONE_WEEK_IN_SECONDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还可以对文章进行投票</span></span><br><span class="line">    <span class="comment">// （虽然使用散列也可以获取文章的发布时间，</span></span><br><span class="line">    <span class="comment">// 但有序集合返回的文章发布时间为浮点数，</span></span><br><span class="line">    <span class="comment">// 可以不进行转换直接使用）。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.zscore(<span class="string">&quot;time:&quot;</span>, article) &lt; cutoff) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从article:id标识符（identifier）里面取出文章的ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> article.substring(article.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户是第一次为这篇文章投票，那么增加这篇文章的投票数量和评分。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.sadd(<span class="string">&quot;voted:&quot;</span> + articleId, user) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.zincrby(<span class="string">&quot;score:&quot;</span>, VOTE_SCORE, article);</span><br><span class="line">        conn.hincrBy(article, <span class="string">&quot;votes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发布并获取文章"><a class="markdownIt-Anchor" href="#发布并获取文章"></a> 发布并获取文章</h4>
<p>发布文章：</p>
<ul>
<li>添加文章 - 使用 <code>INCR</code> 命令计算新的文章 ID，填充文章信息，然后用 <code>HSET</code> 命令或 <code>HMSET</code> 命令写入到 <code>HASH</code> 结构中。</li>
<li>将文章作者 ID 添加到投票名单 - 使用 <code>SADD</code> 命令添加到代表投票名单的 <code>SET</code> 结构中。</li>
<li>设置投票有效期 - 使用 <code>EXPIRE</code> 命令设置投票有效期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postArticle</span><span class="params">(Jedis conn, String user, String title, String link)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成一个新的文章ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> String.valueOf(conn.incr(<span class="string">&quot;article:&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">voted</span> <span class="operator">=</span> <span class="string">&quot;voted:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将发布文章的用户添加到文章的已投票用户名单里面，</span></span><br><span class="line">    conn.sadd(voted, user);</span><br><span class="line">    <span class="comment">// 然后将这个名单的过期时间设置为一周（第3章将对过期时间作更详细的介绍）。</span></span><br><span class="line">    conn.expire(voted, ONE_WEEK_IN_SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章信息存储到一个散列里面。</span></span><br><span class="line">    HashMap&lt;String, String&gt; articleData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    articleData.put(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">    articleData.put(<span class="string">&quot;link&quot;</span>, link);</span><br><span class="line">    articleData.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    articleData.put(<span class="string">&quot;now&quot;</span>, String.valueOf(now));</span><br><span class="line">    articleData.put(<span class="string">&quot;votes&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    conn.hmset(article, articleData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文章添加到根据发布时间排序的有序集合和根据评分排序的有序集合里面。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;score:&quot;</span>, now + VOTE_SCORE, article);</span><br><span class="line">    conn.zadd(<span class="string">&quot;time:&quot;</span>, now, article);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分页查询最受欢迎文章：</p>
<p>使用 <code>ZINTERSTORE</code> 命令根据页码、每页记录数、排序号，根据评分值从大到小分页查出文章 ID 列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getArticles</span><span class="params">(Jedis conn, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置获取文章的起始索引和结束索引。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (page - <span class="number">1</span>) * ARTICLES_PER_PAGE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + ARTICLES_PER_PAGE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多个文章ID。</span></span><br><span class="line">    Set&lt;String&gt; ids = conn.zrevrange(order, start, end);</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; articles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据文章ID获取文章的详细信息。</span></span><br><span class="line">    <span class="keyword">for</span> (String id : ids) &#123;</span><br><span class="line">        Map&lt;String, String&gt; articleData = conn.hgetAll(id);</span><br><span class="line">        articleData.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        articles.add(articleData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对文章进行分组"><a class="markdownIt-Anchor" href="#对文章进行分组"></a> 对文章进行分组</h4>
<p>如果文章需要分组，功能需要分为两块：</p>
<ul>
<li>记录文章属于哪个群组</li>
<li>负责取出群组里的文章</li>
</ul>
<p>将文章添加、删除群组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRemoveGroups</span><span class="params">(Jedis conn, String articleId, String[] toAdd, String[] toRemove)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建存储文章信息的键名。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章添加到它所属的群组里面。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toAdd) &#123;</span><br><span class="line">        conn.sadd(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从群组里面移除文章。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toRemove) &#123;</span><br><span class="line">        conn.srem(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出群组里的文章：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225214210.jpg" alt="img" /></p>
<ul>
<li>通过对存储群组文章的集合和存储文章评分的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章评分排序的群组文章。</li>
<li>通过对存储群组文章的集合和存储文章发布时间的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章发布时间排序的群组文章。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getGroupArticles</span><span class="params">(Jedis conn, String group, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 为每个群组的每种排列顺序都创建一个键。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> order + group;</span><br><span class="line">    <span class="comment">// 检查是否有已缓存的排序结果，如果没有的话就现在进行排序。</span></span><br><span class="line">    <span class="keyword">if</span> (!conn.exists(key)) &#123;</span><br><span class="line">        <span class="comment">// 根据评分或者发布时间，对群组文章进行排序。</span></span><br><span class="line">        <span class="type">ZParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZParams</span>().aggregate(ZParams.Aggregate.MAX);</span><br><span class="line">        conn.zinterstore(key, params, <span class="string">&quot;group:&quot;</span> + group, order);</span><br><span class="line">        <span class="comment">// 让Redis在60秒钟之后自动删除这个有序集合。</span></span><br><span class="line">        conn.expire(key, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用之前定义的getArticles函数来进行分页并获取文章数据。</span></span><br><span class="line">    <span class="keyword">return</span> getArticles(conn, page, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-管理令牌"><a class="markdownIt-Anchor" href="#案例-管理令牌"></a> 案例-管理令牌</h3>
<p>网站一般会以 Cookie、Session、令牌这类信息存储用户身份信息。</p>
<p>可以将 Cookie/Session/令牌 和用户的映射关系存储在 <code>HASH</code> 结构。</p>
<p>下面以令牌来举例。</p>
<h4 id="查询令牌"><a class="markdownIt-Anchor" href="#查询令牌"></a> 查询令牌</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkToken</span><span class="params">(Jedis conn, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取并返回令牌对应的用户。</span></span><br><span class="line">    <span class="keyword">return</span> conn.hget(<span class="string">&quot;login:&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更新令牌"><a class="markdownIt-Anchor" href="#更新令牌"></a> 更新令牌</h4>
<ul>
<li>用户每次访问页面，可以记录下令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中，以便分析用户是否活跃，继而可以周期性清理最老的令牌，统计当前在线用户数等行为。</li>
<li>用户如果正在浏览商品，可以记录到用户最近浏览过的商品有序集合中（集合可以限定数量，超过数量进行裁剪），存入到一个 <code>ZSET</code> 结构中，以便分析用户最近可能感兴趣的商品，以便推荐商品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 维持令牌与已登录用户之间的映射。</span></span><br><span class="line">    conn.hset(<span class="string">&quot;login:&quot;</span>, token, user);</span><br><span class="line">    <span class="comment">// 记录令牌最后一次出现的时间。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;recent:&quot;</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录用户浏览过的商品。</span></span><br><span class="line">        conn.zadd(<span class="string">&quot;viewed:&quot;</span> + token, timestamp, item);</span><br><span class="line">        <span class="comment">// 移除旧的记录，只保留用户最近浏览过的25个商品。</span></span><br><span class="line">        conn.zremrangeByRank(<span class="string">&quot;viewed:&quot;</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">&quot;viewed:&quot;</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理令牌"><a class="markdownIt-Anchor" href="#清理令牌"></a> 清理令牌</h4>
<p>上一节提到，更新令牌时，将令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中。所以可以通过排序得知哪些令牌最老。如果没有清理操作，更新令牌占用的内存会不断膨胀，直到导致机器宕机。</p>
<p>比如：最多允许存储 1000 万条令牌信息，周期性检查，一旦发现记录数超出 1000 万条，将 ZSET 从新到老排序，将超出 1000 万条的记录清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CleanSessionsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleanSessionsThread</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 找出目前已有令牌的数量。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> conn.zcard(<span class="string">&quot;recent:&quot;</span>);</span><br><span class="line">            <span class="comment">// 令牌数量未超过限制，休眠并在之后重新检查。</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要移除的令牌ID。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">endIndex</span> <span class="operator">=</span> Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">            Set&lt;String&gt; tokenSet = conn.zrange(<span class="string">&quot;recent:&quot;</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">            String[] tokens = tokenSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[tokenSet.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为那些将要被删除的令牌构建键名。</span></span><br><span class="line">            ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">                sessionKeys.add(<span class="string">&quot;viewed:&quot;</span> + token);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除最旧的那些令牌。</span></span><br><span class="line">            conn.del(sessionKeys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionKeys.size()]));</span><br><span class="line">            conn.hdel(<span class="string">&quot;login:&quot;</span>, tokens);</span><br><span class="line">            conn.zrem(<span class="string">&quot;recent:&quot;</span>, tokens);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-购物车"><a class="markdownIt-Anchor" href="#案例-购物车"></a> 案例-购物车</h3>
<p>可以使用 HASH 结构来实现购物车功能。</p>
<p>每个用户的购物车，存储了商品 ID 和商品数量的映射。</p>
<h4 id="在购物车中添加-删除商品"><a class="markdownIt-Anchor" href="#在购物车中添加-删除商品"></a> 在购物车中添加、删除商品</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToCart</span><span class="params">(Jedis conn, String session, String item, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从购物车里面移除指定的商品。</span></span><br><span class="line">        conn.hdel(<span class="string">&quot;cart:&quot;</span> + session, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将指定的商品添加到购物车。</span></span><br><span class="line">        conn.hset(<span class="string">&quot;cart:&quot;</span> + session, item, String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清空购物车"><a class="markdownIt-Anchor" href="#清空购物车"></a> 清空购物车</h4>
<p>在 <a href="#%E6%B8%85%E7%90%86%E4%BB%A4%E7%89%8C">清理令牌</a> 的基础上，清空会话时，顺便将购物车缓存一并清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> conn.zcard(<span class="string">&quot;recent:&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> <span class="variable">endIndex</span> <span class="operator">=</span> Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">     Set&lt;String&gt; sessionSet = conn.zrange(<span class="string">&quot;recent:&quot;</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">     String[] sessions = sessionSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionSet.size()]);</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     <span class="keyword">for</span> (String sess : sessions) &#123;</span><br><span class="line">         sessionKeys.add(<span class="string">&quot;viewed:&quot;</span> + sess);</span><br><span class="line">         <span class="comment">// 新增加的这行代码用于删除旧会话对应用户的购物车。</span></span><br><span class="line">         sessionKeys.add(<span class="string">&quot;cart:&quot;</span> + sess);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     conn.del(sessionKeys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionKeys.size()]));</span><br><span class="line">     conn.hdel(<span class="string">&quot;login:&quot;</span>, sessions);</span><br><span class="line">     conn.zrem(<span class="string">&quot;recent:&quot;</span>, sessions);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-页面缓存"><a class="markdownIt-Anchor" href="#案例-页面缓存"></a> 案例-页面缓存</h3>
<p>大部分网页内容并不会经常改变，但是访问时，后台需要动态计算，这可能耗时较多，此时可以使用 <code>STRING</code> 结构存储页面缓存，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">cacheRequest</span><span class="params">(Jedis conn, String request, Callback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于不能被缓存的请求，直接调用回调函数。</span></span><br><span class="line">    <span class="keyword">if</span> (!canCache(conn, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback != <span class="literal">null</span> ? callback.call(request) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求转换成一个简单的字符串键，方便之后进行查找。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">pageKey</span> <span class="operator">=</span> <span class="string">&quot;cache:&quot;</span> + hashRequest(request);</span><br><span class="line">    <span class="comment">// 尝试查找被缓存的页面。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> conn.get(pageKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="literal">null</span> &amp;&amp; callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果页面还没有被缓存，那么生成页面。</span></span><br><span class="line">        content = callback.call(request);</span><br><span class="line">        <span class="comment">// 将新生成的页面放到缓存里面。</span></span><br><span class="line">        conn.setex(pageKey, <span class="number">300</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回页面。</span></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-数据行缓存"><a class="markdownIt-Anchor" href="#案例-数据行缓存"></a> 案例-数据行缓存</h3>
<p>电商网站可能会有促销、特卖、抽奖等活动，这些活动页面只需要从数据库中加载几行数据，如：用户信息、商品信息。</p>
<p>可以使用 <code>STRING</code> 结构来缓存这些数据，使用 JSON 存储结构化的信息。</p>
<p>此外，需要有两个 <code>ZSET</code> 结构来记录更新缓存的时机：</p>
<ul>
<li>第一个为调度有序集合；</li>
<li>第二个为延时有序集合。</li>
</ul>
<p>记录缓存时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleRowCache</span><span class="params">(Jedis conn, String rowId, <span class="type">int</span> delay)</span> &#123;</span><br><span class="line">    <span class="comment">// 先设置数据行的延迟值。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;delay:&quot;</span>, delay, rowId);</span><br><span class="line">    <span class="comment">// 立即缓存数据行。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;schedule:&quot;</span>, System.currentTimeMillis() / <span class="number">1000</span>, rowId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时更新数据行缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRowsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheRowsThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取下一个需要被缓存的数据行以及该行的调度时间戳，</span></span><br><span class="line">            <span class="comment">// 命令会返回一个包含零个或一个元组（tuple）的列表。</span></span><br><span class="line">            Set&lt;Tuple&gt; range = conn.zrangeWithScores(<span class="string">&quot;schedule:&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> range.size() &gt; <span class="number">0</span> ? range.iterator().next() : <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span> || next.getScore() &gt; now) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 暂时没有行需要被缓存，休眠50毫秒后重试。</span></span><br><span class="line">                    sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rowId</span> <span class="operator">=</span> next.getElement();</span><br><span class="line">            <span class="comment">// 获取下一次调度前的延迟时间。</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">delay</span> <span class="operator">=</span> conn.zscore(<span class="string">&quot;delay:&quot;</span>, rowId);</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不必再缓存这个行，将它从缓存中移除。</span></span><br><span class="line">                conn.zrem(<span class="string">&quot;delay:&quot;</span>, rowId);</span><br><span class="line">                conn.zrem(<span class="string">&quot;schedule:&quot;</span>, rowId);</span><br><span class="line">                conn.del(<span class="string">&quot;inv:&quot;</span> + rowId);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据行。</span></span><br><span class="line">            <span class="type">Inventory</span> <span class="variable">row</span> <span class="operator">=</span> Inventory.get(rowId);</span><br><span class="line">            <span class="comment">// 更新调度时间并设置缓存值。</span></span><br><span class="line">            conn.zadd(<span class="string">&quot;schedule:&quot;</span>, now + delay, rowId);</span><br><span class="line">            conn.set(<span class="string">&quot;inv:&quot;</span> + rowId, gson.toJson(row));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-网页分析"><a class="markdownIt-Anchor" href="#案例-网页分析"></a> 案例-网页分析</h3>
<p>网站可以采集用户的访问、交互、购买行为，再分析用户习惯、喜好，从而判断市场行情和潜在商机等。</p>
<p>那么，简单的，如何记录用户在一定时间内访问的商品页面呢？</p>
<p>参考 <a href="#%E6%9B%B4%E6%96%B0%E4%BB%A4%E7%89%8C">更新令牌</a> 代码示例，记录用户访问不同商品的浏览次数，并排序。</p>
<p>判断页面是否需要缓存，根据评分判断商品页面是否热门：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCache</span><span class="params">(Jedis conn, String request)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(request);</span><br><span class="line">        HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (url.getQuery() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String param : url.getQuery().split(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">                String[] pair = param.split(<span class="string">&quot;=&quot;</span>, <span class="number">2</span>);</span><br><span class="line">                params.put(pair[<span class="number">0</span>], pair.length == <span class="number">2</span> ? pair[<span class="number">1</span>] : <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从页面里面取出商品ID。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itemId</span> <span class="operator">=</span> extractItemId(params);</span><br><span class="line">        <span class="comment">// 检查这个页面能否被缓存以及这个页面是否为商品页面。</span></span><br><span class="line">        <span class="keyword">if</span> (itemId == <span class="literal">null</span> || isDynamic(params)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取得商品的浏览次数排名。</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> conn.zrank(<span class="string">&quot;viewed:&quot;</span>, itemId);</span><br><span class="line">        <span class="comment">// 根据商品的浏览次数排名来判断是否需要缓存这个页面。</span></span><br><span class="line">        <span class="keyword">return</span> rank != <span class="literal">null</span> &amp;&amp; rank &lt; <span class="number">10000</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException mue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-记录日志"><a class="markdownIt-Anchor" href="#案例-记录日志"></a> 案例-记录日志</h3>
<p>可用使用 <code>LIST</code> 结构存储日志数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logRecent</span><span class="params">(Jedis conn, String name, String message, String severity)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="string">&quot;recent:&quot;</span> + name + <span class="string">&#x27;:&#x27;</span> + severity;</span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> conn.pipelined();</span><br><span class="line">    pipe.lpush(destination, TIMESTAMP.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&#x27; &#x27;</span> + message);</span><br><span class="line">    pipe.ltrim(destination, <span class="number">0</span>, <span class="number">99</span>);</span><br><span class="line">    pipe.sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-统计数据"><a class="markdownIt-Anchor" href="#案例-统计数据"></a> 案例-统计数据</h3>
<p>更新计数器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] PRECISION = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">60</span>, <span class="number">300</span>, <span class="number">3600</span>, <span class="number">18000</span>, <span class="number">86400</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCounter</span><span class="params">(Jedis conn, String name, <span class="type">int</span> count, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">trans</span> <span class="operator">=</span> conn.multi();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> prec : PRECISION) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pnow</span> <span class="operator">=</span> (now / prec) * prec;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> String.valueOf(prec) + <span class="string">&#x27;:&#x27;</span> + name;</span><br><span class="line">        trans.zadd(<span class="string">&quot;known:&quot;</span>, <span class="number">0</span>, hash);</span><br><span class="line">        trans.hincrBy(<span class="string">&quot;count:&quot;</span> + hash, String.valueOf(pnow), count);</span><br><span class="line">    &#125;</span><br><span class="line">    trans.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看计数器数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Pair&lt;Integer&gt;&gt; <span class="title function_">getCounter</span><span class="params">(</span></span><br><span class="line"><span class="params">    Jedis conn, String name, <span class="type">int</span> precision)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> String.valueOf(precision) + <span class="string">&#x27;:&#x27;</span> + name;</span><br><span class="line">    Map&lt;String, String&gt; data = conn.hgetAll(<span class="string">&quot;count:&quot;</span> + hash);</span><br><span class="line">    List&lt;Pair&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(</span><br><span class="line">            entry.getKey(),</span><br><span class="line">            Integer.parseInt(entry.getValue())));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(results);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-查找-ip-所属地"><a class="markdownIt-Anchor" href="#案例-查找-ip-所属地"></a> 案例-查找 IP 所属地</h3>
<p>Redis 实现的 IP 所属地查找比关系型数据实现方式更快。</p>
<h4 id="载入-ip-数据"><a class="markdownIt-Anchor" href="#载入-ip-数据"></a> 载入 IP 数据</h4>
<p>IP 地址转为整数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ipToScore</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String v : ipAddress.split(<span class="string">&quot;\\.&quot;</span>)) &#123;</span><br><span class="line">        score = score * <span class="number">256</span> + Integer.parseInt(v, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 IP 地址与城市 ID 之间的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importIpsToRedis</span><span class="params">(Jedis conn, File file)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 载入 csv 文件数据</span></span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">CSVFormat</span> <span class="variable">csvFormat</span> <span class="operator">=</span> CSVFormat.DEFAULT.withRecordSeparator(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">CSVParser</span> <span class="variable">csvParser</span> <span class="operator">=</span> csvFormat.parse(reader);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;CSVRecord&gt; records = csvParser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord line : records) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">startIp</span> <span class="operator">=</span> line.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (startIp.toLowerCase().indexOf(<span class="string">&#x27;i&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 IP 地址转为整数值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (startIp.indexOf(<span class="string">&#x27;.&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                score = ipToScore(startIp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    score = Integer.parseInt(startIp, <span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// 略过文件的第一行以及格式不正确的条目</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建唯一的城市 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> line.get(<span class="number">2</span>) + <span class="string">&#x27;_&#x27;</span> + count;</span><br><span class="line">            <span class="comment">// 将城市 ID 及其对应的 IP 地址整数值添加到 ZSET</span></span><br><span class="line">            conn.zadd(<span class="string">&quot;ip2cityid:&quot;</span>, score, cityId);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储城市信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importCitiesToRedis</span><span class="params">(Jedis conn, File file)</span> &#123;</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载 csv 信息</span></span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">CSVFormat</span> <span class="variable">csvFormat</span> <span class="operator">=</span> CSVFormat.DEFAULT.withRecordSeparator(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">CSVParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSVParser</span>(reader, csvFormat);</span><br><span class="line">        <span class="comment">// String[] line;</span></span><br><span class="line">        List&lt;CSVRecord&gt; records = parser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.size() &lt; <span class="number">4</span> || !Character.isDigit(record.get(<span class="number">0</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将城市地理信息转为 json 结构，存入 HASH 结构中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> record.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> record.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> record.get(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> record.get(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; city, region, country &#125;);</span><br><span class="line">            conn.hset(<span class="string">&quot;cityid2city:&quot;</span>, cityId, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找-ip-所属城市"><a class="markdownIt-Anchor" href="#查找-ip-所属城市"></a> 查找 IP 所属城市</h4>
<p>操作步骤：</p>
<ol>
<li>将要查找的 IP 地址转为整数值；</li>
<li>查找所有分值小于等于要查找的 IP 地址的地址，取出其中最大分值的那个记录；</li>
<li>用找到的记录所对应的城市 ID 去检索城市信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findCityByIp(Jedis conn, String ipAddress) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> ipToScore(ipAddress);</span><br><span class="line">    Set&lt;String&gt; results = conn.zrevrangeByScore(<span class="string">&quot;ip2cityid:&quot;</span>, score, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> results.iterator().next();</span><br><span class="line">    cityId = cityId.substring(<span class="number">0</span>, cityId.indexOf(<span class="string">&#x27;_&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(conn.hget(<span class="string">&quot;cityid2city:&quot;</span>, cityId), String[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-服务的发现与配置"><a class="markdownIt-Anchor" href="#案例-服务的发现与配置"></a> 案例-服务的发现与配置</h3>
<h3 id="案例-自动补全"><a class="markdownIt-Anchor" href="#案例-自动补全"></a> 案例-自动补全</h3>
<p>需求：根据用户输入，自动补全信息，如：联系人、商品名等。</p>
<ul>
<li>典型场景一：社交网站后台记录用户最近联系过的 100 个好友，当用户查找好友时，根据输入的关键字自动补全姓名。</li>
<li>典型场景二：电商网站后台记录用户最近浏览过的 10 件商品，当用户查找商品是，根据输入的关键字自动补全商品名称。</li>
</ul>
<p>数据模型：使用 Redis 的 LIST 类型存储最近联系人列表。</p>
<p>构建自动补全列表通常有以下操作：</p>
<ul>
<li>如果指定联系人已经存在于最近联系人列表里，那么从列表里移除他。对应 <code>LREM</code> 命令。</li>
<li>将指定联系人添加到最近联系人列表的最前面。对应 <code>LPUSH</code> 命令。</li>
<li>添加操作完成后，如果联系人列表中的数量超过 100 个，进行裁剪操作。对应 <code>LTRIM</code> 命令。</li>
</ul>
<h3 id="案例-广告定向"><a class="markdownIt-Anchor" href="#案例-广告定向"></a> 案例-广告定向</h3>
<h3 id="案例-职位搜索"><a class="markdownIt-Anchor" href="#案例-职位搜索"></a> 案例-职位搜索</h3>
<p>需求：在一个招聘网站上，求职者有自己的技能清单；用人公司的职位有必要的技能清单。用人公司需要查询满足自己职位要求的求职者；求职者需要查询自己可以投递简历的职位。</p>
<p>关键数据模型：使用 <code>SET</code> 类型存储求职者的技能列表，使用 <code>SET</code> 类型存储职位的技能列表。</p>
<p>关键操作：使用 <code>SDIFF</code> 命令对比两个 <code>SET</code> 的差异，返回 <code>empty</code> 表示匹配要求。</p>
<p>redis cli 示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis 职位搜索数据模型示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（1）职位技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:001 职位添加 4 种技能</span></span><br><span class="line">SADD job:001 skill:001</span><br><span class="line">SADD job:001 skill:002</span><br><span class="line">SADD job:001 skill:003</span><br><span class="line">SADD job:001 skill:004</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:002 职位添加 3 种技能</span></span><br><span class="line">SADD job:002 skill:001</span><br><span class="line">SADD job:002 skill:002</span><br><span class="line">SADD job:002 skill:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:003 职位添加 2 种技能</span></span><br><span class="line">SADD job:003 skill:001</span><br><span class="line">SADD job:003 skill:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">SMEMBERS job:001</span><br><span class="line">SMEMBERS job:002</span><br><span class="line">SMEMBERS job:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（2）求职者技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line">SADD interviewee:001 skill:001</span><br><span class="line">SADD interviewee:001 skill:003</span><br><span class="line"></span><br><span class="line">SADD interviewee:002 skill:001</span><br><span class="line">SADD interviewee:002 skill:002</span><br><span class="line">SADD interviewee:002 skill:003</span><br><span class="line">SADD interviewee:002 skill:004</span><br><span class="line">SADD interviewee:002 skill:005</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">SMEMBERS interviewee:001</span><br><span class="line">SMEMBERS interviewee:002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（3）求职者遍历查找自己符合要求的职位（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF job:001 interviewee:001</span><br><span class="line">SDIFF job:002 interviewee:001</span><br><span class="line">SDIFF job:003 interviewee:001</span><br><span class="line"></span><br><span class="line">SDIFF job:001 interviewee:002</span><br><span class="line">SDIFF job:002 interviewee:002</span><br><span class="line">SDIFF job:003 interviewee:002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（4）用人公司根据遍历查找符合自己职位要求的求职者（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF interviewee:001 job:001</span><br><span class="line">SDIFF interviewee:002 job:001</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:002</span><br><span class="line">SDIFF interviewee:002 job:002</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:003</span><br><span class="line">SDIFF interviewee:002 job:003</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011957758/article/details/74783347">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">Fast, easy, realtime metrics using Redis bitmaps</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/a2b16944.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/a2b16944.html" class="post-title-link" itemprop="url">Redis 持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/a2b16944.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="a2b16944.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> Redis 持久化</h1>
<blockquote>
<p>Redis 支持持久化，即把数据存储到硬盘中。</p>
<p>Redis 提供了两种持久化方式：</p>
<ul>
<li><strong><code>RDB 快照（snapshot）</code></strong> - 将存在于某一时刻的所有数据都写入到硬盘中。</li>
<li><strong><code>只追加文件（append-only file，AOF）</code></strong> - 它会在执行写命令时，将被执行的写命令复制到硬盘中。</li>
</ul>
<p>这两种持久化方式既可以同时使用，也可以单独使用。</p>
<p>将内存中的数据存储到硬盘的一个主要原因是为了在之后重用数据，或者是为了防止系统故障而将数据备份到一个远程位置。另外，存储在 Redis 里面的数据有可能是经过长时间计算得出的，或者有程序正在使用 Redis 存储的数据进行计算，所以用户会希望自己可以将这些数据存储起来以便之后使用，这样就不必重新计算了。</p>
<p>Redis 提供了两种持久方式：RDB 和 AOF。你可以同时开启两种持久化方式。在这种情况下, 当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p>
</blockquote>
<h2 id="一-rdb"><a class="markdownIt-Anchor" href="#一-rdb"></a> 一、RDB</h2>
<h3 id="rdb-简介"><a class="markdownIt-Anchor" href="#rdb-简介"></a> RDB 简介</h3>
<p><strong>RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中</strong>。</p>
<p>创建 RDB 后，用户可以对 RDB 进行<strong>备份</strong>，可以将 RDB <strong>复制</strong>到其他服务器从而创建具有相同数据的服务器副本，还可以在<strong>重启</strong>服务器时使用。一句话来说：RDB 适合作为 <strong>冷备</strong>。</p>
<p>RDB 既可以手动执行，也可以根据服务器配置选项定期执行。该功能可以将某个时间点的数据库状态保存到一个 RDB 文件中。</p>
<h4 id="rdb-的优点"><a class="markdownIt-Anchor" href="#rdb-的优点"></a> RDB 的优点</h4>
<ul>
<li>RDB 文件非常紧凑，<strong>适合作为冷备</strong>。比如你可以在每个小时报保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 Redis 的性能。</li>
<li><strong>恢复大数据集时，RDB 比 AOF 更快</strong>。</li>
</ul>
<h4 id="rdb-的缺点"><a class="markdownIt-Anchor" href="#rdb-的缺点"></a> RDB 的缺点</h4>
<ul>
<li><strong>如果系统发生故障，将会丢失最后一次创建快照之后的数据</strong>。如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 快照不适合你。虽然你可以配置不同的 save 时间点(例如每隔 5 分钟并且对数据集有 100 个写的操作)，是 Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li>
<li><strong>如果数据量很大，保存快照的时间会很长</strong>。快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒。AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
<h3 id="rdb-的创建"><a class="markdownIt-Anchor" href="#rdb-的创建"></a> RDB 的创建</h3>
<p>有两个 Redis 命令可以用于生成 RDB 文件：<code>SAVE</code> 和 <code>BGSAVE</code>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/save"><strong><code>SAVE</code></strong></a> 命令会阻塞 Redis 服务器进程，直到 RDB 创建完成为止，在阻塞期间，服务器不能响应任何命令请求。</li>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/bgsave"><strong><code>BGSAVE</code></strong></a> 命令会派生出（fork）一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。</li>
</ul>
<blockquote>
<p>🔔 注意：<code>BGSAVE</code> 命令执行期间，<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code> 三个命令会被拒绝，以免与当前的 <code>BGSAVE</code> 操作产生竞态条件，降低性能。</p>
</blockquote>
<h4 id="自动间隔保存"><a class="markdownIt-Anchor" href="#自动间隔保存"></a> 自动间隔保存</h4>
<p>Redis 允许用户通过设置服务器配置的 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
<p>用户可以通过 <code>save</code> 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。</p>
<p>举例来说，<code>redis.conf</code> 中设置了如下配置：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span>       -- <span class="number">900</span> 秒内，至少对数据库进行了 <span class="number">1</span> 次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span>      -- <span class="number">300</span> 秒内，至少对数据库进行了 <span class="number">10</span> 次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span>    -- <span class="number">60</span> 秒内，至少对数据库进行了 <span class="number">10000</span> 次修改</span><br></pre></td></tr></table></figure>
<p>只要满足以上任意条件，Redis 服务就会执行 BGSAVE 命令。</p>
<h3 id="rdb-的载入"><a class="markdownIt-Anchor" href="#rdb-的载入"></a> RDB 的载入</h3>
<p><strong>RDB 文件的载入工作是在服务器启动时自动执行的</strong>，Redis 并没有专门用于载入 RDB 文件的命令。</p>
<p>服务器载入 RDB 文件期间，会一直处于阻塞状态，直到载入完成为止。</p>
<blockquote>
<p>🔔 注意：因为 AOF 通常更新频率比 RDB 高，所以丢失数据相对更少。基于这个原因，Redis 有以下默认行为：</p>
<ul>
<li>只有在关闭 AOF 功能的情况下，才会使用 RDB 还原数据，否则优先使用 AOF 文件来还原数据。</li>
</ul>
</blockquote>
<h3 id="rdb-的文件结构"><a class="markdownIt-Anchor" href="#rdb-的文件结构"></a> RDB 的文件结构</h3>
<p>RDB 文件是一个经过压缩的二进制文件，由多个部分组成。</p>
<p>对于不同类型（STRING、HASH、LIST、SET、SORTED SET）的键值对，RDB 文件会使用不同的方式来保存它们。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-rdb-structure.png" alt="img" /></p>
<p>Redis 本身提供了一个 RDB 文件检查工具 redis-check-dump。</p>
<h3 id="rdb-的配置"><a class="markdownIt-Anchor" href="#rdb-的配置"></a> RDB 的配置</h3>
<p>Redis RDB 默认配置如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"><span class="attribute">stop</span>-writes-<span class="literal">on</span>-bgsave-error yes</span><br><span class="line"><span class="attribute">rdbcompression</span> yes</span><br><span class="line"><span class="attribute">rdbchecksum</span> yes</span><br><span class="line"><span class="attribute">dbfilename</span> dump.rdb</span><br><span class="line"><span class="attribute">dir</span> ./</span><br></pre></td></tr></table></figure>
<p>Redis 的配置文件 <code>redis.conf</code> 中与 RDB 有关的选项：</p>
<ul>
<li>
<p><code>save</code> - Redis 会根据 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
</li>
<li>
<p><code>stop-writes-on-bgsave-error</code> - 当 BGSAVE 命令出现错误时停止写 RDB 文件</p>
</li>
<li>
<p><code>rdbcompression</code> - RDB 文件开启压缩功能。</p>
</li>
<li>
<p><code>rdbchecksum</code> - 对 RDB 文件进行校验。</p>
</li>
<li>
<p><code>dbfilename</code> - RDB 文件名。</p>
</li>
<li>
<p><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</p>
</li>
</ul>
<h2 id="二-aof"><a class="markdownIt-Anchor" href="#二-aof"></a> 二、AOF</h2>
<h3 id="aof-简介"><a class="markdownIt-Anchor" href="#aof-简介"></a> AOF 简介</h3>
<p><code>AOF(Append Only File)</code> 是以 <strong>文本日志形式</strong> 将 <strong>所有写命令以 Redis 命令请求协议格式追加到 AOF 文件的末尾</strong>，以此来记录数据的变化。<strong>当服务器重启时，会重新载入和执行 AOF 文件中的命令，就可以恢复原始的数据</strong>。AOF 适合作为 <strong>热备</strong>。</p>
<p>AOF 可以通过 <code>appendonly yes</code> 配置选项来开启。</p>
<p>命令请求会先保存到 AOF 缓冲区中，之后再定期写入并同步到 AOF 文件。</p>
<h4 id="aof-的优点"><a class="markdownIt-Anchor" href="#aof-的优点"></a> AOF 的优点</h4>
<ul>
<li><strong>如果系统发生故障，AOF 丢失数据比 RDB 少</strong>。你可以使用不同的 fsync 策略：无 fsync；每秒 fsync；每次写的时候 fsync。使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，你最多丢失 1 秒的数据。</li>
<li><strong>AOF 文件可修复</strong> - AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li><strong>AOF 文件可压缩</strong>。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li><strong>AOF 文件可读</strong> - AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 命令的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单。举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis ，就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h4 id="aof-的缺点"><a class="markdownIt-Anchor" href="#aof-的缺点"></a> AOF 的缺点</h4>
<ul>
<li><strong>AOF 文件体积一般比 RDB 大</strong> - 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li><strong>恢复大数据集时，AOF 比 RDB 慢。</strong> - 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="aof-的创建"><a class="markdownIt-Anchor" href="#aof-的创建"></a> AOF 的创建</h3>
<p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p>AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><strong>命令追加</strong> - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。</li>
<li><strong>文件写入</strong>和<strong>文件同步</strong> - Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行定时运行的函数。因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 <code>appendfsync</code> 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。</li>
</ul>
<p><code>appendfsync</code> 不同选项决定了不同的持久化行为：</p>
<ul>
<li><strong><code>always</code></strong> - 将缓冲区所有内容写入并同步到 AOF 文件。</li>
<li><strong><code>everysec</code></strong> - 将缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。</li>
<li><strong><code>no</code></strong> - 将缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。</li>
</ul>
<h3 id="aof-的载入"><a class="markdownIt-Anchor" href="#aof-的载入"></a> AOF 的载入</h3>
<p>因为 AOF 文件中包含了重建数据库所需的所有写命令，所以服务器只要载入并执行一遍 AOF 文件中保存的写命令，就可以还原服务器关闭前的数据库状态。</p>
<p>AOF 载入过程如下：</p>
<ol>
<li>服务器启动载入程序。</li>
<li>创建一个伪客户端。因为 Redis 命令只能在客户端上下文中执行，所以需要创建一个伪客户端来载入、执行 AOF 文件中记录的命令。</li>
<li>从 AOF 文件中分析并读取一条写命令。</li>
<li>使用伪客户端执行写命令。</li>
<li>循环执行步骤 3、4，直到所有写命令都被处理完毕为止。</li>
<li>载入完毕。</li>
</ol>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-aof-flow.png" />
</div>
<h3 id="aof-的重写"><a class="markdownIt-Anchor" href="#aof-的重写"></a> AOF 的重写</h3>
<p>随着 Redis 不断运行，AOF 的体积也会不断增长，这将导致两个问题：</p>
<ul>
<li>AOF 耗尽磁盘可用空间。</li>
<li>Redis 重启后需要执行 AOF 文件记录的所有写命令来还原数据集，如果 AOF 过大，则还原操作执行的时间就会非常长。</li>
</ul>
<p>为了解决 AOF 体积膨胀问题，Redis 提供了 AOF 重写功能，来对 AOF 文件进行压缩。<strong>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原来的 AOF 文件所保存的数据库状态一致，但体积更小</strong>。</p>
<p>AOF 重写并非读取和分析现有 AOF 文件的内容，而是直接从数据库中读取当前的数据库状态。即<strong>依次读取数据库中的每个键值对，然后用一条命令去记录该键值对</strong>，以此代替之前可能存在冗余的命令。</p>
<h4 id="aof-后台重写"><a class="markdownIt-Anchor" href="#aof-后台重写"></a> AOF 后台重写</h4>
<p>作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 <code>BGREWRITEAOF</code> 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 <code>BGSAVE</code> 原理类似。</p>
<ul>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</li>
<li>由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200130153716.png" alt="img" /></p>
<p>可以通过设置 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，使得 Redis 在满足条件时，自动执行 <code>BGREWRITEAOF</code>。</p>
<p>假设配置如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<p>表明，当 AOF 大于 <code>64MB</code>，且 AOF 体积比上一次重写后的体积大了至少 <code>100%</code> 时，执行 <code>BGREWRITEAOF</code>。</p>
<h3 id="aof-的配置"><a class="markdownIt-Anchor" href="#aof-的配置"></a> AOF 的配置</h3>
<p>AOF 的默认配置：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-<span class="built_in">rewrite</span> no</span><br><span class="line"><span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<p>AOF 持久化通过在 <code>redis.conf</code> 中的 <code>appendonly yes</code> 配置选项来开启。</p>
<ul>
<li><strong><code>appendonly</code></strong> - 开启 AOF 功能。</li>
<li><strong><code>appendfilename</code></strong> - AOF 文件名。</li>
<li><strong><code>appendfsync</code></strong> - 用于设置同步频率，它有以下可选项：
<ul>
<li><strong><code>always</code></strong> - 每个 Redis 写命令都要同步写入硬盘。这样做会严重降低 Redis 的速度。</li>
<li><strong><code>everysec</code></strong> - 每秒执行一次同步，显示地将多个写命令同步到硬盘。为了兼顾数据安全和写入性能，推荐使用 <code>appendfsync everysec</code> 选项。Redis 每秒同步一次 AOF 文件时的性能和不使用任何持久化特性时的性能相差无几。</li>
<li><strong><code>no</code></strong> - 让操作系统来决定应该何时进行同步。</li>
</ul>
</li>
<li><code>no-appendfsync-on-rewrite</code> - AOF 重写时不支持追加命令。</li>
<li><code>auto-aof-rewrite-percentage</code> - AOF 重写百分比。</li>
<li><code>auto-aof-rewrite-min-size</code> - AOF 重写文件的最小大小。</li>
<li><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</li>
</ul>
<h2 id="三-rdb-和-aof"><a class="markdownIt-Anchor" href="#三-rdb-和-aof"></a> 三、RDB 和 AOF</h2>
<blockquote>
<p>当 Redis 启动时， 如果 RDB 和 AOF 功能都开启了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</p>
</blockquote>
<h3 id="如何选择持久化"><a class="markdownIt-Anchor" href="#如何选择持久化"></a> 如何选择持久化</h3>
<ul>
<li>如果不关心数据丢失，可以不持久化。</li>
<li>如果可以承受数分钟以内的数据丢失，可以只使用 RDB。</li>
<li>如果不能承受数分钟以内的数据丢失，可以同时使用 RDB 和 AOF。</li>
</ul>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份，并且快照恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用快照还可以避免之前提到的 AOF 程序的 bug 。</p>
<h3 id="rdb-切换为-aof"><a class="markdownIt-Anchor" href="#rdb-切换为-aof"></a> RDB 切换为 AOF</h3>
<p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换为 AOF ：</p>
<ul>
<li>为最新的 dump.rdb 文件创建一个备份。</li>
<li>将备份放到一个安全的地方。</li>
<li>执行以下两条命令:</li>
<li>redis-cli config set appendonly yes</li>
<li>redis-cli config set save</li>
<li>确保写命令会被正确地追加到 AOF 文件的末尾。</li>
<li>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</li>
</ul>
<p>执行的第二条命令用于关闭快照功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用快照和 AOF 这两种持久化功能。</p>
<blockquote>
<p>🔔 重要：别忘了在 <code>redis.conf</code> 中打开 AOF 功能！否则的话，服务器重启之后，之前通过 CONFIG SET 设置的配置就会被遗忘，程序会按原来的配置来启动服务器。</p>
</blockquote>
<h3 id="aof-和-rdb-的相互作用"><a class="markdownIt-Anchor" href="#aof-和-rdb-的相互作用"></a> AOF 和 RDB 的相互作用</h3>
<p><code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 命令不可以同时执行。这是为了避免两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p>
<p>如果 <code>BGSAVE</code> 正在执行，并且用户显示地调用 <code>BGREWRITEAOF</code> 命令，那么服务器将向用户回复一个 OK 状态，并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行。一旦 <code>BGSAVE</code> 执行完毕， <code>BGREWRITEAOF</code> 就会正式开始。</p>
<h2 id="四-redis-备份"><a class="markdownIt-Anchor" href="#四-redis-备份"></a> 四、Redis 备份</h2>
<p>应该确保 Redis 数据有完整的备份。</p>
<p>备份 Redis 数据建议采用 RDB。</p>
<h3 id="备份过程"><a class="markdownIt-Anchor" href="#备份过程"></a> 备份过程</h3>
<ol>
<li>创建一个定期任务（cron job），每小时将一个 RDB 文件备份到一个文件夹，并且每天将一个 RDB 文件备份到另一个文件夹。</li>
<li>确保快照的备份都带有相应的日期和时间信息，每次执行定期任务脚本时，使用 find 命令来删除过期的快照：比如说，你可以保留最近 48 小时内的每小时快照，还可以保留最近一两个月的每日快照。</li>
<li>至少每天一次，将 RDB 备份到你的数据中心之外，或者至少是备份到你运行 Redis 服务器的物理机器之外。</li>
</ol>
<h3 id="容灾备份"><a class="markdownIt-Anchor" href="#容灾备份"></a> 容灾备份</h3>
<p>Redis 的容灾备份基本上就是对数据进行备份，并将这些备份传送到多个不同的外部数据中心。</p>
<p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时，仍然让数据处于安全状态。</p>
<h2 id="五-要点总结"><a class="markdownIt-Anchor" href="#五-要点总结"></a> 五、要点总结</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224214047.png" alt="img" /></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/edd4cfac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/edd4cfac.html" class="post-title-link" itemprop="url">Redis 复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/edd4cfac.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="edd4cfac.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-复制"><a class="markdownIt-Anchor" href="#redis-复制"></a> Redis 复制</h1>
<blockquote>
<p>在 Redis 中，<strong>可以通过执行 <code>SLAVEOF</code> 命令或设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器</strong>，其中，后者叫主服务器（master），前者叫从服务器（slave）。</p>
<p>Redis 2.8 以前的复制不能高效处理断线后重复制的情况，而 Redis 2.8 新添的部分重同步可以解决这个问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712182603.png" alt="img" /></p>
<h2 id="一-复制简介"><a class="markdownIt-Anchor" href="#一-复制简介"></a> 一、复制简介</h2>
<p>Redis 通过 <code>slaveof host port</code> 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p><strong>一个主服务器可以有多个从服务器</strong>。不仅主服务器可以有从服务器，从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个主从链。</p>
<p><strong>一个从服务器只能有一个主服务器，并且不支持主主复制</strong>。</p>
<p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
<p>在使用 Redis 复制功能时的设置中，强烈建议在 master 和在 slave 中启用持久化。当不启用时，例如由于非常慢的磁盘性能而导致的延迟问题，<strong>应该配置实例来避免重置后自动重启</strong>。</p>
<p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p>
<ul>
<li>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a target="_blank" rel="noopener" href="http://redisdoc.com/configure/config_set.html#config-set">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</li>
<li>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</li>
</ul>
<h2 id="二-旧版复制"><a class="markdownIt-Anchor" href="#二-旧版复制"></a> 二、旧版复制</h2>
<blockquote>
<p>Redis 2.8 版本以前实现方式：<code>SYNC</code> 命令</p>
</blockquote>
<p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li><strong><code>同步（sync）</code></strong> - 用于将从服务器的数据库状态更新至主服务器当前的数据库状态。</li>
<li><strong><code>命令传播（command propagate）</code></strong> - 当主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h3>
<p><code>SYNC</code> 命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送 <code>SYNC</code> 命令。</li>
<li>收到 <code>SYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>主服务器执行 <code>BGSAVE</code> 完毕后，主服务器会将生成的 RDB 文件发送给从服务器。从服务器接收并载入 RDB 文件，更新自己的数据库状态。</li>
<li>主服务器将记录在缓冲区中的所有写命令发送给从服务器，从服务器执行这些写命令，更新自己的数据库状态。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224220353.png" alt="img" /></p>
<h3 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h3>
<p>同步操作完成后，主从数据库的数据库状态将达到一致。每当主服务器执行客户端发送的写命令时，主从数据库状态不再一致。需要将写命令发送给从服务器执行，使得二者的数据库状态重新达到一致。</p>
<h3 id="旧版复制的缺陷"><a class="markdownIt-Anchor" href="#旧版复制的缺陷"></a> 旧版复制的缺陷</h3>
<p>从服务器对主服务器的复制存在两种情况：</p>
<ul>
<li><strong>初次复制</strong> - 从服务器以前没有复制过将要复制的主服务器。</li>
<li><strong>断线后重复制</strong> - 处于命令传播阶段的主从服务器因为网络原因而中断了复制，当从服务器通过自动重连重新连上了主服务器后，继续复制主服务器。</li>
</ul>
<p>对于初次复制，旧版复制功能可用很好完成任务；但是<strong>对于断线后重复制，由于每次任然需要生成 RDB 并传输，效率很低</strong>。</p>
<blockquote>
<p>🔔 注意：<strong>SYNC 命令是一个非常耗费资源的操作。</strong></p>
<ul>
<li>主服务器执行 <code>BGSAVE</code> 命令生成 RDB 文件，这个操作会耗费主服务器大量的 CPU、内存和磁盘 I/O 资源。</li>
<li>主服务器传输 RDB 文件给从服务器，这个操作会耗费主从服务器大量的网络资源，并对主服务器响应时延产生影响。</li>
<li>从服务器载入 RDB 文件期间，会阻塞其他命令请求。</li>
</ul>
</blockquote>
<h2 id="三-新版复制"><a class="markdownIt-Anchor" href="#三-新版复制"></a> 三、新版复制</h2>
<blockquote>
<p>Redis 2.8 版本以后的新实现方式：使用 <code>PSYNC</code> 命令替代 <code>SYNC</code> 命令。</p>
</blockquote>
<p><code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> - 用于断线后重复制。<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
<h3 id="部分重同步"><a class="markdownIt-Anchor" href="#部分重同步"></a> 部分重同步</h3>
<p>部分重同步功能实现由三个部分构成：</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<h4 id="复制偏移量"><a class="markdownIt-Anchor" href="#复制偏移量"></a> 复制偏移量</h4>
<p>主服务器和从服务器会分别维护一个复制偏移量。</p>
<ul>
<li>如果主从服务器的复制偏移量相同，则说明二者的数据库状态一致；</li>
<li>反之，则说明二者的数据库状态不一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-replication-offset.png" alt="img" /></p>
<h4 id="复制积压缓冲区"><a class="markdownIt-Anchor" href="#复制积压缓冲区"></a> 复制积压缓冲区</h4>
<p><strong>复制积压缓冲区是主服务器维护的一个固定长度的先进先出（FIFO）队列</strong>，默认大小为 <code>1MB</code>。</p>
<p>复制积压缓冲区会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p>
<p>当从服务器断线重连主服务时，从服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作。</p>
<ul>
<li>如果 offset 之后的数据仍然在复制积压缓冲区，则主服务器对从服务器执行部分重同步操作。</li>
<li>反之，则主服务器对从服务器执行完整重同步操作。</li>
</ul>
<blockquote>
<p>🔔 注意：<strong>合理调整复制积压缓冲区的大小</strong></p>
<ul>
<li>
<p>Redis 复制积压缓冲区默认大小为 <code>1MB</code>。</p>
</li>
<li>
<p>复制积压缓冲区的最小大小可以根据公式 <code>second * write_size_per_second</code> 估算。</p>
</li>
</ul>
</blockquote>
<h4 id="服务器的运行-id"><a class="markdownIt-Anchor" href="#服务器的运行-id"></a> 服务器的运行 ID</h4>
<ul>
<li>每个 Redis 服务器，都有运行 ID，用于唯一识别身份。</li>
<li>运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成。例如：132e358005e29741f8d7b0a42d666aace286edda</li>
</ul>
<p>从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，从服务器会将这个运行 ID 保存下来。</p>
<p>当从服务器断线重连一个主服务器时，从服务器会发送之前保存的运行 ID：</p>
<ul>
<li>如果保存的运行 ID 和当前主服务器的运行 ID 一致，则说明从服务器断线之前连接的就是这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>反之，若运行 ID 不一致，则说明从服务器断线之前连接的不是这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h3 id="psync-命令"><a class="markdownIt-Anchor" href="#psync-命令"></a> PSYNC 命令</h3>
<p>了解了部分重同步的实现，PSYNC 的实现就很容易理解了，它的基本工作原理大致如下：</p>
<p>当从服务接收到 <code>SLAVEOF</code> 命令时，先判断从服务器以前是否执行过复制操作。</p>
<ul>
<li>如果没有复制过任何主服务器，向要复制的主服务器<strong>发送 <code>PSYNC ? -1</code> 命令，主动请求进行完整重同步</strong>。</li>
<li>反之，向要复制的主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令。
<ul>
<li><code>runid</code> 是上一次复制的主服务器的运行 ID。</li>
<li><code>offset</code> 是复制偏移量。</li>
</ul>
</li>
</ul>
<p>接收到 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令的主服务会进行分析：</p>
<ul>
<li>假如主从服务器的 <strong>master run id 相同</strong>，并且<strong>指定的偏移量（offset）在内存缓冲区中还有效</strong>，复制就会从上次中断的点开始继续。</li>
<li>如果其中一个条件不满足，就会进行完全重新同步（在 2.8 版本之前就是直接进行完全重新同步）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-psync-workflow.png" alt="img" /></p>
<h2 id="四-心跳检测"><a class="markdownIt-Anchor" href="#四-心跳检测"></a> 四、心跳检测</h2>
<p>在<strong>命令传播</strong>阶段，从服务器默认会以<strong>每秒一次</strong>的频率，向主服务器发送命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_offset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>replication_offset</code> 是从服务器当前的复制偏移量。</p>
<p>发送 <code>REPLCONF ACK</code> 命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slaves 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h3 id="检测主从连接状态"><a class="markdownIt-Anchor" href="#检测主从连接状态"></a> 检测主从连接状态</h3>
<p><strong>可以通过发送和接收 <code>REPLCONF ACK</code> 命令来检查主从服务器之间的网络连接</strong>是否正常：如果主服务器超过一秒没有收到从服务器发来的 <code>REPLCONF ACK</code> 命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p>
<p>可以通过向主服务器发送 <code>INFO replication</code> 命令，在列出的从服务器列表的 lag 一栏中，可以看到从服务器向主服务器发送 <code>REPLCONF ACK</code> 命令已经过去多少秒。</p>
<h3 id="辅助实现-min-slaves-选项"><a class="markdownIt-Anchor" href="#辅助实现-min-slaves-选项"></a> 辅助实现 min-slaves 选项</h3>
<p>Redis 的 <strong><code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 两个选项可以防止主服务器在不安全的情况下执行写命令</strong>。</p>
<p>【示例】min-slaves 配置项</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>以上配置表示：从服务器小于 3 个，或三个从服务器的延迟（lag）都大于等于 10 秒时，主服务器将拒绝执行写命令。</p>
<h3 id="检测命令丢失"><a class="markdownIt-Anchor" href="#检测命令丢失"></a> 检测命令丢失</h3>
<p>如果因为网络故障，主服务传播给从服务器的写命令丢失，那么从服务器定时向主服务器发送 <code>REPLCONF ACK</code> 命令时，主服务器将发觉从服务器的复制偏移量少于自己的。然后，主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区中找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h2 id="五-复制的流程"><a class="markdownIt-Anchor" href="#五-复制的流程"></a> 五、复制的流程</h2>
<p>通过向从服务器发送如下 SLAVEOF 命令，可以让一个从服务器去复制一个主服务器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SLAVEOF <span class="tag">&lt;<span class="name">master_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">master_port</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤-1-设置主从服务器"><a class="markdownIt-Anchor" href="#步骤-1-设置主从服务器"></a> 步骤 1. 设置主从服务器</h3>
<p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">slaveof</span> <span class="number">127.0.0.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>当然， 你需要将代码中的 <code>127.0.0.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p>
<p>另外一种方法是调用 <a target="_blank" rel="noopener" href="http://redisdoc.com/replication/slaveof.html#slaveof">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SLAVEOF <span class="number">127.0.0.1</span> <span class="number">10086</span></span><br><span class="line"><span class="attribute">OK</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-主从服务器建立-tcp-连接"><a class="markdownIt-Anchor" href="#步骤-2-主从服务器建立-tcp-连接"></a> 步骤 2. 主从服务器建立 TCP 连接。</h3>
<h3 id="步骤-3-发送-ping-检查通信状态"><a class="markdownIt-Anchor" href="#步骤-3-发送-ping-检查通信状态"></a> 步骤 3. 发送 PING 检查通信状态。</h3>
<h3 id="步骤-4-身份验证"><a class="markdownIt-Anchor" href="#步骤-4-身份验证"></a> 步骤 4. 身份验证。</h3>
<p>如果主服务器没有设置 <code>requirepass</code> ，从服务器没有设置 <code>masterauth</code>，则不进行身份验证；反之，则需要进行身份验证。如果身份验证失败，则放弃执行复制工作。</p>
<p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h3 id="步骤-5-发送端口信息"><a class="markdownIt-Anchor" href="#步骤-5-发送端口信息"></a> 步骤 5. 发送端口信息。</h3>
<p>从服务器执行 <code>REPLCONF listening-port &lt;port-number&gt;</code> ，向主服务器发送从服务器的监听端口号。</p>
<h3 id="步骤-6-同步"><a class="markdownIt-Anchor" href="#步骤-6-同步"></a> 步骤 6. 同步。</h3>
<p>前文已介绍，此处不赘述。</p>
<h3 id="步骤-7-命令传播"><a class="markdownIt-Anchor" href="#步骤-7-命令传播"></a> 步骤 7. 命令传播。</h3>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务发送命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_coffset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>命令的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slave 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h2 id="六-复制的配置项"><a class="markdownIt-Anchor" href="#六-复制的配置项"></a> 六、复制的配置项</h2>
<p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p>
<p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul>
<li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li>
</ul>
<p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p>
<p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p>
<p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<ul>
<li><code>min-slaves-to-write &lt;number of slaves&gt;</code></li>
<li><code>min-slaves-max-lag &lt;number of seconds&gt;</code></li>
</ul>
<p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/459edbc1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/459edbc1.html" class="post-title-link" itemprop="url">Redis 哨兵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/459edbc1.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="459edbc1.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-哨兵"><a class="markdownIt-Anchor" href="#redis-哨兵"></a> Redis 哨兵</h1>
<blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案。</p>
<p>Redis 哨兵是 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md">Raft 算法</a> 的具体实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img" /></p>
<h2 id="一-哨兵简介"><a class="markdownIt-Anchor" href="#一-哨兵简介"></a> 一、哨兵简介</h2>
<p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png" alt="img" /></p>
<p>Sentinel 的主要功能如下：</p>
<ul>
<li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li>
<li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li>
</ul>
<h2 id="二-启动哨兵"><a class="markdownIt-Anchor" href="#二-启动哨兵"></a> 二、启动哨兵</h2>
<p>启动一个 Sentinel 可以使用下面任意一条命令，两条命令效果完全相同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>当一个 Sentinel 启动时，它需要执行以下步骤：</p>
<ol>
<li>初始化服务器。</li>
<li>使用 Sentinel 专用代码。</li>
<li>初始化 Sentinel 状态。</li>
<li>初始化 Sentinel 的主服务器列表。</li>
<li>创建连向被监视的主服务器的网络连接。</li>
</ol>
<p><strong>Sentinel 本质上是一个运行在特殊状模式下的 Redis 服务器</strong>。</p>
<p>Sentinel 模式下 Redis 服务器只支持 <code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>、<code>PUNSUBSCRIBE</code> 七个命令。</p>
<p>创建连向被监视的主服务器的网络连接，Sentinel 将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络：</p>
<ul>
<li>命令连接：专门用于向主服务器发送命令，并接受命令回复。</li>
<li>订阅连接：专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
<h2 id="三-监控"><a class="markdownIt-Anchor" href="#三-监控"></a> 三、监控</h2>
<h3 id="检测服务器状态"><a class="markdownIt-Anchor" href="#检测服务器状态"></a> 检测服务器状态</h3>
<blockquote>
<p><strong>Sentinel 向 Redis 服务器发送 <code>PING</code> 命令，检查其状态</strong>。</p>
</blockquote>
<p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<ul>
<li><strong>主观下线</strong>：<strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</li>
<li><strong>客观下线</strong>：<strong>客观下线</strong> 只适用于 <strong>主节点</strong>。当 <code>Sentinel</code> 将一个主服务器判断为主管下线后，为了确认这个主服务器是否真的下线，会向同样监视这一主服务器的其他 Sentinel 询问，看它们是否也认为主服务器已经下线。当足够数量的 Sentinel 认为主服务器已下线，就判定其为客观下线，并对其执行故障转移操作。
<ul>
<li><code>Sentinel</code> 节点通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。</li>
</ul>
</li>
</ul>
<h3 id="获取服务器信息"><a class="markdownIt-Anchor" href="#获取服务器信息"></a> 获取服务器信息</h3>
<blockquote>
<p><strong>Sentinel 向主服务器发送 <code>INFO</code> 命令，获取主服务器及它的从服务器信息</strong>。</p>
</blockquote>
<ul>
<li><strong>获取主服务器信息</strong> - Sentinel <strong>默认</strong>会以<strong>每十秒一次</strong>的频率，通过命令连接<strong>向被监视的主服务器发送 <code>INFO</code> 命令，并通过分析 <code>INFO</code> 命令的回复来获取主服务器的当前信息</strong>。
<ul>
<li>主服务自身信息：包括 run_id 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li>
<li>主服务的从服务器信息：包括 IP 地址和端口号</li>
</ul>
</li>
<li><strong>获取从服务器信息</strong> - 当 Sentinel 发现主服务器有新的从服务器出现时，Sentinel 除了会为这个新的从服务器创建相应的实例结构之外，Sentinel 还会创建连接到从服务器的命令连接和订阅连接。</li>
</ul>
<h2 id="四-通知"><a class="markdownIt-Anchor" href="#四-通知"></a> 四、通知</h2>
<p>对于每个与 Sentinel 连接的服务器，Sentinel 既会向服务器的 <code>__sentinel__:hello</code> 频道发送消息，也会订阅服务器的 <code>__sentinel__:hello</code> 频道的消息。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131153842.png" alt="img" /></p>
<h3 id="向服务器发送消息"><a class="markdownIt-Anchor" href="#向服务器发送消息"></a> 向服务器发送消息</h3>
<p>在默认情况下，Sentinel 会以每两秒一次的频率，通过命令向所有被监视的主服务器和从服务器发送以下格式的命令。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;<span class="tag">&lt;<span class="name">s_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_runid</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_epoch</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_name</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_epoch</span>&gt;</span>&quot;</span><br></pre></td></tr></table></figure>
<p>这条命令向服务器的 <code>__sentinel__:hello</code> 频道发送一条消息。</p>
<h3 id="接收服务器的消息"><a class="markdownIt-Anchor" href="#接收服务器的消息"></a> 接收服务器的消息</h3>
<p>当 Sentinel 与一个主服务器或从服务器建立起订阅连接后，Sentinel 就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE __sentinel__:hello</code>。</p>
<p>Sentinel 对 <code>__sentinel__:hello</code> 频道的订阅会一直持续到 Sentinel 与服务器断开连接为止。</p>
<h2 id="五-选举-leader"><a class="markdownIt-Anchor" href="#五-选举-leader"></a> 五、选举 Leader</h2>
<blockquote>
<p>Redis Sentinel 系统选举 Leader 的算法是 <a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft</a> 的实现。</p>
<p>Raft 是一种共识性算法，想了解其原理，可以参考 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md">深入剖析共识性算法 Raft</a>。</p>
</blockquote>
<p><strong>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头的 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作</strong>。</p>
<p>所有在线 Sentinel 都有资格被选为 Leader。</p>
<p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p>
<p>（1）每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（2）如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（3）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（4）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（5）在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（6）<code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（7）当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<blockquote>
<p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p>
</blockquote>
<h2 id="六-故障转移"><a class="markdownIt-Anchor" href="#六-故障转移"></a> 六、故障转移</h2>
<p>在选举产生出 Sentinel Leader 后，Sentinel Leader 将对已下线的主服务器执行故障转移操作。操作含以下三个步骤：</p>
<p>（一）<strong>选出新的主服务器</strong></p>
<p>故障转移第一步，是 Sentinel Leader 在已下线主服务属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器。然后，向这个从服务器发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务器。</p>
<p>Sentinel Leader 如何选出新的主服务器：</p>
<ul>
<li>删除列表中所有处于下线或断线状态的从服务器。</li>
<li>删除列表中所有最近五秒没有回复过 Sentinel Leader 的 INFO 命令的从服务器。</li>
<li>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds</code> * 10 毫秒的从服务器（<code>down-after-milliseconds</code> 指定了判断主服务器下线所需的时间）。</li>
<li>之后， Sentinel Leader 先选出优先级最高的从服务器；如果优先级一样高，再选择复制偏移量最大的从服务器；如果结果还不唯一，则选出运行 ID 最小的从服务器。</li>
</ul>
<p>（二）<strong>修改从服务器的复制目标</strong></p>
<p>选出新的主服务器后，Sentinel Leader 会向所有从服务器发送 <code>SLAVEOF</code> 命令，让它们去复制新的主服务器。</p>
<p>（三）<strong>将旧的主服务器变为从服务器</strong></p>
<p>Sentinel Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 SLAVEOF 命令，让其成为从服务器。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.web-lovers.com/redis-source-sentinel.html">渐进式解析 Redis 源码 - 哨兵 sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64">深入剖析 Redis 系列(二) - Redis 哨兵模式与高可用集群</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/174793d2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/174793d2.html" class="post-title-link" itemprop="url">Redis 集群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/174793d2.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="174793d2.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-集群"><a class="markdownIt-Anchor" href="#redis-集群"></a> Redis 集群</h1>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis 集群（Redis Cluster）</a> 是 Redis 官方提供的分布式数据库方案</strong>。</p>
<p>既然是分布式，自然具备分布式系统的基本特性：可扩展、高可用、一致性。</p>
<ul>
<li>Redis 集群通过划分 hash 槽来分区，进行数据分享。</li>
<li>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。</li>
<li>根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得，而 Redis 集群的选择是 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713100613.png" alt="img" /></p>
<h2 id="1-redis-cluster-分区"><a class="markdownIt-Anchor" href="#1-redis-cluster-分区"></a> 1. Redis Cluster 分区</h2>
<h3 id="11-集群节点"><a class="markdownIt-Anchor" href="#11-集群节点"></a> 1.1. 集群节点</h3>
<p>Redis 集群由多个节点组成，节点刚启动时，彼此是相互独立的。<strong>节点通过握手（ <code>CLUSTER MEET</code> 命令）来将其他节点添加到自己所处的集群中</strong>。</p>
<p>向一个节点发送 <code>CLUSTER MEET</code> 命令，可以让当前节点与指定 IP、PORT 的节点进行握手，握手成功时，当前节点会将指定节点加入所在集群。</p>
<p><strong>集群节点保存键值对以及过期时间的方式与单机 Redis 服务完全相同</strong>。</p>
<p>Redis 集群节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="12-分配-hash-槽"><a class="markdownIt-Anchor" href="#12-分配-hash-槽"></a> 1.2. 分配 Hash 槽</h3>
<p>分布式存储需要解决的首要问题是把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<p><strong>Redis 集群通过划分 hash 槽来将数据分区</strong>。Redis 集群通过分区的方式来保存数据库的键值对：<strong>集群的整个数据库被分为 16384 个哈希槽（slot）</strong>，数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。<strong>如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</strong>。</p>
<p>通过向节点发送 <a target="_blank" rel="noopener" href="https://redis.io/commands/cluster-addslots"><code>CLUSTER ADDSLOTS</code></a> 命令，可以将一个或多个槽指派给节点负责。</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="variable constant_">CLUSTER</span> <span class="variable constant_">ADDSLOTS</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5500</li>
<li>节点Ｂ存储的哈希槽范围是：5501 – 11000</li>
<li>节点Ｃ存储的哈希槽范围是：11001 – 16384</li>
</ul>
<h3 id="13-寻址"><a class="markdownIt-Anchor" href="#13-寻址"></a> 1.3. 寻址</h3>
<p>当客户端向节点发送与数据库键有关的命令时，接受命令的节点会<strong>计算出命令要处理的数据库属于哪个槽</strong>，并<strong>检查这个槽是否指派给了自己</strong>：</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么当前节点直接执行命令。</li>
<li>如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端重定向至正确的节点。</li>
</ul>
<h4 id="131-计算键属于哪个槽"><a class="markdownIt-Anchor" href="#131-计算键属于哪个槽"></a> 1.3.1. 计算键属于哪个槽</h4>
<p>决定一个 key 应该分配到那个槽的算法是：<strong>计算该 key 的 CRC16 结果再模 16834</strong>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">HASH_SLOT</span> = CRC16(KEY) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure>
<p>当节点计算出 key 所属的槽为 i 之后，节点会根据以下条件判断槽是否由自己负责：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">clusterState.slots[i] <span class="operator">=</span><span class="operator">=</span> clusterState.myself</span><br></pre></td></tr></table></figure>
<h4 id="132-moved-错误"><a class="markdownIt-Anchor" href="#132-moved-错误"></a> 1.3.2. MOVED 错误</h4>
<p>当节点发现键所在的槽并非自己负责处理的时候，节点就会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向正在负责槽的节点。</p>
<p><code>MOVED</code> 错误的格式为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">MOVED <span class="tag">&lt;<span class="name">slot</span>&gt;</span> <span class="tag">&lt;<span class="name">ip</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解：MOVED 这种操作有点类似 HTTP 协议中的重定向。</p>
</blockquote>
<h3 id="14-重新分区"><a class="markdownIt-Anchor" href="#14-重新分区"></a> 1.4. 重新分区</h3>
<p>Redis 集群的<strong>重新分区操作可以将任意数量的已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</strong>。</p>
<p>重新分区操作<strong>可以在线进</strong>行，在重新分区的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分区操作由 Redis 集群管理软件 <strong>redis-trib</strong> 负责执行的，redis-trib 通过向源节点和目标节点发送命令来进行重新分区操作。</p>
<p>重新分区的实现原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-cluster-trib.png" alt="img" /></p>
<h3 id="15-ask-错误"><a class="markdownIt-Anchor" href="#15-ask-错误"></a> 1.5. ASK 错误</h3>
<p><code>ASK</code> 错误与 <code>MOVED</code> 的区别在于：<strong>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施</strong>，在客户端收到关于槽 X 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 X 的命令请求发送至 ASK 错误所指示的节点，但这种转向不会对客户端今后发送关于槽 X 的命令请求产生任何影响，客户端仍然会将关于槽 X 的命令请求发送至目前负责处理槽 X 的节点，除非 ASK 错误再次出现。</p>
<p>判断 ASK 错误的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-ask.png" alt="img" /></p>
<h2 id="2-redis-cluster-故障转移"><a class="markdownIt-Anchor" href="#2-redis-cluster-故障转移"></a> 2. Redis Cluster 故障转移</h2>
<h3 id="21-复制"><a class="markdownIt-Anchor" href="#21-复制"></a> 2.1. 复制</h3>
<p>Redis 复制机制可以参考：<a href="docs/05.KV%E6%95%B0%E6%8D%AE%E5%BA%93/01.Redis/05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></p>
<h3 id="22-故障检测"><a class="markdownIt-Anchor" href="#22-故障检测"></a> 2.2. 故障检测</h3>
<p><strong>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</strong>。</p>
<p>节点的状态信息可以分为：</p>
<ul>
<li>
<p>在线状态；</p>
</li>
<li>
<p>下线状态（FAIL）;</p>
</li>
<li>
<p>疑似下线状态（PFAIL），即在规定的时间内，没有应答 PING 消息；</p>
</li>
</ul>
<h3 id="23-故障转移"><a class="markdownIt-Anchor" href="#23-故障转移"></a> 2.3. 故障转移</h3>
<ol>
<li>下线主节点的所有从节点中，会有一个从节点被选中。</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条 PONG 消息，告知其他节点这个从节点已变成主节点。</li>
</ol>
<h3 id="24-选举新的主节点"><a class="markdownIt-Anchor" href="#24-选举新的主节点"></a> 2.4. 选举新的主节点</h3>
<p>Redis 集群选举新的主节点流程基于<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e4bbe7e276c">共识算法：Raft</a></p>
<h2 id="3-redis-cluster-通信"><a class="markdownIt-Anchor" href="#3-redis-cluster-通信"></a> 3. Redis Cluster 通信</h2>
<p>集群中的节点通过发送和接收消息来进行通信。</p>
<p>Redis 集群节点发送的消息主要有以下五种：</p>
<ul>
<li><code>MEET</code> - 请求接收方加入发送方所在的集群。</li>
<li><code>PING</code> - 集群中每个节点每隔一段时间（默认为一秒）从已知节点列表中随机选出五个节点，然后对这五个节点中最久没联系的节点发送 PING 消息，以此检测被选中的节点是否在线。</li>
<li><code>PONG</code> - 当接收方收到发送方发来的 MEET 消息或 PING 消息时，会返回一条 PONG 消息作为应答。</li>
<li><code>FAIL</code> - 当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于节点 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。</li>
<li><code>PUBLISH</code> - 当节点收到一个 PUBLISH 命令时，节点会执行这个命令，并向集群广播一条 PUBLISH 消息，所有接受到这条消息的节点都会执行相同的 PUBLISH 命令。</li>
</ul>
<h2 id="4-redis-cluster-应用"><a class="markdownIt-Anchor" href="#4-redis-cluster-应用"></a> 4. Redis Cluster 应用</h2>
<h3 id="41-集群功能限制"><a class="markdownIt-Anchor" href="#41-集群功能限制"></a> 4.1. 集群功能限制</h3>
<p>Redis 集群相对 <strong>单机</strong>，存在一些功能限制，需要 <strong>开发人员</strong> 提前了解，在使用时做好规避。</p>
<ul>
<li>
<p><code>key</code> <strong>批量操作</strong> 支持有限：类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的 <code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的 <code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</p>
</li>
<li>
<p><code>key</code> <strong>事务操作</strong> 支持有限：只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</p>
</li>
<li>
<p><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</p>
</li>
<li>
<p>不支持 <strong>多数据库空间</strong>：<strong>单机</strong> 下的 Redis 可以支持 <code>16</code> 个数据库（<code>db0 ~ db15</code>），<strong>集群模式</strong> 下只能使用 <strong>一个</strong> 数据库空间，即 <code>db0</code>。</p>
</li>
<li>
<p><strong>复制结构</strong> 只支持一层：<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</p>
</li>
</ul>
<h3 id="42-集群规模限制"><a class="markdownIt-Anchor" href="#42-集群规模限制"></a> 4.2. 集群规模限制</h3>
<p>Redis Cluster 的优点是易于使用。分区、主从复制、弹性扩容这些功能都可以做到自动化，通过简单的部署就可以获得一个大容量、高可靠、高可用的 Redis 集群，并且对于应用来说，近乎于是透明的。</p>
<p>所以，<strong>Redis Cluster 非常适合构建中小规模 Redis 集群</strong>，这里的中小规模指的是，大概几个到几十个节点这样规模的 Redis 集群。</p>
<p>但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。</p>
<p>Redis 的每个节点上，都保存了所有槽和节点的映射关系表，客户端可以访问任意一个节点，再通过重定向命令，找到数据所在的那个节点。那么，这个映射关系表是如何更新的呢？Redis Cluster 采用了一种去中心化的流言 (Gossip) 协议来传播集群配置的变化。</p>
<p>Gossip 协议的优点是去中心化；缺点是传播速度慢，并且是集群规模越大，传播的越慢。</p>
<h3 id="43-集群配置"><a class="markdownIt-Anchor" href="#43-集群配置"></a> 4.3. 集群配置</h3>
<p>我们后面会部署一个 Redis 集群作为例子，在那之前，先介绍一下集群在 redis.conf 中的参数。</p>
<ul>
<li><strong>cluster-enabled</strong> <code>&lt;yes/no&gt;</code> - 如果配置”yes”则开启集群功能，此 redis 实例作为集群的一个节点，否则，它是一个普通的单一的 redis 实例。</li>
<li><strong>cluster-config-file</strong> <code>&lt;filename&gt;</code> - 注意：虽然此配置的名字叫“集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</li>
<li><strong>cluster-node-timeout</strong> <code>&lt;milliseconds&gt;</code> - 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。</li>
<li><strong>cluster-slave-validity-factor</strong> <code>&lt;factor&gt;</code> - 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。如果设置成正数，则 cluster-node-timeout 乘以 cluster-slave-validity-factor 得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，超过这个时间，从节点不会启动故障迁移。假设 cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过 50 秒，此从节点不能成为主节点。注意，如果此参数配置为非 0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作。</li>
<li><strong>cluster-migration-barrier</strong> <code>&lt;count&gt;</code> - 主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。</li>
<li><strong>cluster-require-full-coverage</strong> <code>&lt;yes/no&gt;</code> - 在部分 key 所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的 key 提供读操作。</li>
</ul>
<h2 id="5-其他-redis-集群方案"><a class="markdownIt-Anchor" href="#5-其他-redis-集群方案"></a> 5. 其他 Redis 集群方案</h2>
<p>Redis Cluster 不太适合用于大规模集群，所以，如果要构建超大 Redis 集群，需要选择替代方案。一般有三种方案类型：</p>
<ul>
<li>客户端分区方案</li>
<li>代理分区方案</li>
<li>查询路由方案</li>
</ul>
<h3 id="51-客户端分区方案"><a class="markdownIt-Anchor" href="#51-客户端分区方案"></a> 5.1. 客户端分区方案</h3>
<p><strong>客户端</strong> 就已经决定数据会被 <strong>存储</strong> 到哪个 Redis 节点或者从哪个 Redis 节点 <strong>读取数据</strong>。其主要思想是采用 <strong>哈希算法</strong> 将 Redis 数据的 <code>key</code> 进行散列，通过 <code>hash</code> 函数，特定的 <code>key</code>会 <strong>映射</strong> 到特定的 Redis 节点上。</p>
<p><strong>客户端分区方案</strong> 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis <strong>多实例集群</strong> 方法。Java 的 Redis 客户端驱动库 <a target="_blank" rel="noopener" href="https://github.com/redis/jedis"><strong>Jedis</strong></a>，支持 Redis Sharding 功能，即 ShardedJedis 以及 <strong>结合缓存池</strong> 的 ShardedJedisPool。</p>
<ul>
<li>
<p><strong>优点</strong>：不使用 <strong>第三方中间件</strong>，<strong>分区逻辑</strong> 可控，<strong>配置</strong> 简单，节点之间无关联，容易 <strong>线性扩展</strong>，灵活性强。</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>客户端</strong> 无法 <strong>动态增删</strong> 服务节点，客户端需要自行维护 <strong>分发逻辑</strong>，客户端之间 <strong>无连接共享</strong>，会造成 <strong>连接浪费</strong>。</p>
</li>
</ul>
<h3 id="52-代理分区方案"><a class="markdownIt-Anchor" href="#52-代理分区方案"></a> 5.2. 代理分区方案</h3>
<p><strong>客户端</strong> 发送请求到一个 <strong>代理组件</strong>，<strong>代理</strong> 解析 <strong>客户端</strong> 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<ul>
<li><strong>优点</strong>：简化 <strong>客户端</strong> 的分布式逻辑，<strong>客户端</strong> 透明接入，切换成本低，代理的 <strong>转发</strong> 和 <strong>存储</strong> 分离。</li>
<li><strong>缺点</strong>：多了一层 <strong>代理层</strong>，加重了 <strong>架构部署复杂度</strong> 和 <strong>性能损耗</strong>。</li>
</ul>
<p><strong>代理分区</strong> 主流实现的有方案有 <strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 和 <a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a>。</p>
<h4 id="521-twemproxy"><a class="markdownIt-Anchor" href="#521-twemproxy"></a> 5.2.1. Twemproxy</h4>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 也叫 <code>nutcraker</code>，是 Twitter 开源的一个 Redis 和 Memcache 的 <strong>中间代理服务器</strong> 程序。</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 作为 <strong>代理</strong>，可接受来自多个程序的访问，按照 <strong>路由规则</strong>，转发给后台的各个 Redis 服务器，再原路返回。<strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 存在 <strong>单点故障</strong> 问题，需要结合 Lvs 和 Keepalived 做 <strong>高可用方案</strong>。</p>
<ul>
<li><strong>优点</strong>：应用范围广，稳定性较高，中间代理层 <strong>高可用</strong>。</li>
<li><strong>缺点</strong>：无法平滑地 <strong>水平扩容/缩容</strong>，无 <strong>可视化管理界面</strong>，运维不友好，出现故障，不能 <strong>自动转移</strong>。</li>
</ul>
<h4 id="522-codis"><a class="markdownIt-Anchor" href="#522-codis"></a> 5.2.2. Codis</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 是一个 <strong>分布式</strong> Redis 解决方案，对于上层应用来说，连接 Codis-Proxy 和直接连接 <strong>原生的</strong> Redis-Server 没有的区别。<a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 底层会 <strong>处理请求的转发</strong>，不停机的进行 <strong>数据迁移</strong> 等工作。<a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 采用了无状态的 <strong>代理层</strong>，对于 <strong>客户端</strong> 来说，一切都是透明的。</p>
<ul>
<li>
<p><strong>优点</strong>：实现了上层 Proxy 和底层 Redis 的 <strong>高可用</strong>，<strong>数据分区</strong> 和 <strong>自动平衡</strong>，提供 <strong>命令行接口</strong> 和 RESTful API，提供 <strong>监控</strong> 和 <strong>管理</strong> 界面，可以动态 <strong>添加</strong> 和 <strong>删除</strong> Redis 节点。</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>部署架构</strong> 和 <strong>配置</strong> 复杂，不支持 <strong>跨机房</strong> 和 <strong>多租户</strong>，不支持 <strong>鉴权管理</strong>。</p>
</li>
</ul>
<h3 id="53-查询路由方案"><a class="markdownIt-Anchor" href="#53-查询路由方案"></a> 5.3. 查询路由方案</h3>
<p><strong>客户端随机地</strong> 请求任意一个 Redis 实例，然后由 Redis 将请求 <strong>转发</strong> 给 <strong>正确</strong> 的 Redis 节点。Redis Cluster 实现了一种 <strong>混合形式</strong> 的 <strong>查询路由</strong>，但并不是 <strong>直接</strong> 将请求从一个 Redis 节点 <strong>转发</strong> 到另一个 Redis 节点，而是在 <strong>客户端</strong> 的帮助下直接 <strong>重定向</strong>（ <code>redirected</code>）到正确的 Redis 节点。</p>
<ul>
<li>
<p><strong>优点</strong>：<strong>去中心化</strong>，数据按照 <strong>槽</strong> 存储分布在多个 Redis 实例上，可以平滑的进行节点 <strong>扩容/缩容</strong>，支持 <strong>高可用</strong> 和 <strong>自动故障转移</strong>，运维成本低。</p>
</li>
<li>
<p><strong>缺点</strong>：重度依赖 Redis-trib 工具，缺乏 <strong>监控管理</strong>，需要依赖 Smart Client (<strong>维护连接</strong>，<strong>缓存路由表</strong>，<code>MultiOp</code> 和 <code>Pipeline</code> 支持)。Failover 节点的 <strong>检测过慢</strong>，不如有 <strong>中心节点</strong> 的集群及时（如 ZooKeeper）。Gossip 消息采用广播方式，集群规模越大，开销越大。无法根据统计区分 <strong>冷热数据</strong>。</p>
</li>
</ul>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>中间件</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">Codis</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046801">后端存储实战课</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/redis-cluster-tutorial/">Redis 集群教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c869feb5581d">Redis 集群的原理和搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/3b589cea.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/3b589cea.html" class="post-title-link" itemprop="url">Redis 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/3b589cea.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="3b589cea.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>952</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-实战"><a class="markdownIt-Anchor" href="#redis-实战"></a> Redis 实战</h1>
<h2 id="一-应用场景"><a class="markdownIt-Anchor" href="#一-应用场景"></a> 一、应用场景</h2>
<p>Redis 可以应用于很多场景，这里列举几个经典的应用场景。</p>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<p>缓存是 Redis 最常见的应用场景。</p>
<p>Redis 有多种数据类型，以及丰富的操作命令，并且有着高性能、高可用的特性，非常适合用于分布式缓存。</p>
<blockquote>
<p>缓存应用的基本原理，请参考 <a target="_blank" rel="noopener" href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a> 第四 ~ 第六节内容。</p>
</blockquote>
<h3 id="bitmap-和-bloomfilter"><a class="markdownIt-Anchor" href="#bitmap-和-bloomfilter"></a> BitMap 和 BloomFilter</h3>
<p>Redis 除了 5 种基本数据类型外，还支持 BitMap 和 BloomFilter（即布隆过滤器，可以通过 Redis Module 支持）。</p>
<p>BitMap 和 BloomFilter 都可以用于解决缓存穿透问题。要点在于：过滤一些不可能存在的数据。</p>
<blockquote>
<p>什么是缓存穿透，可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a></p>
</blockquote>
<p>小数据量可以用 BitMap，大数据量可以用布隆过滤器。</p>
<h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3>
<p>使用 Redis 作为分布式锁，基本要点如下：</p>
<ul>
<li><strong>互斥性</strong> - 使用 <code>setnx</code> 抢占锁。</li>
<li><strong>避免永远不释放锁</strong> - 使用 <code>expire</code> 加一个过期时间，避免一直不释放锁，导致阻塞。</li>
<li><strong>原子性</strong> - setnx 和 expire 必须合并为一个原子指令，避免 setnx 后，机器崩溃，没来得及设置 expire，从而导致锁永不释放。</li>
</ul>
<blockquote>
<p>更多分布式锁的实现方式及细节，请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-lock.md">分布式锁基本原理</a></p>
</blockquote>
<h2 id="二-技巧"><a class="markdownIt-Anchor" href="#二-技巧"></a> 二、技巧</h2>
<p>根据 Redis 的特性，在实际应用中，存在一些应用小技巧。</p>
<h3 id="keys-和-scan"><a class="markdownIt-Anchor" href="#keys-和-scan"></a> keys 和 scan</h3>
<p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<p>如果这个 redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</p>
<p>首先，Redis 是单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p>
<p>这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<p>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 <code>SMEMBERS</code> 命令可以返回集合键当前包含的所有元素， 但是对于 <code>SCAN</code> 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5db66ed9e51d452a2f15d833">《我们一起进大厂》系列- Redis 基础</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ichunhui.github.io/fde825d1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="Jimmy">
      <meta itemprop="description" content="不忘初心，方得始终.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/fde825d1.html" class="post-title-link" itemprop="url">Redis 运维</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 18:42:50" itemprop="dateModified" datetime="2022-06-06T18:42:50+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/fde825d1.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="fde825d1.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-运维"><a class="markdownIt-Anchor" href="#redis-运维"></a> Redis 运维</h1>
<blockquote>
<p><strong>Redis</strong> 是一个高性能的 key-value 数据库。</p>
<p>SET 操作每秒钟 110000 次；GET 操作每秒钟 81000 次。</p>
</blockquote>
<h2 id="一-redis-安装"><a class="markdownIt-Anchor" href="#一-redis-安装"></a> 一、Redis 安装</h2>
<h3 id="window-下安装"><a class="markdownIt-Anchor" href="#window-下安装"></a> Window 下安装</h3>
<p><strong>下载地址：</strong><a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/releases">https://github.com/MSOpenTech/redis/releases</a>。</p>
<p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p>
<p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p>
<p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。</p>
<p>这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。</p>
<p>切换到 redis 目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p>
<h3 id="linux-下安装"><a class="markdownIt-Anchor" href="#linux-下安装"></a> Linux 下安装</h3>
<p><strong>下载地址：</strong> <a target="_blank" rel="noopener" href="http://redis.io/download%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E6%96%87%E6%A1%A3%E7%89%88%E6%9C%AC%E3%80%82">http://redis.io/download，下载最新文档版本。</a></p>
<p>下载、解压、编译 Redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br><span class="line">tar xzf redis-5.0.4.tar.gz</span><br><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>为了编译 Redis 源码，你需要 gcc-c++和 tcl。如果你的系统是 CentOS，可以直接执行命令：<code>yum install -y gcc-c++ tcl</code> 来安装。</p>
<p>进入到解压后的 <code>src</code> 目录，通过如下命令启动 Redis:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure>
<p>您可以使用内置的客户端与 Redis 进行交互:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">src/redis-cli</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash"><span class="built_in">set</span> foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">get foo</span></span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu-下安装"><a class="markdownIt-Anchor" href="#ubuntu-下安装"></a> Ubuntu 下安装</h3>
<p>在 Ubuntu 系统安装 Redis 可以使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>
<h3 id="开机启动"><a class="markdownIt-Anchor" href="#开机启动"></a> 开机启动</h3>
<ul>
<li>开机启动配置：<code>echo &quot;/usr/local/bin/redis-server /etc/redis.conf&quot; &gt;&gt; /etc/rc.local</code></li>
</ul>
<h3 id="开放防火墙端口"><a class="markdownIt-Anchor" href="#开放防火墙端口"></a> 开放防火墙端口</h3>
<ul>
<li>添加规则：<code>iptables -I INPUT -p tcp -m tcp --dport 6379 -j ACCEPT</code></li>
<li>保存规则：<code>service iptables save</code></li>
<li>重启 iptables：<code>service iptables restart</code></li>
</ul>
<h3 id="redis-安装脚本"><a class="markdownIt-Anchor" href="#redis-安装脚本"></a> Redis 安装脚本</h3>
<blockquote>
<p>CentOS7 环境安装脚本：<a target="_blank" rel="noopener" href="https://github.com/dunwu/linux-tutorial/tree/master/codes/linux/soft">软件运维配置脚本集合</a></p>
</blockquote>
<p><strong>安装说明</strong></p>
<ul>
<li>采用编译方式安装 Redis, 并将其注册为 systemd 服务</li>
<li>安装路径为：<code>/usr/local/redis</code></li>
<li>默认下载安装 <code>5.0.4</code> 版本，端口号为：<code>6379</code>，密码为空</li>
</ul>
<p><strong>使用方法</strong></p>
<ul>
<li>默认安装 - 执行以下任意命令即可：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br><span class="line">wget -qO- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义安装 - 下载脚本到本地，并按照以下格式执行：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh redis-install.sh [version] [port] [password]</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>version</code> - redis 版本号</li>
<li><code>port</code> - redis 服务端口号</li>
<li><code>password</code> - 访问密码</li>
</ul>
<h2 id="二-redis-单机使用和配置"><a class="markdownIt-Anchor" href="#二-redis-单机使用和配置"></a> 二、Redis 单机使用和配置</h2>
<h3 id="启动-redis"><a class="markdownIt-Anchor" href="#启动-redis"></a> 启动 Redis</h3>
<p><strong>启动 redis 服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p><strong>启动 redis 客户端</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure>
<p><strong>查看 redis 是否启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<p>以上命令将打开以下终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>以上说明我们已经成功启动了 redis。</p>
<h3 id="redis-常见配置"><a class="markdownIt-Anchor" href="#redis-常见配置"></a> Redis 常见配置</h3>
<blockquote>
<p>Redis 默认的配置文件是根目录下的 <code>redis.conf</code> 文件。</p>
<p>如果需要指定特定文件作为配置文件，需要使用命令： <code>./redis-server -c xxx.conf</code></p>
<p>每次修改配置后，需要重启才能生效。</p>
<p>Redis 官方默认配置：</p>
<ul>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.8/redis.conf">redis.conf for Redis 2.8</a></li>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.6/redis.conf">redis.conf for Redis 2.6</a>.</li>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.4/redis.conf">redis.conf for Redis 2.4</a>.</li>
</ul>
<p>自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。</p>
</blockquote>
<h3 id="设为守护进程"><a class="markdownIt-Anchor" href="#设为守护进程"></a> 设为守护进程</h3>
<p>Redis 默认以非守护进程方式启动，而通常我们会将 Redis 设为守护进程启动方式，配置：<code>daemonize yes</code></p>
<h4 id="远程访问"><a class="markdownIt-Anchor" href="#远程访问"></a> 远程访问</h4>
<p>Redis 默认绑定 127.0.0.1，这样就只能本机才能访问，若要 Redis 允许远程访问，需要配置：<code>bind 0.0.0.0</code></p>
<h4 id="设置密码"><a class="markdownIt-Anchor" href="#设置密码"></a> 设置密码</h4>
<p>Redis 默认访问不需要密码，如果需要设置密码，需要如下配置：</p>
<ul>
<li><code>protected-mode yes</code></li>
<li><code>requirepass &lt;密码&gt;</code></li>
</ul>
<h4 id="配置参数表"><a class="markdownIt-Anchor" href="#配置参数表"></a> 配置参数表</h4>
<table>
<thead>
<tr>
<th style="text-align:left">配置项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>daemonize no</code></td>
<td style="text-align:left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td style="text-align:left"><code>pidfile /var/run/redis.pid</code></td>
<td style="text-align:left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td style="text-align:left"><code>port 6379</code></td>
<td style="text-align:left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>bind 127.0.0.1</code></td>
<td style="text-align:left">绑定的主机地址</td>
</tr>
<tr>
<td style="text-align:left"><code>timeout 300</code></td>
<td style="text-align:left">当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td>
</tr>
<tr>
<td style="text-align:left"><code>loglevel notice</code></td>
<td style="text-align:left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td style="text-align:left"><code>logfile stdout</code></td>
<td style="text-align:left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td style="text-align:left"><code>databases 16</code></td>
<td style="text-align:left">设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id</td>
</tr>
<tr>
<td style="text-align:left"><code>save &lt;seconds&gt; &lt;changes&gt;</code> Redis 默认配置文件中提供了三个条件：<strong>save 900 1</strong>、<strong>save 300 10</strong>、<strong>save 60 10000</strong> 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td>
<td style="text-align:left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td style="text-align:left"><code>rdbcompression yes</code></td>
<td style="text-align:left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td style="text-align:left"><code>dbfilename dump.rdb</code></td>
<td style="text-align:left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td style="text-align:left"><code>dir ./</code></td>
<td style="text-align:left">指定本地数据库存放目录</td>
</tr>
<tr>
<td style="text-align:left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td style="text-align:left">设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td style="text-align:left"><code>masterauth &lt;master-password&gt;</code></td>
<td style="text-align:left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td style="text-align:left"><code>requirepass foobared</code></td>
<td style="text-align:left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 <code>AUTH &lt;password&gt;</code> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td style="text-align:left"><code>maxclients 128</code></td>
<td style="text-align:left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td style="text-align:left"><code>maxmemory &lt;bytes&gt;</code></td>
<td style="text-align:left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td style="text-align:left"><code>appendonly no</code></td>
<td style="text-align:left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td style="text-align:left"><code>appendfilename appendonly.aof</code></td>
<td style="text-align:left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td style="text-align:left"><code>appendfsync everysec</code></td>
<td style="text-align:left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-enabled no</code></td>
<td style="text-align:left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-swap-file /tmp/redis.swap</code></td>
<td style="text-align:left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-max-memory 0</code></td>
<td style="text-align:left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-page-size 32</code></td>
<td style="text-align:left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-pages 134217728</code></td>
<td style="text-align:left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-max-threads 4</code></td>
<td style="text-align:left">设置访问 swap 文件的线程数,最好不要超过机器的核数,如果设置为 0,那么所有对 swap 文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</td>
</tr>
<tr>
<td style="text-align:left"><code>glueoutputbuf yes</code></td>
<td style="text-align:left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td style="text-align:left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td style="text-align:left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td style="text-align:left"><code>activerehashing yes</code></td>
<td style="text-align:left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td style="text-align:left"><code>include /path/to/local.conf</code></td>
<td style="text-align:left">指定包含其它的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody>
</table>
<h3 id="压力测试"><a class="markdownIt-Anchor" href="#压力测试"></a> 压力测试</h3>
<blockquote>
<p>参考官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/benchmarks">How fast is Redis?</a></p>
</blockquote>
<p>Redis 自带了一个性能测试工具：<code>redis-benchmark</code></p>
<p><strong>（1）基本测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -q -n 100000</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-q</code> 表示静默（quiet）执行</li>
<li><code>-n 100000</code> 请求 10 万次</li>
</ul>
<p><strong>（2）测试指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-benchmark -t <span class="built_in">set</span>,lpush -n 100000 -q</span></span><br><span class="line">SET: 74239.05 requests per second</span><br><span class="line">LPUSH: 79239.30 requests per second</span><br></pre></td></tr></table></figure>
<p><strong>（3）测试 pipeline 模式下指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -n 1000000 -t set,get -P 16 -q</span><br><span class="line">SET: 403063.28 requests per second</span><br><span class="line">GET: 508388.41 requests per second</span><br></pre></td></tr></table></figure>
<h2 id="三-redis-集群使用和配置"><a class="markdownIt-Anchor" href="#三-redis-集群使用和配置"></a> 三、Redis 集群使用和配置</h2>
<p>Redis 3.0 后支持集群模式。</p>
<h3 id="集群规划"><a class="markdownIt-Anchor" href="#集群规划"></a> 集群规划</h3>
<p><code>Redis</code> 集群一般由 <strong>多个节点</strong> 组成，节点数量至少为 <code>6</code> 个，才能保证组成 <strong>完整高可用</strong> 的集群。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0d1c392?w=1467&amp;h=803&amp;f=png&amp;s=43428" alt="img" /></p>
<p>理想情况当然是所有节点各自在不同的机器上，首先于资源，本人在部署 Redis 集群时，只得到 3 台服务器。所以，我计划每台服务器部署 2 个 Redis 节点。</p>
<p>【示例】最简高可用 Redis 集群规划</p>
<p>机器配置：16G 内存 + 8 核 CPU + 1T 磁盘</p>
<p>Redis 进程分配 10 G 内存。一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>集群拓扑：三主三从；三哨兵，每个哨兵监听所有主节点。</p>
<p>估算性能：</p>
<ul>
<li>容量：三主，占用 30 G 内存，所以最大存储容量为 30 G。假设每条数据记录平均 大小为 10 K，则最大能存储 300 万条数据。</li>
<li>吞吐量：单机一般 TPS/QPS 为 五万到八万左右。假设为五万，那么三主三从架构理论上能达到 TPS 15 万，QPS 30 万。</li>
</ul>
<h3 id="部署集群"><a class="markdownIt-Anchor" href="#部署集群"></a> 部署集群</h3>
<blockquote>
<p>Redis 集群节点的安装与单节点服务相同，差异仅在于部署方式。</p>
<p>注意：为了演示方便，本示例将所有 Redis 集群节点都部署在一台机器上，实际生产环境中，基本都会将节点部署在不同机器上。要求更高的，可能还要考虑多机房部署。</p>
</blockquote>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/7001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7003</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7004</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7005</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7006</span><br></pre></td></tr></table></figure>
<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口号</span></span><br><span class="line">port 7001</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定的主机端口（0.0.0.0 表示允许远程访问）</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以守护进程方式启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群的配置，配置文件首次启动自动生成</span></span><br><span class="line">cluster-config-file /usr/local/redis/conf/7001/7001.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求超时时间，设置 10 秒</span></span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据存放目录</span></span><br><span class="line">dir /usr/local/redis/conf/7001</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进程文件</span></span><br><span class="line">pidfile /usr/local/redis/conf/7001/7001.pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件</span></span><br><span class="line">logfile /usr/local/redis/conf/7001/7001.log</span><br></pre></td></tr></table></figure>
<p>（3）批量启动 Redis 节点</p>
<p>Redis 的 utils/create-cluster 目录下自带了一个名为 create-cluster 的脚本工具，可以利用它来新建、启动、停止、重启 Redis 节点。</p>
<p>脚本中有几个关键参数：</p>
<ul>
<li><code>PORT</code>=30000 - 初始端口号</li>
<li><code>TIMEOUT</code>=2000 - 超时时间</li>
<li><code>NODES</code>=6 - 节点数</li>
<li><code>REPLICAS</code>=1 - 备份数</li>
</ul>
<p>脚本中的每个命令项会根据初始端口号，以及设置的节点数，遍历的去执行操作。</p>
<p>由于前面的规划中，节点端口是从 7001 ~ 7006，所以需要将 PORT 变量设为 7000。</p>
<p>脚本中启动每个 Redis 节点是通过指定命令行参数来配置属性。所以，我们需要改一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PORT=7000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6</span><br><span class="line">ENDPORT=$((PORT+NODES))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; == &quot;start&quot; ]</span><br><span class="line">then</span><br><span class="line">    while [ $((PORT &lt; ENDPORT)) != &quot;0&quot; ]; do</span><br><span class="line">        PORT=$((PORT+1))</span><br><span class="line">        echo &quot;Starting $PORT&quot;</span><br><span class="line">        /usr/local/redis/src/redis-server /usr/local/redis/conf/$&#123;PORT&#125;/redis.conf</span><br><span class="line">    done</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>好了，在每台服务器上，都执行 <code>./create-cluster start</code> 来启动节点。</p>
<p>然后，通过 ps 命令来确认 Redis 进程是否已经工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root @ dbClusterDev01 <span class="keyword">in</span> /usr/local/redis/conf [11:07:55]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep redis</span></span><br><span class="line">root      4604     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7001 [cluster]</span><br><span class="line">root      4609     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7002 [cluster]</span><br><span class="line">root      4614     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7003 [cluster]</span><br><span class="line">root      4619     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7004 [cluster]</span><br><span class="line">root      4624     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7005 [cluster]</span><br><span class="line">root      4629     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7006 [cluster]</span><br></pre></td></tr></table></figure>
<p>（4）启动集群</p>
<p>通过 <code>redis-cli --cluster create</code> 命令可以自动配置集群，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.2:7003 127.0.0.2:7004 127.0.0.3:7005 127.0.0.3:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p>redis-cluster 会根据设置的节点数和副本数自动分片（分配 Hash 虚拟槽 slot），如果满意，输入 yes ，直接开始分片。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.2:7004 to 127.0.0.1:7001</span><br><span class="line">Adding replica 127.0.0.3:7006 to 127.0.0.2:7003</span><br><span class="line">Adding replica 127.0.0.1:7002 to 127.0.0.3:7005</span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.2:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.2:7004</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.3:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.3:7006</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">....</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.1:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.1:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.1:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<p>（5）日常维护操作</p>
<ul>
<li>关闭集群 - <code>./create-cluster stop</code></li>
<li>检查集群是否健康（指定任意节点即可）：<code>./redis-cli --cluster check &lt;ip:port&gt;</code></li>
<li>尝试修复集群节点：<code>./redis-cli --cluster fix &lt;ip:port&gt;</code></li>
</ul>
<h3 id="部署哨兵"><a class="markdownIt-Anchor" href="#部署哨兵"></a> 部署哨兵</h3>
<p>redis-cluster 实现了 Redis 的分片、复制。</p>
<p>但 redis-cluster 没有解决故障转移问题，一旦任意分片的 Master 节点宕机、网络不通，就会导致 redis-cluster 的集群不能工作。为了解决高可用的问题，Redis 提供了 Redis 哨兵来监控 Redis 节点状态，并且会在 Master 宕机时，发起选举，将这个 Master 的一个 Slave 节点选举为 Master。</p>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/27001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27003</span><br></pre></td></tr></table></figure>
<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 27001</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor redis-master 172.22.6.3 7001 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 5000</span><br><span class="line">sentinel failover-timeout redis-master 900000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sentinel auth-pass redis-master 123456</span></span><br><span class="line">logfile /usr/local/redis/conf/27001/27001.log</span><br></pre></td></tr></table></figure>
<p>（3）批量启动哨兵节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27001/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27002/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27003/</span>sentinel.conf</span><br></pre></td></tr></table></figure>
<h3 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h3>
<p>（1）查看信息</p>
<p>进入任意节点</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">./redis-<span class="keyword">cli</span> -h <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span> -p <span class="number">7001</span></span><br></pre></td></tr></table></figure>
<p>cluster info 查看集群节点状态</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594528179852</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br></pre></td></tr></table></figure>
<p>cluster info 查看集群信息</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster info</span><br><span class="line"><span class="attribute">cluster_state</span>:ok</span><br><span class="line"><span class="attribute">cluster_slots_assigned</span>:<span class="number">16384</span></span><br><span class="line"><span class="attribute">cluster_slots_ok</span>:<span class="number">16384</span></span><br><span class="line"><span class="attribute">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">cluster_known_nodes</span>:<span class="number">6</span></span><br><span class="line"><span class="attribute">cluster_size</span>:<span class="number">3</span></span><br><span class="line"><span class="attribute">cluster_current_epoch</span>:<span class="number">6</span></span><br><span class="line"><span class="attribute">cluster_my_epoch</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_ping_sent</span>:<span class="number">3406</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_pong_sent</span>:<span class="number">3569</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_publish_sent</span>:<span class="number">5035</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_sent</span>:<span class="number">12010</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_ping_received</span>:<span class="number">3564</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_pong_received</span>:<span class="number">3406</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_meet_received</span>:<span class="number">5</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_publish_received</span>:<span class="number">5033</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_received</span>:<span class="number">12008</span></span><br></pre></td></tr></table></figure>
<p>（2）添加节点到集群</p>
<p>将已启动的节点实例添加到集群中</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>127.0.0.1:7007 127.0.0.1:7008</span><br></pre></td></tr></table></figure>
<p><strong>添加主节点</strong></p>
<p>添加一组主节点</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7007 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7008 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7009 172.22.6.3:7001</span><br></pre></td></tr></table></figure>
<p>查看节点状态</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529342575</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">55cacf121662833a4a19dbeb4a5df712cfedf77f</span> <span class="number">172.22.6.3:7009</span>@<span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529341573</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529343577</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">e5ba78fe629115977a74fbbe1478caf8868d6d55</span> <span class="number">172.22.6.3:7007</span>@<span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529341000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">79d4fffc2cec210556c3b4c44e63ab506e87eda3</span> <span class="number">172.22.6.3:7008</span>@<span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>
<p>可以发现，新加入的三个主节点，还没有分配哈希槽，所以，暂时还无法访问。</p>
<p><strong>添加从节点</strong></p>
<p>–slave：设置该参数，则新节点以 slave 的角色加入集群<br />
–master-id：这个参数需要设置了–slave 才能生效，–master-id 用来指定新节点的 master 节点。如果不设置该参数，则会随机为节点选择 master 节点。</p>
<p>语法</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span> 新节点IP地址：端口    存在节点IP：端口 --cluster-slave （从节点） --cluster-master-id （master节点的ID）</span><br><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>  10.42.141.119:6379  10.42.166.105:6379  --cluster-slave   --cluster-master-id  dfa238fff8a7a49230cff7eb74f573f5645c8ec5</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7010 172.22.6.3:7007 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7011 172.22.6.3:7008 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7012 172.22.6.3:7009 --cluster-slave</span><br></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">ef5c1b9ce4cc795dc12b2c1e8736a572647b4c3e</span> <span class="number">172.22.6.3:7011</span>@<span class="number">17011</span> slave <span class="number">79</span>d4fffc2cec210556c3b4c44e63ab506e87eda3 <span class="number">0</span> <span class="number">1594529492043</span> <span class="number">7</span> connected</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529491943</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">5140d1129ed850df59c51cf818c4eb74545d9959</span> <span class="number">172.22.6.3:7010</span>@<span class="number">17010</span> slave e5ba78fe629115977a74fbbe1478caf8868d6d55 <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">55cacf121662833a4a19dbeb4a5df712cfedf77f</span> <span class="number">172.22.6.3:7009</span>@<span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">8</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529490000</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529489939</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">e5ba78fe629115977a74fbbe1478caf8868d6d55</span> <span class="number">172.22.6.3:7007</span>@<span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529490942</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">02e9f57b5b45c350dc57acf1c8efa8db136db7b7</span> <span class="number">172.22.6.3:7012</span>@<span class="number">17012</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">79d4fffc2cec210556c3b4c44e63ab506e87eda3</span> <span class="number">172.22.6.3:7008</span>@<span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>
<p>分配哈希槽</p>
<p>执行 <code>./redis-cli --cluster rebalance 172.22.6.3:7001 --cluster-threshold 1 --cluster-use-empty-masters</code></p>
<p>参数说明：</p>
<p>rebalance：表明让 Redis 自动根据节点数进行均衡哈希槽分配。</p>
<p>–cluster-use-empty-masters：表明</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712125827.png" alt="img" /></p>
<p>执行结束后，查看状态：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712130234.png" alt="img" /></p>
<h2 id="四-redis-命令"><a class="markdownIt-Anchor" href="#四-redis-命令"></a> 四、Redis 命令</h2>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3>
<blockquote>
<p>命令详细用法，请参考 <a target="_blank" rel="noopener" href="https://redis.io/commands"><strong>Redis 命令官方文档</strong></a></p>
<p>搬迁两张 cheat sheet 图，原址：<a target="_blank" rel="noopener" href="https://www.cheatography.com/tasjaevan/cheat-sheets/redis/">https://www.cheatography.com/tasjaevan/cheat-sheets/redis/</a></p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0b8ea57?w=2230&amp;h=2914&amp;f=png&amp;s=246433" alt="img" /></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0e9ba3c?w=2229&amp;h=2890&amp;f=png&amp;s=192997" alt="img" /></p>
<h3 id="集群命令"><a class="markdownIt-Anchor" href="#集群命令"></a> 集群命令</h3>
<ul>
<li><strong>集群</strong>
<ul>
<li><code>cluster info</code> - 打印集群的信息</li>
<li><code>cluster nodes</code> - 列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li>
</ul>
</li>
<li><strong>节点</strong>
<ul>
<li><code>cluster meet &lt;ip&gt; &lt;port&gt;</code> - 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</li>
<li><code>cluster forget &lt;node_id&gt;</code> - 从集群中移除 node_id 指定的节点。</li>
<li><code>cluster replicate &lt;node_id&gt;</code> - 将当前节点设置为 node_id 指定的节点的从节点。</li>
<li><code>cluster saveconfig</code> - 将节点的配置文件保存到硬盘里面。</li>
</ul>
</li>
<li><strong>槽(slot)</strong>
<ul>
<li><code>cluster addslots &lt;slot&gt; [slot ...]</code> - 将一个或多个槽（ slot）指派（ assign）给当前节点。</li>
<li><code>cluster delslots &lt;slot&gt; [slot ...]</code> - 移除一个或多个槽对当前节点的指派。</li>
<li><code>cluster flushslots</code> - 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li>
<li><code>cluster setslot &lt;slot&gt; node &lt;node_id&gt;</code> - 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。</li>
<li><code>cluster setslot &lt;slot&gt; migrating &lt;node_id&gt;</code> - 将本节点的槽 slot 迁移到 node_id 指定的节点中。</li>
<li><code>cluster setslot &lt;slot&gt; importing &lt;node_id&gt;</code> - 从 node_id 指定的节点中导入槽 slot 到本节点。</li>
<li><code>cluster setslot &lt;slot&gt; stable</code> - 取消对槽 slot 的导入（ import）或者迁移（ migrate）。</li>
</ul>
</li>
<li><strong>键</strong>
<ul>
<li><code>cluster keyslot &lt;key&gt;</code> - 计算键 key 应该被放置在哪个槽上。</li>
<li><code>cluster countkeysinslot &lt;slot&gt;</code> - 返回槽 slot 目前包含的键值对数量。</li>
<li><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code> - 返回 count 个 slot 槽中的键。</li>
</ul>
</li>
</ul>
<h4 id="重新分片"><a class="markdownIt-Anchor" href="#重新分片"></a> 重新分片</h4>
<p>添加节点：./redis-cli --cluster add-node 192.168.1.136:7007 192.168.1.136:7001 --cluster-slave</p>
<p>redis-cli --cluster reshard 172.22.6.3 7001</p>
<h2 id="五-客户端"><a class="markdownIt-Anchor" href="#五-客户端"></a> 五、客户端</h2>
<p>推荐使用 <a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager"><strong>RedisDesktopManager</strong></a></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jimmy"
      src="/images/avatar2.gif">
  <p class="site-author-name" itemprop="name">Jimmy</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ichunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ichunhui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hustzch@163.com" title="E-Mail → mailto:hustzch@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备17019300号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jimmy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jimmyblog-2.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
